Bottom: 5b5f08a6caf0def0aa3e31ecd61794ef0a9c6c49
Top:    192f7a223097518c76a7464b57970c278459c074
Author: Jon Smirl <jonsmirl@terra>
Date:   2012-03-17 22:29:23 -0400

Changes to support SPL


---

diff --git a/arch/arm/cpu/arm926ejs/cpu.c b/arch/arm/cpu/arm926ejs/cpu.c
index 5c902df..73f0512 100644
--- a/arch/arm/cpu/arm926ejs/cpu.c
+++ b/arch/arm/cpu/arm926ejs/cpu.c
@@ -37,6 +37,10 @@ static void cache_flush(void);
 
 int cleanup_before_linux (void)
 {
+#ifdef CONFIG_USB_DEVICE
+	extern void udc_shutdown (void);
+	udc_shutdown();
+#endif
 	/*
 	 * this function is called just before we call linux
 	 * it prepares the processor for linux
diff --git a/arch/arm/cpu/arm926ejs/lpc313x/Makefile b/arch/arm/cpu/arm926ejs/lpc313x/Makefile
new file mode 100644
index 0000000..5051ccb
--- /dev/null
+++ b/arch/arm/cpu/arm926ejs/lpc313x/Makefile
@@ -0,0 +1,63 @@
+#
+# (C) Copyright 2000-2006
+# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= $(obj)lib$(SOC).o
+
+COBJS	= timer.o
+COBJS	+= serial.o
+COBJS	+= clock.o
+COBJS	+= mci.o
+COBJS	+= dos_partition.o
+COBJS	+= spi.o
+COBJS   += usbdfu.o
+ifndef CONFIG_SPL_BUILD
+COBJS   += usbpoll.o
+COBJS	+= init.o
+COBJS	+= i2c.o
+COBJS	+= nand_params.o
+COBJS	+= nand_format.o
+COBJS	+= crc32.o
+else
+CFLAGS += -DUBOOT_FILESIZE=$(shell stat -c%s $(TOPDIR)/u-boot.img)
+COBJS	+= spl.o
+endif
+
+SRCS	:= $(SOBJS:.o=.S) $(COBJS:.o=.c)
+OBJS	:= $(addprefix $(obj),$(COBJS) $(SOBJS))
+
+all:	$(obj).depend $(LIB)
+
+$(LIB):	$(OBJS)
+	$(call cmd_link_o_target, $(OBJS))
+
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff --git a/arch/arm/cpu/arm926ejs/lpc313x/Makefile~patched b/arch/arm/cpu/arm926ejs/lpc313x/Makefile~patched
new file mode 100644
index 0000000..c0b59c9
--- /dev/null
+++ b/arch/arm/cpu/arm926ejs/lpc313x/Makefile~patched
@@ -0,0 +1,59 @@
+#
+# (C) Copyright 2000-2006
+# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= $(obj)lib$(CPU).a
+
+START	= start.o
+COBJS	= cpu.o
+COBJS	+= timer.o
+COBJS	+= serial.o
+COBJS	+= clock.o
+COBJS	+= init.o
+COBJS	+= i2c.o
+COBJS	+= mci.o
+COBJS	+= dos_partition.o
+COBJS	+= spi.o
+COBJS	+= nand_params.o
+COBJS	+= nand_format.o
+COBJS	+= crc32.o
+COBJS   += usbpoll.o
+
+SRCS	:= $(START:.o=.S) $(SOBJS:.o=.S) $(COBJS:.o=.c)
+OBJS	:= $(addprefix $(obj),$(SOBJS) $(COBJS))
+START	:= $(addprefix $(obj),$(START))
+
+all:	$(obj).depend $(START) $(LIB)
+
+$(LIB):	$(OBJS)
+	$(AR) $(ARFLAGS) $@ $(OBJS)
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff --git a/arch/arm/cpu/arm926ejs/lpc313x/clock.c b/arch/arm/cpu/arm926ejs/lpc313x/clock.c
new file mode 100644
index 0000000..44d04c4
--- /dev/null
+++ b/arch/arm/cpu/arm926ejs/lpc313x/clock.c
@@ -0,0 +1,542 @@
+/*
+ * (C) Copyright 2010 NXP Semiconductors
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <asm/arch/hardware.h>
+#include <asm/arch/clock.h>
+
+
+static ulong  cgu_clkid2esrid(u32 clkid)
+{
+	ulong esrIndex = (ulong )clkid;
+
+	switch (clkid) {
+	case CGU_SB_I2SRX_BCK0_ID:
+	case CGU_SB_I2SRX_BCK1_ID:
+	case CGU_SB_SYSCLK_O_ID:
+			/* invalid esr index. No ESR register for these clocks */
+		esrIndex = CGU_INVALID_ID;
+		break;
+
+	case CGU_SB_SPI_CLK_ID:
+	case CGU_SB_SPI_CLK_GATED_ID:
+		esrIndex = esrIndex - 2;
+		break;
+	default:
+		/* do nothing */
+		break;
+	}
+
+	return esrIndex;
+}
+
+
+
+static void cgu_ClkId2DomainId(u32 clkid, u32* pDomainId,
+		ulong * pSubdomainId)
+{
+	ulong esrIndex, esrReg;
+	ulong fracdiv_base = CGU_INVALID_ID;
+
+	/* 1. Get the domain ID */
+
+	if (clkid <= CGU_SYS_LAST) {
+		*pDomainId = CGU_SB_SYS_BASE_ID;
+		fracdiv_base = CGU_SB_BASE0_FDIV_LOW_ID;
+
+	}
+	else if (clkid <= CGU_AHB0APB0_LAST) {
+		*pDomainId = CGU_SB_AHB0_APB0_BASE_ID;
+		fracdiv_base = CGU_SB_BASE1_FDIV_LOW_ID;
+
+	}
+	else if (clkid <= CGU_AHB0APB1_LAST) {
+		*pDomainId = CGU_SB_AHB0_APB1_BASE_ID;
+		fracdiv_base = CGU_SB_BASE2_FDIV_LOW_ID;
+
+	}
+	else if (clkid <= CGU_AHB0APB2_LAST) {
+		*pDomainId = CGU_SB_AHB0_APB2_BASE_ID;
+		fracdiv_base = CGU_SB_BASE3_FDIV_LOW_ID;
+
+	}
+	else if (clkid <= CGU_AHB0APB3_LAST) {
+		*pDomainId = CGU_SB_AHB0_APB3_BASE_ID;
+		fracdiv_base = CGU_SB_BASE4_FDIV_LOW_ID;
+
+	}
+	else if (clkid == CGU_PCM_LAST) {
+		*pDomainId = CGU_SB_PCM_BASE_ID;
+		fracdiv_base = CGU_SB_BASE5_FDIV_LOW_ID;
+
+	}
+	else if (clkid == CGU_UART_LAST) {
+		*pDomainId = CGU_SB_UART_BASE_ID;
+		fracdiv_base = CGU_SB_BASE6_FDIV_LOW_ID;
+
+	}
+	else if (clkid <= CGU_CLK1024FS_LAST) {
+		*pDomainId = CGU_SB_CLK1024FS_BASE_ID;
+		fracdiv_base = CGU_SB_BASE7_FDIV_LOW_ID;
+
+	}
+	else if (clkid == CGU_I2SRX_BCK0_LAST) {
+		*pDomainId = CGU_SB_I2SRX_BCK0_BASE_ID;
+		fracdiv_base = CGU_INVALID_ID;
+
+	}
+	else if (clkid == CGU_I2SRX_BCK1_LAST) {
+		*pDomainId = CGU_SB_I2SRX_BCK1_BASE_ID;
+		fracdiv_base = CGU_INVALID_ID;
+
+	}
+	else if (clkid <= CGU_SPI_LAST) {
+		*pDomainId = CGU_SB_SPI_CLK_BASE_ID;
+		fracdiv_base = CGU_SB_BASE10_FDIV_LOW_ID;
+
+	}
+	else {
+		*pDomainId = CGU_SB_SYSCLK_O_BASE_ID;
+		fracdiv_base = CGU_INVALID_ID;
+	}
+
+	*pSubdomainId = CGU_INVALID_ID;
+
+	/* read the clocks ESR to get the fractional divider */
+	esrIndex = cgu_clkid2esrid(clkid);
+
+	if (CGU_INVALID_ID != esrIndex) {
+		/* read the clocks ESR to get the fractional divider */
+		esrReg = CGU_SB->clk_esr[esrIndex];
+
+		/* A clock may not be connected to any sub-domain and it might be
+		 * connected directly to domain. This is also a valid combination. So,
+		 * errror should not be returned
+		 */
+		if (esrReg & CGU_SB_ESR_ENABLE) {
+			*pSubdomainId = CGU_SB_ESR_SEL_GET(esrReg) + fracdiv_base;
+		}
+	}
+
+}
+
+void cgu_reset_all_clks(void)
+{
+	u32 domainId;
+	ulong esr_id;
+	ulong enable, i;
+
+	/* switch reference clock in to FFAST */
+	for (domainId = CGU_SB_BASE_FIRST; domainId < CGU_SB_NR_BASE; domainId++) 
+		cgu_set_base_freq(domainId, CGU_FIN_SELECT_FFAST);
+	
+	/* disable all BCRs */
+	for (i = 0; i < CGU_SB_NR_BCR; i++) 
+		CGU_SB->base_bcr[i] = 0;
+	
+	/* disable all clocks except the needed ones */
+	for (i = 0; i < (CGU_SYSCLK_O_LAST + 1); i++) {
+		/* Clear the clocks ESR to deselect fractional divider */
+		esr_id = cgu_clkid2esrid((u32)i);
+
+		if (CGU_INVALID_ID != esr_id) {
+			CGU_SB->clk_esr[esr_id] = 0;
+		}
+
+		if (i < 31) {
+			enable = CGU_DEF_CLKS_0_31 & (1<<i);
+		}
+		else {
+			if (i < 63) {
+				enable = CGU_DEF_CLKS_32_63 & (1<<(i - 32));
+			}
+			else {
+				enable = CGU_DEF_CLKS_64_92 & (1<<(i - 64));
+			}
+		}
+		/* 
+		 * set external enable for all possible clocks to conserve
+		 * power. cgu_clk_set_exten() function sets CGU_SB_PCR_EXTEN_EN
+		 * for allowed clocks only.
+		 */
+		cgu_clk_set_exten((u32)i, 1);
+
+		/* set enable-out’s for only the following clocks */
+		if ((i == CGU_SB_ARM926_BUSIF_CLK_ID) ||
+				(i == CGU_SB_MPMC_CFG_CLK_ID)) {
+			CGU_SB->clk_pcr[i] |= CGU_SB_PCR_ENOUT_EN;
+		}
+		else {
+			CGU_SB->clk_pcr[i] &= ~CGU_SB_PCR_ENOUT_EN;
+		}
+
+		/* disable all clocks except the needed ones */
+		if (enable) {
+			CGU_SB->clk_pcr[i] |= CGU_SB_PCR_RUN;
+		}
+		else {
+			CGU_SB->clk_pcr[i] &= ~CGU_SB_PCR_RUN;
+		}
+	}
+	/* disable all fractional dividers */
+	for (i = 0; i < CGU_SB_NR_FRACDIV; i++) {
+		CGU_SB->base_fdc[i] &= ~CGU_SB_FDC_RUN;
+	}
+}
+
+long cgu_init_clks(u32 fidv_val[], u32 fdiv_clks[])
+{
+	
+	u32 domain_id = 0, fd_id = 0, clk_id = 0, esr_id=0;
+	u32 clk_start = 0, fdiv_start = 0;
+	u32 clk_last = CGU_SYS_LAST, fdiv_last = CGU_SB_BASE0_FDIV_HIGH_ID;
+	u32 bcr_id;
+
+	/* reset all clocks and connect them to FFAST */
+	cgu_reset_all_clks();
+
+	/* now init all fractional dividers */
+	while ( domain_id < CGU_SB_NR_BASE) {
+
+		if (domain_id == CGU_SB_SYS_BASE_ID) {
+			clk_last = CGU_SYS_LAST;
+			fdiv_last = CGU_SB_BASE0_FDIV_HIGH_ID;
+
+		} else if (domain_id == CGU_SB_AHB0_APB0_BASE_ID) {
+			clk_last = CGU_AHB0APB0_LAST;
+			fdiv_last = CGU_SB_BASE1_FDIV_HIGH_ID;
+
+		} else if (domain_id == CGU_SB_AHB0_APB1_BASE_ID) {
+			clk_last = CGU_AHB0APB1_LAST;
+			fdiv_last = CGU_SB_BASE2_FDIV_HIGH_ID;
+
+		} else if (domain_id == CGU_SB_AHB0_APB2_BASE_ID) {
+			clk_last = CGU_AHB0APB2_LAST;
+			fdiv_last = CGU_SB_BASE3_FDIV_HIGH_ID;
+
+		} else if (domain_id == CGU_SB_AHB0_APB3_BASE_ID) {
+			clk_last = CGU_AHB0APB3_LAST;
+			fdiv_last = CGU_SB_BASE4_FDIV_HIGH_ID;
+
+		} else if (domain_id == CGU_SB_PCM_BASE_ID) {
+			clk_last = CGU_PCM_LAST;
+			fdiv_last = CGU_SB_BASE5_FDIV_HIGH_ID;
+
+		} else if (domain_id == CGU_SB_UART_BASE_ID) {
+			clk_last = CGU_UART_LAST;
+			fdiv_last = CGU_SB_BASE6_FDIV_HIGH_ID;
+
+		} else if (domain_id == CGU_SB_CLK1024FS_BASE_ID) {
+			clk_last = CGU_CLK1024FS_LAST;
+			fdiv_last = CGU_SB_BASE7_FDIV_HIGH_ID;
+
+		} else if (domain_id == CGU_SB_SPI_CLK_BASE_ID) {
+			clk_last = CGU_SPI_LAST;
+			fdiv_last = CGU_SB_BASE10_FDIV_HIGH_ID;
+
+		} else
+			clk_id++;
+	
+		fd_id = fdiv_start;
+		while (fd_id <= fdiv_last) {
+			/* enable frac divider only if it has valid settings. Or else it may be unused*/
+			if (fidv_val[fd_id] != 0) {
+				clk_id = clk_start;
+				/* select frac div for each clock in this sub domain*/
+				while (clk_id <= clk_last) {
+					if (fdiv_clks[fd_id] & (1 << (clk_id - clk_start))) {
+						/* Get esr_id. No need to check return id since 
+						 * if we are here we will have esr_id for clk_id
+						 */
+						esr_id = cgu_clkid2esrid(clk_id); 
+						/* finally configure the clock*/
+						CGU_SB->clk_esr[esr_id] = CGU_SB_ESR_SELECT((fd_id - fdiv_start) ) |
+										CGU_SB_ESR_ENABLE;
+					}
+					clk_id++;
+				}
+				/* enable frac divider */
+				CGU_SB->base_fdc[fd_id] = fidv_val[fd_id] | CGU_SB_FDC_RUN;
+			}
+			clk_id = clk_last + 1;
+			fd_id++;
+		}
+		clk_start = clk_id;
+		fdiv_start = fd_id;
+		domain_id++;
+	}
+
+	/* enable dynamic divider for SYS_BASE for dynamic clock scaling */
+	for (fd_id = 0; fd_id < CGU_SB_NR_DYN_FDIV; fd_id++) {
+		CGU_SB->base_dyn_fdc[fd_id] = fidv_val[CGU_SB_NR_FRACDIV + fd_id];
+		CGU_SB->base_dyn_sel[fd_id] = fdiv_clks[CGU_SB_NR_FRACDIV + fd_id];
+	}
+
+	for (bcr_id = 0; bcr_id < CGU_SB_NR_BCR; bcr_id++) {
+		/* enable BCR for domain */
+		CGU_SB->base_bcr[bcr_id] = CGU_SB_BCR_FD_RUN;
+	}
+	/* select input for domain. All have FFAST so just domains which need PLL clocks.*/
+	cgu_set_base_freq(CGU_SB_SYS_BASE_ID, CGU_FIN_SELECT_HPPLL1);
+	cgu_set_base_freq(CGU_SB_AHB0_APB2_BASE_ID, CGU_FIN_SELECT_HPPLL1);
+	cgu_set_base_freq(CGU_SB_PCM_BASE_ID, CGU_FIN_SELECT_HPPLL1);
+	cgu_set_base_freq(CGU_SB_SPI_CLK_BASE_ID, CGU_FIN_SELECT_HPPLL1);
+	cgu_set_base_freq(CGU_SB_CLK1024FS_BASE_ID, CGU_FIN_SELECT_HPPLL0);
+	cgu_set_base_freq(CGU_SB_I2SRX_BCK0_BASE_ID, CGU_FIN_SELECT_XT_I2SRX_BCK0);
+	cgu_set_base_freq(CGU_SB_I2SRX_BCK1_BASE_ID, CGU_FIN_SELECT_XT_I2SRX_BCK1);
+
+
+	return 0;
+}
+
+void cgu_clk_set_exten(u32 clkid, ulong enable)
+{
+	switch (clkid) {
+	case CGU_SB_OTP_PCLK_ID:
+	case CGU_SB_PCM_APB_PCLK_ID:
+	case CGU_SB_EVENT_ROUTER_PCLK_ID:
+	case CGU_SB_ADC_PCLK_ID:
+	case CGU_SB_IOCONF_PCLK_ID:
+	case CGU_SB_CGU_PCLK_ID:
+	case CGU_SB_SYSCREG_PCLK_ID:
+	case CGU_SB_DMA_CLK_GATED_ID:
+	case CGU_SB_SPI_PCLK_GATED_ID:
+	case CGU_SB_SPI_CLK_GATED_ID:
+	case CGU_SB_PCM_CLK_IP_ID:
+	case CGU_SB_PWM_PCLK_REGS_ID:
+		if (enable) {
+			CGU_SB->clk_pcr[clkid] |= CGU_SB_PCR_EXTEN_EN;
+		}
+		else {
+			CGU_SB->clk_pcr[clkid] &= ~CGU_SB_PCR_EXTEN_EN;
+		}
+		break;
+		/* force disable for the following clocks */
+	case CGU_SB_I2C0_PCLK_ID:
+	case CGU_SB_I2C1_PCLK_ID:
+	case CGU_SB_WDOG_PCLK_ID:
+	case CGU_SB_UART_APB_CLK_ID:
+	case CGU_SB_LCD_PCLK_ID:
+		CGU_SB->clk_pcr[clkid] &= ~CGU_SB_PCR_EXTEN_EN;
+		break;
+	default:
+		break;
+	}
+}
+
+void cgu_set_base_freq(u32 baseid, ulong  fin_sel)
+{
+	ulong baseSCR;
+
+	/* Switch configuration register*/
+	baseSCR = CGU_SB->base_scr[baseid] & ~CGU_SB_SCR_FS_MASK;
+	/* If fs1 is currently enabled set refId to fs2 and enable fs2*/
+	if (CGU_SB->base_ssr[baseid] & CGU_SB_SCR_EN1) {
+		/* check if the selcted frequency is same as requested. If not switch.*/
+		if (CGU_SB->base_fs1[baseid] != fin_sel) {
+			CGU_SB->base_fs2[baseid] = fin_sel;
+
+			/* Don't touch stop bit in SCR register*/
+			CGU_SB->base_scr[baseid] = baseSCR | CGU_SB_SCR_EN2;
+		}
+	}
+	else {
+		/* check if the selcted frequency is same as requested. If not switch.*/
+		if (CGU_SB->base_fs2[baseid] != fin_sel) {
+			CGU_SB->base_fs1[baseid] = fin_sel;
+
+			/* Don't touch stop bit in SCR register*/
+			CGU_SB->base_scr[baseid] = baseSCR | CGU_SB_SCR_EN1;
+		}
+	}
+}
+
+ulong cgu_get_clk_freq(u32 clkid)
+{
+	ulong freq = 0;
+	u32 domainId;
+	ulong subDomainId;
+	long n, m;
+	ulong fdcVal;
+
+	/* get domain and frac div info for the clock */
+	cgu_ClkId2DomainId(clkid, &domainId, &subDomainId);
+
+	/* get base frequency for the domain */
+	if(CGU_SB_SSR_FS_GET(CGU_SB->base_ssr[domainId]) == CGU_FIN_SELECT_FFAST)
+		freq = XTAL_IN;
+	else if (CGU_SB_SSR_FS_GET(CGU_SB->base_ssr[domainId]) == CGU_FIN_SELECT_HPPLL1)
+		freq = PLL_FREQUENCY;
+	else
+		freq = 0;
+
+	/* direct connection has no fraction divider*/
+	if (subDomainId == CGU_INVALID_ID) {
+		return freq;
+	}
+	/* read frac div control register value */
+	fdcVal = CGU_SB->base_fdc[subDomainId];
+
+	/* Is the fracdiv enabled ?*/
+	if (fdcVal & CGU_SB_FDC_RUN) {
+		long msub, madd;
+
+		if (subDomainId != CGU_SB_BASE7_FDIV_LOW_ID) {
+			msub = CGU_SB_FDC_MSUB_GET(fdcVal);
+			madd = CGU_SB_FDC_MADD_GET(fdcVal);
+		}
+		else {
+			msub = CGU_SB_FDC17_MSUB_GET(fdcVal);
+			madd = CGU_SB_FDC17_MADD_GET(fdcVal);
+		}
+
+		/* remove trailing zeros */
+		while (!(msub & 1)  && !(madd & 1)) {
+			madd = madd >> 1;
+			msub = msub >> 1;
+		}
+		/* compute m and n values */
+		n = - msub;
+		m = madd + n;
+		/* check m and n are non-zero values */
+		if ((n == 0) || (m == 0)) {
+			return 0;
+		}
+		/* calculate the frequency based on m and n values */
+		freq = (freq * n) / m ;
+	}
+
+	return freq;
+}
+
+void cgu_hpll_config(u32 pllid, CGU_HPLL_SETUP_T *pllinfo)
+{
+	CGU_HP_CFG_REGS* hppll;
+	ulong switched_domains = 0;
+	u32 domainId;
+
+	/**********************************************************
+	 * switch domains connected to HPLL to FFAST automatically
+	 ***********************************************************/
+	for (domainId = CGU_SB_BASE_FIRST; domainId < CGU_SB_NR_BASE;
+			 domainId++) {
+		if (CGU_SB_SSR_FS_GET(CGU_SB->base_ssr[domainId]) ==
+				(CGU_FIN_SELECT_HPPLL0 + pllid)) {
+			/* switch reference clock in to FFAST */
+			cgu_set_base_freq(domainId, CGU_FIN_SELECT_FFAST);
+			/* store the domain id to switch back to HPLL */
+			switched_domains |= (1<<domainId);
+		}
+	}
+
+	/* get PLL regs */
+	hppll = &CGU_CFG->hp[pllid];
+
+	/* disable clock, disable skew enable, power down pll,
+	 * (dis/en)able post divider, (dis/en)able pre-divider,
+	 * disable free running mode, disable bandsel,
+	 * enable up limmiter, disable bypass
+	 */
+	hppll->mode = CGU_HPLL_MODE_PD;
+
+	/* Select fin */
+	hppll->fin_select = pllinfo->fin_select;
+
+	/* M divider */
+	hppll->mdec = pllinfo->mdec & CGU_HPLL_MDEC_MASK;
+
+	/* N divider */
+	hppll->ndec = pllinfo->ndec & CGU_HPLL_NDEC_MSK;
+
+	/* P divider */
+	hppll->pdec = pllinfo->pdec & CGU_HPLL_PDEC_MSK;
+
+	/* Set bandwidth */
+	hppll->selr = pllinfo->selr;
+	hppll->seli = pllinfo->seli;
+	hppll->selp = pllinfo->selp;
+
+	/* Power up pll */
+	hppll->mode = (pllinfo->mode & ~CGU_HPLL_MODE_PD) | CGU_HPLL_MODE_CLKEN;
+
+	/* wait for PLL to lock */
+	while ((hppll->status & CGU_HPLL_STATUS_LOCK) == 0);
+
+	 /* 
+	  * switch domains back to HPLL
+	  */
+	for (domainId = CGU_SB_BASE_FIRST; domainId < CGU_SB_NR_BASE; domainId++) {
+		if (switched_domains & (1<<domainId)) {
+			/* switch reference clock in to HPLL */
+			cgu_set_base_freq(domainId, CGU_FIN_SELECT_HPPLL0 + pllid);
+		}
+	}
+
+}
+
+void cgu_soft_reset_module(CGU_MOD_ID_T modId)
+{
+	volatile ulong i;
+	volatile ulong * pmod_rst_reg = &(CGU_CFG->apb0_resetn_soft);
+
+	/* All the reset registers are continously mapped with an address difference of 4 */
+	pmod_rst_reg += modId;
+
+	/* clear and set the register */
+	*pmod_rst_reg = 0;
+	/* introduce some delay */
+	for (i = 0;i < 1000;i++);
+
+	*pmod_rst_reg = CGU_CONFIG_SOFT_RESET;
+}
+
+
+void init_clocks(u32 fidv_val[], u32 fdiv_clks[])
+{
+	CGU_HPLL_SETUP_T pllinfo;
+
+#ifdef CONFIG_PLL_270
+	/* settings for 270MHz */
+	pllinfo.fin_select = CGU_FIN_SELECT_FFAST;
+	pllinfo.ndec = 514;
+	pllinfo.mdec = 19660;
+	pllinfo.pdec = 98;
+	pllinfo.selr = 0;
+	pllinfo.seli = 48;
+	pllinfo.selp = 23;
+	pllinfo.mode = 0;
+
+#else
+	/* settings for 180MHz */
+	pllinfo.fin_select = CGU_FIN_SELECT_FFAST;
+	pllinfo.ndec = 770;
+	pllinfo.mdec = 8191;
+	pllinfo.pdec = 98;
+	pllinfo.selr = 0;
+	pllinfo.seli = 16;
+	pllinfo.selp = 8;
+	pllinfo.mode = 0;
+#endif
+	cgu_reset_all_clks();
+	cgu_hpll_config(CGU_HPLL1_ID, &pllinfo);
+	cgu_init_clks(fidv_val, fdiv_clks);
+}
diff --git a/arch/arm/cpu/arm926ejs/lpc313x/config.mk b/arch/arm/cpu/arm926ejs/lpc313x/config.mk
new file mode 100644
index 0000000..85e9f1f
--- /dev/null
+++ b/arch/arm/cpu/arm926ejs/lpc313x/config.mk
@@ -0,0 +1,34 @@
+#
+# (C) Copyright 2002
+# Gary Jennejohn, DENX Software Engineering, <garyj@denx.de>
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+PLATFORM_RELFLAGS += -fno-common -ffixed-r8 -msoft-float
+
+PLATFORM_CPPFLAGS += -march=armv5te
+# =========================================================================
+#
+# Supply options according to compiler version
+#
+# ========================================================================
+PLATFORM_RELFLAGS +=$(call cc-option,-mshort-load-bytes,$(call cc-option,-malignment-traps,))
+
+USE_PRIVATE_LIBGCC := yes
diff --git a/arch/arm/cpu/arm926ejs/lpc313x/crc32.c b/arch/arm/cpu/arm926ejs/lpc313x/crc32.c
new file mode 100644
index 0000000..2b97165
--- /dev/null
+++ b/arch/arm/cpu/arm926ejs/lpc313x/crc32.c
@@ -0,0 +1,37 @@
+/*
+ * (C) Copyright 2010 NXP Semiconductors
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#define crc32table	((const unsigned int *)0x12015CBC)
+
+unsigned int crc32_compute(unsigned char *data, int length)
+{
+	unsigned int crc;
+
+	crc = 0xFFFFFFFF;
+	
+	while (length--) {
+		crc = crc32table[(crc ^ *data++) & 0xFF] ^(crc >> 8);
+	}
+
+	crc ^= 0xFFFFFFFF;
+	return crc;
+}
diff --git a/arch/arm/cpu/arm926ejs/lpc313x/dos_partition.c b/arch/arm/cpu/arm926ejs/lpc313x/dos_partition.c
new file mode 100644
index 0000000..5487e4a
--- /dev/null
+++ b/arch/arm/cpu/arm926ejs/lpc313x/dos_partition.c
@@ -0,0 +1,152 @@
+/*
+ * (C) Copyright 2010 NXP Semiconductors
+ * 
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ * 
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ * 
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *  
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include "dos_partition.h"
+
+#ifdef CONFIG_MMC
+static partition_t partition_table_data[MAX_PARTITION + 1];
+
+/*
+ * Read a 32bit little endian value from an address which may be misaligned.
+ * Helper function for reading partition table entries...
+ */
+static unsigned int unaligned_read32_le (unsigned char *src)
+{
+	unsigned int value = 0;
+	unsigned int bytes_remaining = 4;
+
+	do {
+		value |= *src++;
+		value = (value << 24) | (value >> 8);
+	}
+	while (--bytes_remaining);
+
+	return value;
+}
+
+
+/*
+ * returns 1 if partition type indicates an extended partition
+ */
+static int p_type_is_extended (int type)
+{
+	return ((type == 0x05) || (type == 0x0F) || (type == 0x85)) ? 1 : 0;
+}
+
+static int p_table_sector_scan (partition_t *parent, partition_t *primary_parent,
+		unsigned char *buf)
+{
+	int i;
+	partition_t *pinfo;
+	unsigned char *pinfo_raw;
+
+
+	if(mci_read_blocks((int)mmc_get_dev(0), parent->start_lba, 1, buf) == 0) {
+		printf("not able to read first sector for patition table\n");
+		return -1;
+	}
+
+	/* check for valid partition table signature bytes */
+	if (*((unsigned short *) &buf[510]) != 0xAA55)
+		return -1;
+
+	pinfo = (partition_t *) buf;
+	
+	/* first offset (others will be 462, 478 and 494) */
+	pinfo_raw = &buf[446];
+
+	/* scan all partition entries (only first 2 are used for non-MBR) */
+	for (i = 0; i < 4; i++) {
+		memset (pinfo, 0, sizeof(partition_t));
+		if ((pinfo->size_lba = unaligned_read32_le (&pinfo_raw[12])) != 0) {
+			pinfo->start_lba = unaligned_read32_le (&pinfo_raw[8]);
+			pinfo->type = pinfo_raw[4];
+			pinfo->start_lba += p_type_is_extended (pinfo->type) ?
+				primary_parent->start_lba :
+				parent->start_lba;
+		}
+
+		pinfo++;
+		pinfo_raw += 16;
+	}
+
+	return 0;
+}
+
+int partition_table_probe (void)
+{
+	int i;
+	int logical_index;
+	partition_t temp, *parent, *primary_parent;
+
+	unsigned char buf[512];
+
+	memset (partition_table_data, 0, sizeof(partition_table_data));
+
+	if (p_table_sector_scan (partition_table_data, partition_table_data, buf) < 0) {
+		printf ("Fatal Error: No valid partition table found... \n");
+		return -1;
+	}
+
+	memcpy (&partition_table_data[1], buf, sizeof(partition_t) * 4);
+
+	return 0;
+}
+
+int partition_get_info (partition_t *pinfo, unsigned int partition_number)
+{
+	int i = MAX_PARTITION;
+
+	/* is the partition number being requested valid ?? */
+	if ((partition_number < 1) || (partition_number > MAX_PARTITION)) {
+		/*
+		 * check if we discovered bootIt partition. if yes return it for all
+		 * invalid partion numbers
+		 */
+		while ( i > 0 ) {
+			if (partition_table_data[i].type == BOOT_IT_PARTITION) {
+				/* If yes, copy partition information about
+				 *  the requested partition into supplied buffer */
+				memcpy (pinfo, &partition_table_data[i], sizeof(partition_t));
+				return 0;
+			}
+			i--;
+		}
+		return -1;
+	}
+
+	/* was the partition number being requested found during probing ?? */
+	if (partition_table_data[partition_number].size_lba == 0)
+		return -1;
+
+	/* is the partition an extended partition ?? */
+	if (p_type_is_extended (partition_table_data[partition_number].type))
+		return -1;
+
+	/* If yes, copy partition information about the requested
+	 * partition into supplied buffer */
+	memcpy (pinfo, &partition_table_data[partition_number], sizeof(partition_t));
+
+	return 0;
+}
+#endif
diff --git a/arch/arm/cpu/arm926ejs/lpc313x/dos_partition.h b/arch/arm/cpu/arm926ejs/lpc313x/dos_partition.h
new file mode 100644
index 0000000..0bb9c6e
--- /dev/null
+++ b/arch/arm/cpu/arm926ejs/lpc313x/dos_partition.h
@@ -0,0 +1,44 @@
+/*
+ * (C) Copyright 2010 NXP Semiconductors
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef DOS_PARTITION_H_
+#define DOS_PARTITION_H_
+
+#define MAX_PARTITION		10
+
+#define BOOT_IT_PARTITION	0xDF
+
+typedef struct
+{
+	unsigned int start_lba;
+	unsigned int size_lba;
+	unsigned char type;
+	unsigned char _pad[3];
+}
+partition_t;
+
+extern int partition_table_probe (void);
+extern int partition_get_info (partition_t *pinfo, unsigned int partition_number);
+
+#endif /* DOS_PARTITION_H */
+
+
diff --git a/arch/arm/cpu/arm926ejs/lpc313x/i2c.c b/arch/arm/cpu/arm926ejs/lpc313x/i2c.c
new file mode 100644
index 0000000..23d9edd
--- /dev/null
+++ b/arch/arm/cpu/arm926ejs/lpc313x/i2c.c
@@ -0,0 +1,130 @@
+/*
+ * (C) Copyright 2010 NXP Semiconductors
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <asm/arch/i2c.h>
+#include <asm/arch/clock.h>
+
+void i2c_init(u32 id, I2C_REGS_T *pI2cBase)
+{
+	u32 srcclk;
+
+#ifdef CONFIG_EA3152
+	if(pI2cBase == I2C1_CTRL) {
+		cgu_clk_en_dis(CGU_SB_SYSCLK_O_ID, 1);
+		cgu_clk_en_dis(CGU_SB_CLK_256FS_ID, 1);
+	}
+#endif
+	cgu_clk_en_dis(id, 1);
+
+	/* Get the I2C0/I2C1 controller base clock rate */
+	srcclk = cgu_get_clk_freq(id);
+
+	pI2cBase->ckh = (srcclk/100000) - 2;
+	pI2cBase->ckl = (srcclk/100000) - 2;
+
+	/* Issue soft reset of the block */
+	pI2cBase->ctl = I2C_CTL_SOFT_RESET;
+	udelay(10000);
+
+	/*
+	 *Change Controller's Slave address as on LPC313x platform
+	 * UDA1380 codec has the same Slave Address which is 0x1A
+	 */
+	pI2cBase->adr = 0x06E;
+}
+
+void i2c_write(I2C_REGS_T *pI2cBase, u32 slave_addr, u32 reg_addr,
+		u32 addr_len, u32 reg_value,u32 data_len)
+{
+	u32 status = 0;
+	int i = 0;
+
+	/* Write Device (Slave) Address with START condition */
+	pI2cBase->fifo = (slave_addr | I2C_TXFF_START_CND);
+
+	/* Write Device Register Address */
+	for(i = (addr_len -1); i >= 0; i--)
+		pI2cBase->fifo = ((reg_addr >> (i * 8)) & 0xFF);
+
+	/* Write Device Register Data */
+	for(i = (data_len -1); i >= 0; i--) {
+		/* Generate STOP condition after last data */
+		if(i == 0)
+			pI2cBase->fifo = (((reg_value >> (i * 8)) & 0xFF) |
+					I2C_TXFF_STOP_CND);
+		else
+			pI2cBase->fifo = ((reg_value >> (i * 8)) & 0xFF);
+	}
+
+	/* Wait untill NAK or X'fer Done is gernerated */
+	while ((status & (I2C_STS_NAI | I2C_STS_TDI)) == 0) {
+		status = pI2cBase->sts;
+	}
+
+	if (status & I2C_STS_TDI) {
+		pI2cBase->sts = I2C_STS_TDI;
+	}
+}
+
+void i2c_read(I2C_REGS_T *pI2cBase, u32 slave_addr, u32 reg_addr,
+		u32 addr_len, u32 *pReg_value,u32 data_len)
+{
+	int i = 0;
+	unsigned int status = 0;
+
+	*pReg_value = 0;
+
+	/* Write Device (Slave) Address with START condition and Write mode*/
+	pI2cBase->fifo = (slave_addr | I2C_TXFF_START_CND);
+
+	/* Write Device Register Address */
+	for(i = (addr_len -1); i >= 0; i--)
+		pI2cBase->fifo = ((reg_addr >> (i * 8)) & 0xFF);
+
+	/* Write Device (Slave) Address with Re-START condition and Read mode*/
+	pI2cBase->fifo = ((slave_addr | 0x1) | I2C_TXFF_START_CND);
+
+	/* Write Dummy Data to get data in RX FIFO*/
+	for(i = (data_len -1); i >= 0; i--) {
+		/* Generate STOP condition after last data */
+		if(i == 0)
+			pI2cBase->fifo = (0xFF | I2C_TXFF_STOP_CND);
+		else
+			pI2cBase->fifo = 0xFF;
+	}
+
+	/* Wait untill NAK or X'fer Done is gernerated */
+	while ((status & (I2C_STS_NAI | I2C_STS_TDI)) == 0) {
+		status = pI2cBase->sts;
+	}
+
+	/* If X'fer is done successfully, read data from RX FIFO */
+	if (status & I2C_STS_TDI) {
+
+		pI2cBase->sts = I2C_STS_TDI;
+
+		*pReg_value = (((pI2cBase->fifo) & 0xFF) << 24);
+		*pReg_value |= (((pI2cBase->fifo) & 0xFF) << 16);
+		*pReg_value |= (((pI2cBase->fifo) & 0xFF) << 8);
+		*pReg_value |= ((pI2cBase->fifo) & 0xFF);
+	}
+}
diff --git a/arch/arm/cpu/arm926ejs/lpc313x/init.c b/arch/arm/cpu/arm926ejs/lpc313x/init.c
new file mode 100644
index 0000000..8c2be28
--- /dev/null
+++ b/arch/arm/cpu/arm926ejs/lpc313x/init.c
@@ -0,0 +1,502 @@
+/*
+ * (C) Copyright 2010 NXP Semiconductors
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <nand.h>
+#include <spi_flash.h>
+#include <mmc.h>
+#include <malloc.h>
+#include <asm/arch/hardware.h>
+#include <asm/arch/clock.h>
+#include <asm/arch/sysreg.h>
+#include <asm/arch/ioconf.h>
+#include <asm/arch/mci.h>
+#include <asm/arch/timer.h>
+#include <asm/arch/i2c.h>
+#include "dos_partition.h"
+
+typedef enum
+{
+	LPC313X_BOOT_MODE_NAND = 0,
+	LPC313X_BOOT_MODE_SPI,
+	LPC313X_BOOT_MODE_DFU_USB,
+	LPC313X_BOOT_MODE_SD_MMC,
+	LPC313X_BOOT_MODE_RESERVED,
+	LPC313X_BOOT_MODE_NOR_FLASH,
+	LPC313X_BOOT_MODE_UART,
+	LPC313X_BOOT_MODE_TEST,
+} LPC313X_BOOT_MODE_T;
+
+/* LPC313x macros */
+#define LPC313X_BOOTMODE_MASK		0x00000007
+#define UART_DOWNLOAD_TIMEOUT_END_US	10000
+#define UART_DOWNLOAD_TIMEOUT_START_US	1000000
+#define READ_BLOCK_SIZE			(512)
+
+#ifdef CONFIG_EA3152
+#define AD_SLAVE_ADDR			(0x18)
+#define AD_REG_OTGDCLIC_RW		0x0000
+#define ANALOG_1V8_RAIL			2
+/* 1v4 io voltage rail adjustments */
+#define PSU_VOUT3_1_80			_BIT(16)
+#endif
+
+/* Memory macros */
+#define LPC313X_ISRAM_BASE_ADD		0x11029000
+#define LPC313X_SDRAM_TEMP_DATA_ADDR	0x32000000
+
+/* SPI NOR flash macros */
+#define LPC313X_SPI_NOR_UBOOT_SECTOR	0x0
+#define LPC313X_SPI_NOR_SECTOR_SIZE	0x40000
+
+/* SD/MMC macros */
+#define LBA_STEP_MCI			32
+/* based on LBA_STEP_MCI define we will search first 32MB of the partition only */
+#define MAX_IMAGE_SEARCH_NUM_OF_BLOCKS	2048
+
+/* USB macros */
+#define EVT_usb_pll_bank		3
+#define EVT_usb_atx_pll_lock_bit	_BIT(25)
+
+//extern long __INITIAL_DATA_END;
+//extern long __initial_boot_image_size;
+
+//int is_nand_init_done = 0;
+//int is_spi_init_done = 0;
+
+#ifdef CONFIG_CPU_USBDFU_BOOT
+extern unsigned char stop_polling;
+#endif
+
+DECLARE_GLOBAL_DATA_PTR;
+
+#ifdef CONFIG_CPU_MMC_BOOT
+static int find_and_load_mci_image (ulong image_length, volatile unsigned char * loadPointer,
+		unsigned int startLBA, unsigned int sizeInLBA)
+{
+	unsigned int mci_block_index;
+	unsigned int mci_block_limit;
+
+	mci_block_index = startLBA;
+	mci_block_limit = startLBA;
+
+	if (sizeInLBA > ((unsigned int) (MAX_IMAGE_SEARCH_NUM_OF_BLOCKS *
+					LBA_STEP_MCI))) {
+		mci_block_limit += ((unsigned int) (MAX_IMAGE_SEARCH_NUM_OF_BLOCKS *
+					 LBA_STEP_MCI));
+	}
+	else {
+		mci_block_limit += sizeInLBA;
+	}
+
+	while (mci_block_index < mci_block_limit) {
+		/* Read the header */
+		if (mci_read_blocks((int)mmc_get_dev(0),mci_block_index, 1, loadPointer) == 0) {
+			/* This error while reading was not expected so return with failure */
+			return (-1);
+		}
+
+		/* Yes it makes sense, so try loading the rest of the image
+		 * first test if the image fits the medium */
+		if ((((image_length + READ_BLOCK_SIZE - 1)/READ_BLOCK_SIZE)
+					+ mci_block_index)<(startLBA + sizeInLBA)) {
+			/* Yes, the image fits the medium so load it */
+			if (mci_read_blocks((int)mmc_get_dev(0),mci_block_index+1,
+					((image_length + READ_BLOCK_SIZE - 1)/READ_BLOCK_SIZE),
+					loadPointer + READ_BLOCK_SIZE) == 0) {
+				/* this error while reading was not expected so return with failure */
+				return (-1);
+			}
+			else {
+				return 0;
+			}
+
+		}
+		mci_block_index += (unsigned int) LBA_STEP_MCI;
+	}
+
+	return -1;
+}
+#endif
+
+static int timer_expired(ulong timeStart, ulong timeDelta)
+{
+	ulong currTime = 0;
+
+	currTime = get_timer(0);
+	if (((currTime - timeStart) > timeDelta))
+		return 1;
+
+	return 0;
+}
+
+static int usb_copy_boot_image(ulong image_length, volatile unsigned char * loadPointer)
+{
+#ifdef CONFIG_CPU_USBDFU_BOOT
+	u32 i = 500;
+
+	while(!stop_polling) {
+		usbtty_poll();
+	}
+	/* do usbtty_poll() for the DFU Class status request to complete */
+	while(i) {
+		usbtty_poll();
+		i--;
+	}
+#else
+	printf("Please enable USB Gadget supoprt before selecting USB DFU boot mode\n");
+#endif
+	return 0;
+}
+
+static int sdmmc_copy_boot_image(ulong image_length, volatile unsigned char * loadPointer)
+{
+#ifdef CONFIG_CPU_MMC_BOOT
+	unsigned int partition_number;
+	partition_t partitionInfo;
+	unsigned int max_num_sectors = mmc_get_card_size((int)mmc_get_dev(0));
+	unsigned int ret = 0;
+
+	/* Check if there is partition table on the device */
+	if (0 == partition_table_probe()) {
+		/* Yes there is, so try the partitions for the image. Search bootIt partition first
+		 * so pass partition_number = 0 first. Usualy 0 is invalid partition number.
+		 */
+		for (partition_number = 0; partition_number <= MAX_PARTITION;
+					 partition_number++) {
+			if (0 == partition_get_info (&partitionInfo, partition_number)) {
+				/* Check if the partition fits in the media (corrupt partition table check) */
+				if ((partitionInfo.start_lba + partitionInfo.size_lba) <=
+					max_num_sectors) {
+					/* Found a valid partition, so try finding a image */
+					ret = find_and_load_mci_image (image_length, loadPointer,
+							partitionInfo.start_lba,
+							partitionInfo.size_lba);
+					if (ret == 0) {
+						/* Good image found. */
+						return 0;
+					}
+				}
+			}
+		}
+	}
+#else
+	printf("Please enable MMC supoprt before selecting MMC boot mode\n");
+#endif
+	return 0;
+}
+
+static int flash_copy_boot_image(ulong image_length, volatile unsigned char * loadPointer)
+{
+	printf("Parallel flash boot mode is not supported\n");
+	return 0;
+}
+static int nand_copy_boot_image(ulong image_length, volatile unsigned char * loadPointer)
+{
+#ifdef CONFIG_CPU_NAND_BOOT
+	size_t len = 0;
+	int ret = 0;
+
+	len = image_length;
+	printf("reading NAND..");
+	ret = nand_read_skip_bad(&nand_info[0], 0x20000, &len,
+			(u_char *)loadPointer);
+	if(ret) {
+		printf("Failed\n");
+		return -1;
+	}
+	else {
+		printf("Done\n");
+	}
+#else
+	printf("Please enable NAND supoprt before selecting NAND boot mode\n");
+#endif
+	return 0;
+}
+
+static int spi_copy_boot_image(ulong image_length, volatile unsigned char * loadPointer)
+{
+#ifdef CONFIG_CPU_SPI_BOOT
+	struct spi_flash *flash = NULL;
+	int ret = 0;
+
+	flash = spi_flash_probe(0, 0, 0, 0);
+	if (!flash) {
+		printf("Failed to initialize SPI flash\n");
+		return 1;
+	}
+
+	printf("reading SPI NOR..");
+	ret = spi_flash_read(flash,(LPC313X_SPI_NOR_UBOOT_SECTOR * LPC313X_SPI_NOR_SECTOR_SIZE),
+			image_length, (void *)loadPointer);
+
+	if (ret) {
+		printf("Failed\n");
+		return -1;
+	}
+	printf("Done\n");
+#else
+	printf("Please enable SPI supoprt before selecting SPI boot mode\n");
+#endif
+	return 0;
+}
+
+static int uart_copy_boot_image(ulong image_length, volatile unsigned char *loadPointer)
+{
+	u32 byteCount = 0;
+	ulong timeoutValue = 0;
+	ulong timerexpire = 0;
+	ulong timeStart = 0;
+
+	/* Download the image until the maximal size is reached
+	 * or a timeout on the byte reception happened.
+	 */
+
+	timeoutValue = UART_DOWNLOAD_TIMEOUT_START_US;
+	printf("READY TO RECEIVE DATA IN BINARY MODE\n");
+
+	while (1) {
+		reset_timer();
+		timeStart = get_timer(0);
+
+		while (serial_getchar (loadPointer) == 0) {
+			timerexpire = timer_expired(timeStart, timeoutValue);
+			if(timerexpire == 1) {
+				break;
+			}
+			if(byteCount >= image_length)
+				break;
+		}
+
+		if(timerexpire == 1) {
+			if (timeoutValue == UART_DOWNLOAD_TIMEOUT_END_US) {
+				printf("Download finished\n" );
+			}
+			else {
+				printf("Timeout!!!\n" );
+			}
+			break;
+		}
+
+		timeoutValue = UART_DOWNLOAD_TIMEOUT_END_US;
+
+		loadPointer++;
+		byteCount++;
+		if (byteCount >= image_length) {
+			break;
+		}
+	}
+
+	printf("%d bytes are transfered\n",byteCount);
+	return 0;
+}
+
+void GPIOMuxSetup(void)
+{
+	gpio_set_outpin_high(IOCONF_GPIO, 2);
+}
+
+#if defined(CONFIG_USB_EHCI_LPC313X) || defined(CONFIG_USB_DEVICE)
+void usb_init_clocks(void)
+{
+
+	/* enable USB to AHB clock */
+	cgu_clk_en_dis(CGU_SB_USB_OTG_AHB_CLK_ID, 1);
+	/* enable clock to Event router */
+	cgu_clk_en_dis(CGU_SB_EVENT_ROUTER_PCLK_ID, 1);
+
+	/* reset USB block */
+	cgu_soft_reset_module(USB_OTG_AHB_RST_N_SOFT);
+
+	if(SYS_REGS->usb_atx_pll_pd_reg != 0) {
+		/* enable USB OTG PLL */
+		SYS_REGS->usb_atx_pll_pd_reg = 0x0;
+		/* wait for PLL to lock */
+		while (!(EVRT_RSR(EVT_usb_pll_bank) & EVT_usb_atx_pll_lock_bit));
+	}
+
+	return;
+}
+#endif
+
+#ifdef CONFIG_EA3152
+void psu_set_voltage(u32 rail, u32 volt)
+{
+	u32 reg_val;
+	int bit_pos;
+
+	/* read PSU register */
+	i2c_read(I2C1_CTRL, AD_SLAVE_ADDR, AD_REG_OTGDCLIC_RW,
+			2, &reg_val,4);
+
+	/* check if this is to set VOUT3 rail */
+	if (ANALOG_1V8_RAIL == rail) {
+		reg_val |= (volt)?_BIT(16):0;
+	} else {
+		/* for 1v2 bitpos is 17 and for 3v3 bit pos 20 */
+		bit_pos = (rail)? 17 : 20;
+
+		if (volt > 0x7)
+			volt = 0x7;
+
+		/* zero the dcdc1 adjust bits */
+		reg_val &= ~(0x7 << bit_pos);
+		/* write the new adjust value */
+		reg_val |= (volt << bit_pos);
+	}
+
+	i2c_write(I2C1_CTRL, AD_SLAVE_ADDR, AD_REG_OTGDCLIC_RW,
+			2, reg_val,4);
+	return;
+}
+
+void setup_sdram_voltage(void)
+{
+	unsigned int reg_val = 0;
+
+	i2c_init(CGU_SB_I2C1_PCLK_ID,I2C1_CTRL);
+
+	/* Set SDRAM voltage rail to 1.8V default is 1.4V */
+	psu_set_voltage(ANALOG_1V8_RAIL, PSU_VOUT3_1_80);
+}
+#endif
+
+
+int lpc313x_init(void)
+{
+	long uartid = 0;
+	int rc = 0;
+	ulong bootmode = 0;
+	volatile unsigned char * tmploadPointer =
+		(volatile unsigned char *)(LPC313X_SDRAM_TEMP_DATA_ADDR);
+	ulong image_length = 0;
+//	ulong init_image_length = (ulong)&__initial_boot_image_size;
+//	ulong init_end = (ulong)&__INITIAL_DATA_END;
+	ulong init_image_length = 0;
+	ulong init_end = 0;
+	volatile unsigned char * loadPointer =
+		(volatile unsigned char *)(init_end);
+	unsigned int cnt = 0;
+
+	gd = (gd_t*)(_TEXT_BASE - CONFIG_SYS_MALLOC_LEN - sizeof(gd_t));
+
+	mem_malloc_init (_TEXT_BASE - CONFIG_SYS_MALLOC_LEN,
+			CONFIG_SYS_MALLOC_LEN);
+
+	GPIOMuxSetup();
+
+	/* Initialize Timer0 */
+	timer_init();
+
+	/* Initialize UART0 */
+	gd->baudrate = CONFIG_BAUDRATE;
+	gd->flags = 0;
+	uartid = serial_init();
+	gd->have_console = 1;
+
+#if defined(CONFIG_USB_EHCI_LPC313X) || defined(CONFIG_USB_DEVICE)
+	usb_init_clocks();
+#endif
+
+#ifdef CONFIG_CPU_NAND_BOOT
+	/* Initialize NAND device */
+	printf("\nNAND:  ");
+	nand_init();
+	//is_nand_init_done = 1;
+#endif
+
+#ifdef CONFIG_CPU_SPI_BOOT
+	/* Inialize SPI NOR flah*/
+	spi_init();
+	//is_spi_init_done = 1;
+#endif
+
+#ifdef CONFIG_CPU_MMC_BOOT
+	/* Initialize MMC */
+	mmc_legacy_init(0);
+#endif
+
+#ifdef CONFIG_CPU_USBDFU_BOOT
+	drv_usbtty_init();
+#endif
+	
+	/* Read Boot mode pins and copy u-boot image from
+	 * selected BOOT device 
+	 */
+	IOCONF->block[IOCONF_GPIO].mode0_clear = LPC313X_BOOTMODE_MASK;
+	IOCONF->block[IOCONF_GPIO].mode1_clear = LPC313X_BOOTMODE_MASK;
+
+	udelay(1000);
+
+	bootmode = IOCONF->block[IOCONF_GPIO].pins;
+	bootmode &= LPC313X_BOOTMODE_MASK;
+
+	bootmode = (((bootmode & 0x1) << 1) | ((bootmode & 0x2) << 1) |
+			((bootmode & 0x4) >> 2));
+
+	image_length = *((unsigned int *)(LPC313X_ISRAM_BASE_ADD + 0x30));
+
+	switch(bootmode) {
+	case LPC313X_BOOT_MODE_NAND:
+		printf("BOOTMODE: NAND\n");
+		rc = nand_copy_boot_image(image_length,tmploadPointer);
+		break;
+	case LPC313X_BOOT_MODE_SPI:
+		printf("BOOTMODE: SPI\n");
+		rc = spi_copy_boot_image(image_length,tmploadPointer);
+		break;
+	case LPC313X_BOOT_MODE_DFU_USB:
+		printf("BOOTMODE: USB\n");
+		rc = usb_copy_boot_image(image_length,tmploadPointer);
+		break;
+	case LPC313X_BOOT_MODE_SD_MMC:
+		printf("BOOTMODE: SDMMC\n");
+		rc = sdmmc_copy_boot_image(image_length,tmploadPointer);
+		break;
+	case LPC313X_BOOT_MODE_NOR_FLASH:
+		printf("BOOTMODE: NOR\n");
+		rc = flash_copy_boot_image(image_length,tmploadPointer);
+		break;
+	case LPC313X_BOOT_MODE_UART:
+		printf("BOOTMODE: UART\n");
+		rc = uart_copy_boot_image(image_length,tmploadPointer);
+		break;
+	default:
+		break;
+	}
+
+	if(rc == -1) {
+		printf("valid image is not found\n");
+		hang();
+	}
+
+	/* copy all sections excluding .data section */
+	tmploadPointer = tmploadPointer + (init_end - _TEXT_BASE);
+	while(cnt < (image_length - init_image_length)) {
+		*loadPointer++ = *tmploadPointer++;
+		cnt++;
+	}
+	udelay(100);
+	
+	//start_armboot();
+	return 0;
+}
diff --git a/arch/arm/cpu/arm926ejs/lpc313x/mci.c b/arch/arm/cpu/arm926ejs/lpc313x/mci.c
new file mode 100644
index 0000000..54e5b33
--- /dev/null
+++ b/arch/arm/cpu/arm926ejs/lpc313x/mci.c
@@ -0,0 +1,751 @@
+/*
+ * (C) Copyright 2010 NXP Semiconductors
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <asm/arch/sdmmc.h>
+#include <asm/arch/sysreg.h>
+#include <asm/arch/ioconf.h>
+#include <asm/arch/clock.h>
+#include <asm/arch/timer.h>
+#include <asm/arch/mci.h>
+
+#ifdef CONFIG_MMC
+
+#define USE_WIDE
+
+/* give 1 atleast 1 sec for the card to respond */
+#define US_TIMEOUT		1000000
+/* inter-command acquire oper condition delay in msec*/
+#define MS_ACQUIRE_DELAY	(10 * 1000)
+/* initial OP_COND retries */
+#define INIT_OP_RETRIES		10
+/* set OP_COND retries */
+#define SET_OP_RETRIES		200
+
+/* global instance of the current card*/
+static MCI_CARD_INFO_T g_card_info;
+block_dev_desc_t mmc_dev;
+
+static ulong prv_card_acquired(MCI_CARD_INFO_T* pdev)
+{
+	return (pdev->cid[0] != 0);
+}
+
+static ulong prv_get_bits(int start, int end, ulong* data)
+{
+	ulong v;
+	ulong i = end >> 5;
+	ulong j = start & 0x1f;
+
+	if (i == (start >> 5))
+		v = (data[i] >> j);
+	else
+		v = ((data[i] << (32 - j)) | (data[start >> 5] >> j));
+
+	return (v & ((1 << (end - start + 1)) - 1));
+}
+
+static void prv_clear_all(void)
+{
+	/* reset all blocks */
+	MCI->ctrl |= MCI_CTRL_FIFO_RESET;
+	/* wait till resets clear */
+	while (MCI->ctrl & MCI_CTRL_FIFO_RESET);
+
+	/* Clear interrupt status */
+	MCI->rintsts = 0xFFFFFFFF;
+}
+
+static int prv_send_cmd(ulong cmd, ulong arg)
+{
+	volatile int tmo = 50;
+	volatile int delay;
+	/* set command arg reg*/
+	MCI->cmdarg = arg;
+	MCI->cmd = MCI_CMD_START | cmd;
+
+	/* poll untill command is accepted by the CIU */
+	while (--tmo && (MCI->cmd & MCI_CMD_START)) {
+		if (tmo & 1)
+			delay = 50;
+		else
+			delay = 18000;
+
+		while (--delay > 1);
+	}
+
+	return (tmo < 1) ? 1 : 0;
+}
+
+static void prv_set_clock(ulong speed)
+{
+	/* compute SD/MMC clock dividers */
+	ulong mmc_clk = cgu_get_clk_freq(CGU_SB_SD_MMC_CCLK_IN_ID);
+	ulong div = ((mmc_clk / speed) + 2) >> 1;
+
+	if ((div == MCI->clkdiv) && MCI->clkena)
+		return; /* requested speed is already set */
+
+	/* disable clock */
+	MCI->clkena = 0;
+	MCI->clksrc = 0;
+
+	/* inform CIU */
+	prv_send_cmd(MCI_CMD_UPD_CLK | MCI_CMD_PRV_DAT_WAIT, 0);
+
+	/* set clock to desired speed */
+	MCI->clkdiv = div;
+	/* inform CIU */
+	prv_send_cmd(MCI_CMD_UPD_CLK | MCI_CMD_PRV_DAT_WAIT, 0);
+
+	/* enable clock */
+	MCI->clkena = MCI_CLKEN_ENABLE;
+	/* inform CIU */
+	prv_send_cmd(MCI_CMD_UPD_CLK | MCI_CMD_PRV_DAT_WAIT, 0);
+}
+
+static void prv_pull_response(MCI_CARD_INFO_T* pdev, int length)
+{
+
+	/* on this chip response is not a fifo so read all 4 regs */
+	pdev->response[0] = MCI->resp0;
+	pdev->response[1] = MCI->resp1;
+	pdev->response[2] = MCI->resp2;
+	pdev->response[3] = MCI->resp3;
+}
+
+static int prv_pull_data(unsigned char* pv, int cnt)
+{
+	int j,i = 0;
+	int fcnt;
+
+	volatile ulong * pFifo = (ulong *)0x18000100;
+	ulong *pBuffer = (ulong *)pv;
+
+	while (i < cnt) {
+		fcnt = MCI_STS_GET_FCNT(MCI->status);
+		for(j=0;j<fcnt;j++)
+			*pBuffer++ = pFifo[j];
+
+		i += (fcnt * 4);
+	}
+	return i;
+}
+
+static void prv_push_data(const unsigned char* pv, ulong cb)
+{
+	int i = 0;
+	int fcnt;
+
+	while (i < cb) {
+		fcnt = MCI_FIFO_SZ - (MCI_STS_GET_FCNT(MCI->status) << 2);
+		memcpy((void*)&MCI->data, pv + i, fcnt);
+		i += fcnt;
+	}
+}
+
+static ulong prv_wait_for_completion(MCI_CARD_INFO_T* pdev, ulong bits)
+{
+	ulong status = 0;
+	int tmo_count = 10;
+
+	/* also check error conditions */
+	bits |= MCI_INT_EBE | MCI_INT_SBE | MCI_INT_HLE
+		| MCI_INT_RTO | MCI_INT_RCRC | MCI_INT_RESP_ERR;
+
+	if (bits & MCI_INT_DATA_OVER)
+		bits |= MCI_INT_FRUN | MCI_INT_HTO | MCI_INT_DTO
+			| MCI_INT_DCRC;
+
+	do {
+		udelay(5000);
+		status = MCI->rintsts;
+
+		if (--tmo_count < 1) {
+			break;
+		}
+	}
+	while ((status  & bits) == 0);
+	/* set time out flag for driver timeout also */
+	status |= ((tmo_count < 1) ? MCI_INT_RTO : 0);
+//printf("JDS tmo %d\n", tmo_count);
+	return status;
+}
+
+static void prv_process_csd(MCI_CARD_INFO_T* pdev)
+{
+	long status = 0;
+	long c_size = 0;
+	long c_size_mult = 0;
+	long mult = 0;
+
+	/* compute block length based on CSD response */
+	pdev->block_len = 1 << prv_get_bits(80, 83, pdev->csd);
+
+	if ((pdev->card_type & CARD_TYPE_HC) &&
+			(pdev->card_type & CARD_TYPE_SD)) {
+		/*
+		 * See section 5.3.3 CSD Register (CSD Version 2.0) of SD2.0 spec
+		 * an explanation for the calculation of these values
+		 */
+		c_size = prv_get_bits(48, 63, (ulong*)pdev->csd) + 1;
+		pdev->blocknr = c_size << 10; /* 512 byte blocks */
+	}
+	else {
+		/*
+		 * See section 5.3 of the 4.1 revision of the MMC specs for
+		 * an explanation for the calculation of these values
+		 */
+		c_size = prv_get_bits(62, 73, (ulong*)pdev->csd);
+		c_size_mult = prv_get_bits(47, 49, (ulong*)pdev->csd);
+		mult = 1 << (c_size_mult + 2);
+		pdev->blocknr = (c_size + 1) * mult;
+		
+		/* adjust blocknr to 512/block */
+		if (pdev->block_len > MMC_SECTOR_SIZE)
+			pdev->blocknr = pdev->blocknr * (pdev->block_len >> 9);
+
+		/* get extended CSD for newer MMC cards CSD spec >= 4.0*/
+		if (((pdev->card_type & CARD_TYPE_SD) == 0) &&
+				(prv_get_bits(122, 125, (ulong*)pdev->csd) >= 4)) {
+
+			ulong ext_csd[MMC_SECTOR_SIZE/4];
+
+			/* put card in trans state */
+			status = mci_execute_command(pdev, CMD_SELECT_CARD, pdev->rca << 16, 0);
+			/* set block size and byte count */
+			MCI->blksiz = MMC_SECTOR_SIZE;
+			MCI->bytcnt = MMC_SECTOR_SIZE;
+			/* send EXT_CSD command */
+			status = mci_execute_command(pdev, CMD_SEND_EXT_CSD, 0,
+					MCI_INT_CMD_DONE | MCI_INT_DATA_OVER |
+					MCI_INT_RXDR);
+
+			if ((status & MCI_INT_ERROR) == 0) {
+				/* read 52bytes EXT-CSD data */
+				prv_pull_data((unsigned char*)ext_csd, MMC_SECTOR_SIZE);
+
+				/* check EXT_CSD_VER is greater than 1.1 */
+				if ((ext_csd[48] & 0xFF) > 1)
+				/* bytes 212:215 represent sec count */
+					pdev->blocknr = ext_csd[53];
+
+				/* switch to 52MHz clock if card type
+				 * is set to 1 or else set to 26MH
+				 * */
+				if ((ext_csd[49] & 0xFF) == 1) {
+					/* for type 1 MMC cards high speed is 52MHz */
+					pdev->speed = MMC_HIGH_BUS_MAX_CLOCK;
+				}
+				else {
+					/* for type 0 MMC cards high speed is 26MHz */
+					pdev->speed = MMC_LOW_BUS_MAX_CLOCK;
+				}
+			}
+		}
+	}
+
+	pdev->device_size = pdev->blocknr << 9; /* blocknr * 512 */
+}
+
+static int prv_set_trans_state(MCI_CARD_INFO_T* pdev)
+{
+	ulong status;
+
+	/* get current state of the card */
+	status = mci_execute_command(pdev, CMD_SEND_STATUS, pdev->rca << 16, 0);
+	if (status & MCI_INT_RTO) {
+		/* unable to get the card state. So return immediatly. */
+		return _ERROR;
+	}
+	/* check card state in response */
+	status = R1_CURRENT_STATE(pdev->response[0]);
+	switch (status) {
+	case SDMMC_STBY_ST:
+		/* put card in 'Trans' state */
+		status = mci_execute_command(pdev, CMD_SELECT_CARD, pdev->rca << 16, 0);
+		if (status != 0) {
+			/* unable to put the card in Trans state. So return immediatly. */
+			return _ERROR;
+		}
+		break;
+	case SDMMC_TRAN_ST:
+		/*do nothing */
+		break;
+	default:
+		/* card shouldn't be in other states so return */
+		return _ERROR;
+	}
+
+#if defined (USE_WIDE)
+	if (pdev->card_type & CARD_TYPE_SD) {
+		/* SD, 4 bit width */
+		mci_execute_command(pdev, CMD_SD_SET_WIDTH, 2, 0);
+		/* if positive response */
+		MCI->ctype = MCI_CTYPE_4BIT;
+	}
+#endif
+
+	/* set block length */
+	MCI->blksiz = MMC_SECTOR_SIZE;
+	status = mci_execute_command(pdev, CMD_SET_BLOCKLEN, MMC_SECTOR_SIZE, 0);
+
+	return _NO_ERROR;
+}
+
+long mci_execute_command(MCI_CARD_INFO_T* pdev,
+		ulong cmd, ulong arg, ulong wait_status)
+{
+	/* if APP command there are 2 stages */
+	int step = (cmd & CMD_BIT_APP) ? 2 : 1;
+	long status = 0;
+	ulong cmd_reg = 0;
+
+	if (!wait_status)
+		wait_status = (cmd & CMD_MASK_RESP) ? MCI_INT_CMD_DONE : MCI_INT_DATA_OVER;
+
+	/* Clear the interrupts & FIFOs*/
+	if (cmd & CMD_BIT_DATA)
+		prv_clear_all();
+
+	while (step) {
+		prv_set_clock((cmd & CMD_BIT_LS) ? SD_MMC_ENUM_CLOCK : pdev->speed);
+
+
+		/* Clear the interrupts */
+		MCI->rintsts = 0xFFFFFFFF;
+
+		switch (step) {
+		case 1:
+			/* Execute command */
+			cmd_reg = ((cmd & CMD_MASK_CMD) >> CMD_SHIFT_CMD)
+				| ((cmd & CMD_BIT_INIT) ? MCI_CMD_INIT : 0)
+				| ((cmd & CMD_BIT_DATA) ? (MCI_CMD_DAT_EXP |
+					MCI_CMD_PRV_DAT_WAIT) : 0)
+				| (((cmd & CMD_MASK_RESP) == CMD_RESP_R2) ? 
+						MCI_CMD_RESP_LONG : 0)
+				| ((cmd & CMD_MASK_RESP) ? MCI_CMD_RESP_EXP : 0)
+				| ((cmd & CMD_BIT_WRITE) ? MCI_CMD_DAT_WR : 0)
+				| ((cmd & CMD_BIT_STREAM) ? MCI_CMD_STRM_MODE : 0)
+				| ((cmd & CMD_BIT_BUSY) ? MCI_CMD_STOP : 0)
+				| ((cmd & CMD_BIT_AUTO_STOP) ? MCI_CMD_SEND_STOP : 0)
+				| MCI_CMD_START;
+
+			/* wait for previos data finsh for selct/deselct commands */
+			if (((cmd & CMD_MASK_CMD) >> CMD_SHIFT_CMD) == MMC_SELECT_CARD) {
+				cmd_reg |= MCI_CMD_PRV_DAT_WAIT;
+			}
+
+			/* wait for command to be accepted by CIU */
+			if (prv_send_cmd(cmd_reg, arg) == 0)
+				--step;
+
+			break;
+		case 0:
+			return 0;
+		case 2:
+			/* APP prefix */
+			cmd_reg = MMC_APP_CMD
+				| MCI_CMD_RESP_EXP /* Response is status */
+				| ((cmd & CMD_BIT_INIT) ? MCI_CMD_INIT : 0)
+				| MCI_CMD_START;
+			if (prv_send_cmd(cmd_reg, pdev->rca << 16) == 0)
+				--step;
+			break;
+		}
+//printf("JDS waiting\n");
+		/* wait for command response*/
+		status = prv_wait_for_completion(pdev, wait_status);
+//printf("JDS cmd %lx arg %lx step %x status %x\n", cmd, arg, step, status);
+
+		/* We return an error if there is a timeout, even if we've fetched
+		 * a response */
+		if (status & MCI_INT_ERROR)
+			return status;
+
+		if (status & MCI_INT_CMD_DONE) {
+			switch (cmd & CMD_MASK_RESP) {
+			case 0:
+				break;
+			case CMD_RESP_R1:
+			case CMD_RESP_R3:
+				prv_pull_response(pdev, 48);
+				break;
+			case CMD_RESP_R2:
+				prv_pull_response(pdev, 136);
+				break;
+			}
+		}
+	}
+	return 0;
+}
+
+
+void mci_acquire(MCI_CARD_INFO_T* pdev)
+{
+	int status;
+	int tries = 0;
+	ulong ocr = OCR_VOLTAGE_RANGE_MSK;
+	ulong r;
+	int state = 0;
+	ulong command = 0;
+
+	/* clear card struct */
+	memset(pdev, 0, sizeof(MCI_CARD_INFO_T));
+
+	/* clear card type */
+	MCI->ctype = 0;
+
+	/* we could call board specific card detect routine here */
+
+	/* set high speed for the card as 20MHz */
+	pdev->speed = MMC_MAX_CLOCK;
+
+	status = mci_execute_command(pdev, CMD_IDLE, 0, MCI_INT_CMD_DONE);
+
+	while (state < 100) {
+//printf("JDS state %d\n", state);
+		switch (state) {
+		case 0:
+			/* Setup for SD */
+			/* check if it is SDHC card */
+			status = mci_execute_command(pdev, CMD_SD_SEND_IF_COND, SD_SEND_IF_ARG, 0);
+			if (!(status & MCI_INT_RTO)) {
+					/* check response has same echo pattern */
+				if ((pdev->response[0] & SD_SEND_IF_ECHO_MSK) == SD_SEND_IF_RESP)
+					/* it is SD 2.0 card so indicate we are SDHC capable*/
+					ocr |= OCR_HC_CCS;
+			}
+				++state;
+			command = CMD_SD_OP_COND;
+			tries = INIT_OP_RETRIES;
+			/* assume SD card */
+			pdev->card_type |= CARD_TYPE_SD;
+			/* for SD cards high speed is 25MHz */
+			pdev->speed = SD_MAX_CLOCK;
+				break;
+		case 10:
+			/* Setup for MMC */
+			/* start fresh for MMC crds */
+			pdev->card_type &= ~CARD_TYPE_SD;
+			status = mci_execute_command(pdev, CMD_IDLE, 0, MCI_INT_CMD_DONE);
+			command = CMD_MMC_OP_COND;
+			tries = INIT_OP_RETRIES;
+			ocr |= OCR_HC_CCS;
+			++state;
+			/* for MMC cards high speed is 20MHz */
+			pdev->speed = MMC_MAX_CLOCK;
+			break;
+		case 1:
+		case 11:
+			status = mci_execute_command(pdev, command, 0, 0);
+			if (status & MCI_INT_RTO)
+				state += 9; /* Mode unavailable */
+			else
+				++state;
+			break;
+		case 2:
+		case 12:
+			ocr = pdev->response[0] | (ocr & OCR_HC_CCS);
+			if (ocr & OCR_ALL_READY)
+				++state;
+			else
+				state += 2;
+			break;
+		/* Initial wait for OCR clear */
+		case 3:
+		case 13:
+			while ((ocr & OCR_ALL_READY) && --tries > 0) {
+				udelay(MS_ACQUIRE_DELAY);
+				status = mci_execute_command(pdev, command, 0, 0);
+				ocr = pdev->response[0] | (ocr & OCR_HC_CCS);
+			}
+			if (ocr & OCR_ALL_READY)
+				state += 7;
+			else
+				++state;
+			break;
+
+		case 14:
+			/* for MMC cards set high capacity bit */
+			ocr |= OCR_HC_CCS;
+		case 4:
+			/* Assign OCR */
+			tries = SET_OP_RETRIES;
+			ocr &= OCR_VOLTAGE_RANGE_MSK | OCR_HC_CCS; /* Mask for the bits we care about */
+			do {
+				udelay(MS_ACQUIRE_DELAY);
+				status = mci_execute_command(pdev, command, ocr, 0);
+				r = pdev->response[0];
+			}
+			while (!(r & OCR_ALL_READY) && --tries > 0);
+			if (r & OCR_ALL_READY) {
+				/* is it high capacity card */
+				pdev->card_type |= (r & OCR_HC_CCS);
+				++state;
+			}
+			else
+				state += 6;
+			break;
+		case 5:
+		case 15:
+			/* CID polling */
+			status = mci_execute_command(pdev, CMD_ALL_SEND_CID, 0, 0);
+			memcpy(pdev->cid, pdev->response, 16);
+			++state;
+			break;
+		case 6:
+			/* RCA send, for SD get RCA */
+			status = mci_execute_command(pdev, CMD_SD_SEND_RCA, 0, 0);
+			pdev->rca = (pdev->response[0]) >> 16;
+			++state;
+			break;
+		case 16:
+			/* RCA assignment for MMC set to 1 */
+			pdev->rca = 1;
+			status = mci_execute_command(pdev, CMD_MMC_SET_RCA, pdev->rca << 16, 0);
+			++state;
+			break;
+		case 7:
+		case 17:
+			status = mci_execute_command(pdev, CMD_SEND_CSD, pdev->rca << 16, 0);
+			memcpy(pdev->csd, pdev->response, 16);
+			state = 100;
+			break;
+		default:
+			/* break from while loop */
+			state += 100; 
+			break;
+		}
+	}
+
+	if (prv_card_acquired(pdev)) {
+		/* change delay gates per card type */
+		if (pdev->card_type & CARD_TYPE_SD)
+			SYS_REGS->mci_delaymodes = SYS_REG_SD_CARD_DELAY;
+		else
+			SYS_REGS->mci_delaymodes = SYS_REG_MMC_CARD_DELAY;
+
+		/*
+		 * now compute card size, block size and no. of blocks
+		 * based on CSD response recived.
+		 */
+		prv_process_csd(pdev);
+	}
+}
+
+int mmc_legacy_init(int verbose)
+{
+	/* enable SD/MMC clock */
+	cgu_clk_en_dis(CGU_SB_SD_MMC_HCLK_ID, 1);
+	cgu_clk_en_dis(CGU_SB_SD_MMC_CCLK_IN_ID, 1);
+
+	/* reset SD/MMC/MCI modules through CGU */
+	cgu_soft_reset_module(SD_MMC_PNRES_SOFT);
+	cgu_soft_reset_module(SD_MMC_NRES_CCLK_IN_SOFT);
+
+	/* Set IOCONF to MCI pins */
+	SYS_REGS->mci_delaymodes = 0;
+	SYS_REGS->mux_gpio_mci_sel = 1;
+	/* set the pins as driven by IP in IOCONF */
+	IOCONF->block[IOCONF_MUX0].mode1_clear = 0xF0000003;
+	IOCONF->block[IOCONF_MUX0].mode0_set = 0xF0000003;
+
+	/* set delay gates */
+	SYS_REGS->mci_delaymodes = SYS_REG_SD_CARD_DELAY;
+
+	/* reset all blocks */
+	MCI->ctrl = MCI_CTRL_RESET | MCI_CTRL_FIFO_RESET
+		| MCI_CTRL_DMA_RESET;
+	/* wait till resets clear */
+	while (MCI->ctrl & (MCI_CTRL_RESET | MCI_CTRL_FIFO_RESET |
+			MCI_CTRL_DMA_RESET));
+
+	/* Clear the interrupts for the host controller */
+	MCI->rintsts = 0xFFFFFFFF;
+
+	/* Put in max timeout */
+	MCI->tmout = 0xFFFFFFFF;
+
+	/* FIFO threshold settings */
+	MCI->fifoth = (0x2 << 28) | (0xF << 16) | (0x10 << 0);
+
+	/* disable clock to CIU */
+	MCI->clkena = 0;
+	MCI->clksrc = 0;
+
+	/* clear mmc structure*/
+	memset(&g_card_info, 0, sizeof(MCI_CARD_INFO_T));
+
+	/* start card enumeration */
+	mci_acquire(&g_card_info);
+	if(g_card_info.cid[0] == 0) {
+		return 1;
+	}
+	mmc_dev.if_type = IF_TYPE_MMC;
+	mmc_dev.part_type = PART_TYPE_DOS;
+	mmc_dev.dev = 0;
+	mmc_dev.lun = 0;
+	mmc_dev.type = 0;
+	mmc_dev.blksz = g_card_info.block_len;
+	mmc_dev.lba = g_card_info.blocknr;
+	sprintf((char*)mmc_dev.vendor, "Unknown vendor");
+	sprintf((char*)mmc_dev.product, "Unknown product");
+	sprintf((char*)mmc_dev.revision, "N/A");
+	mmc_dev.removable = 0;  /* should be true??? */
+	mmc_dev.block_read = mci_read_blocks;
+	mmc_dev.block_write = mci_write_blocks;
+
+	return 0;
+}
+
+ulong mci_read_blocks( int devid, ulong start_block,
+		long blkcnt, void* buffer)
+{
+	MCI_CARD_INFO_T* pdev = &g_card_info;
+	long end_block = start_block + blkcnt - 1; 
+	long cbRead = (end_block - start_block + 1) << 9; /*(end_block - start_block) * 512 */
+	long status;
+	long index;
+
+	if (blkcnt == 0)
+		return 0;
+//printf("JDS start %lx count %lx\n", start_block, blkcnt);
+
+	/* if card is not acquired return immediately */
+	if (prv_card_acquired(pdev) == 0) {
+	  printf("Card is not aquired\n");
+	  return -1;
+	}
+	/* check block index in range */
+	if(end_block < start_block) {
+	  printf("Invalid parameters: end_block %d < start_block %d cnt %d\n", end_block, start_block, blkcnt);
+	  return -1;
+	}
+	if(start_block < 0) {
+	  printf("Invalid parameters: start_block < 0\n");
+	  return -1;
+	}
+	if(end_block > pdev->blocknr) {
+	  printf("Invalid parameters: end_block > pdev->blocknr\n");
+	  return -1;	
+	}
+	/* put card in trans state */
+	if (prv_set_trans_state(pdev) != _NO_ERROR)
+		return 0;
+
+	/* set number of bytes to read */
+	MCI->bytcnt = cbRead;
+
+	/* if high capacity card use block indexing */
+	if (pdev->card_type & CARD_TYPE_HC)
+		index = start_block;
+	else
+		index = start_block << 9;
+
+	/* check how many blocks to read */
+	if (end_block == start_block) {
+		status = mci_execute_command(pdev, CMD_READ_SINGLE, index,
+				MCI_INT_CMD_DONE | MCI_INT_DATA_OVER | MCI_INT_RXDR);
+	}
+	else {
+		/* do read multiple */
+		status = mci_execute_command(pdev, CMD_READ_MULTIPLE, index,
+				MCI_INT_CMD_DONE | MCI_INT_DATA_OVER | MCI_INT_RXDR);
+	}
+
+	memset(buffer,0,cbRead);
+
+	/* read data from the FIFO */
+	if (status == 0)
+		cbRead = prv_pull_data((unsigned char*)buffer, cbRead);
+	else
+		cbRead = 0; /* return error if command fails */
+
+	return cbRead >> 9;
+}
+
+ulong mci_write_blocks(int devid, ulong start_block,
+		long blkcnt, void* buffer)
+{
+	MCI_CARD_INFO_T* pdev = &g_card_info;
+	/*(end_block - start_block) * 512 */
+	long end_block = start_block + blkcnt - 1; 
+	long cbWrote = (end_block - start_block + 1) << 9;
+	int status;
+	long index;
+
+	/* if card is not acquired return immediately */
+	if ((prv_card_acquired(pdev) == 0)
+			|| (end_block < start_block) /* check block index in range */
+			|| (start_block < 0)
+			|| (end_block > pdev->blocknr)) {
+		return 0;
+	}
+
+	/* put card in trans state */
+	if (prv_set_trans_state(pdev) != _NO_ERROR)
+		return 0;
+
+	/* set number of bytes to write */
+	MCI->bytcnt = cbWrote;
+
+	/* if high capacity card use block indexing */
+	if (pdev->card_type & CARD_TYPE_HC)
+		index = start_block;
+	else
+		index = start_block << 9;
+
+	/* check how many blocks to write */
+	if (end_block == start_block) {
+		status = mci_execute_command(pdev, CMD_WRITE_SINGLE, index,
+				MCI_INT_CMD_DONE | MCI_INT_TXDR);
+	}
+	else {
+		/* do write multiple */
+		status = mci_execute_command(pdev, CMD_WRITE_MULTIPLE, index,
+				MCI_INT_CMD_DONE | MCI_INT_TXDR);
+	}
+	/* write data to the FIFO */
+	if (status == 0) {
+		prv_push_data((unsigned char*)buffer, cbWrote);
+		/* wait for transfer done */
+		status = prv_wait_for_completion(pdev, MCI_INT_DATA_OVER);
+	}
+	else {
+		cbWrote = 0; /* return error if command fails */
+	}
+
+	return cbWrote >> 9;
+}
+
+
+unsigned int mmc_get_card_size(int dev)
+{
+	return (g_card_info.device_size >> 9);
+}
+
+block_dev_desc_t * mmc_get_dev(int dev)
+{
+	return (block_dev_desc_t *)(&mmc_dev);
+}
+
+#endif
diff --git a/arch/arm/cpu/arm926ejs/lpc313x/nand_format.c b/arch/arm/cpu/arm926ejs/lpc313x/nand_format.c
new file mode 100644
index 0000000..b6d1b37
--- /dev/null
+++ b/arch/arm/cpu/arm926ejs/lpc313x/nand_format.c
@@ -0,0 +1,351 @@
+/*
+* (C) Copyright 2010 NXP Semiconductors
+*
+* See file CREDITS for list of people who contributed to this
+* project.
+*
+* This program is free software; you can redistribute it and/or
+* modify it under the terms of the GNU General Public License as
+* published by the Free Software Foundation; either version 2 of
+* the License, or (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+* 
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the Free Software
+* Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+* MA 02111-1307 USA
+*/
+
+#include <common.h>
+#include <linux/mtd/mtd.h>
+#include <nand.h>
+
+#if defined(CONFIG_CMD_NAND)
+#include <asm/arch/sysreg.h>
+#include <asm/arch/nand.h>
+
+#define LPC313x_NAND_BPARAM_PAGE_SZ	256
+#define TIMEOUT_WAIT_ERASE		500
+
+/* Max Calculation: (14*510) + (1*509) */
+#define MAX_NUM_BAD_BLOCKS		7649
+
+extern const NAND_BOOT_CFG_PARAMS_T nandbootparams[];
+volatile unsigned int mem_based_bbt[MAX_NUM_BAD_BLOCKS + 1];
+
+static void wait_on_int (u32 int_mask, u32 tmo)
+{
+  unsigned long time_start = get_timer(0);
+
+  /* Wait for MLC NAND ready */
+  while (!(NAND_CTRL->irq_status_raw & int_mask)) {
+    if ( (get_timer(0) - time_start) >= tmo) {
+      printf ("\nbailing at timeout status 0x%08lx bits 0x%08x\n",
+        NAND_CTRL->irq_status_raw, int_mask);
+      break;
+    }
+  }
+}
+
+static int is_bad_block(unsigned int blkaddr)
+{
+  unsigned int i = 0;
+  while(mem_based_bbt[i] != 0xFFFFFFFF) {
+    if(blkaddr == mem_based_bbt[i])
+      return 1;
+    i++;
+  }
+  return 0;
+}
+
+static int nand_erase_block(unsigned long offset)
+{
+  int count;
+
+  NAND_CTRL->irq_status_raw = NAND_IRQ_RB1_POS_EDGE;
+  NAND_CTRL->set_cmd= NAND_CMD_ERASE1;
+
+  for (count=0; count< nandbootparams->amount_of_erase_address_bytes;
+    count++, offset >>= 8 )
+    NAND_CTRL->set_addr = (u8)( offset & 0xff );
+  NAND_CTRL->set_cmd = NAND_CMD_ERASE2;
+
+  wait_on_int(NAND_IRQ_RB1_POS_EDGE, TIMEOUT_WAIT_ERASE);
+
+  NAND_CTRL->set_cmd = NAND_CMD_STATUS;
+  udelay(5);
+  if (NAND_CTRL->read_data & NAND_STATUS_FAIL) {
+    return 0;
+  }
+
+  return 1;
+}
+
+static int erase_all_blocks(void)
+{
+  unsigned int page_num;
+  unsigned int blksize = ( nandbootparams->page_size_in_bytes *
+    nandbootparams->pages_per_block);
+  unsigned char *wbuffer = (unsigned char *)(0x30000000);
+  unsigned char *rbuffer = (unsigned char *)(0x30020000);
+
+  size_t len = 0;
+  int ret = 0;
+  unsigned int i = 0;
+  unsigned int bad_blk_cnt = 0;
+
+  memset(wbuffer,0xa5a5a5a5,(128 * 1024));
+
+  for( i = 0, page_num = nandbootparams->pages_per_block;
+    i < nandbootparams->nbr_of_blocks;
+    i++,page_num += nandbootparams->pages_per_block ) {
+      NAND_CTRL->set_ce = NAND_SETCE_WP | NAND_SETCE_CV(0);
+      if(nand_erase(&nand_info[0],(i * blksize),nand_info[0].erasesize) == 0) {
+
+        len = 128 * 1024;
+        ret = nand_write(&nand_info[0], (i * blksize), &len, wbuffer);
+        if(ret) {
+          printf("nand write failed for block%d\n",i);
+          return 1;
+        }
+        printf("\\\r");
+
+        len = 128 * 1024;
+        memset(rbuffer, 0x0,(128 * 1024));
+        ret = nand_read(&nand_info[0], (i * blksize), &len, rbuffer);
+        if(ret) {
+          printf("nand read failed for block%d\n",i);
+          return 1;
+        }
+
+        printf("-\r");
+        if(memcmp(wbuffer, rbuffer, (128 * 1024)) && (i != 0)) {
+          bad_blk_cnt++;
+          mem_based_bbt[bad_blk_cnt] = (i * blksize);
+        }
+      }
+      else {
+        bad_blk_cnt++;
+        mem_based_bbt[bad_blk_cnt] = (i * blksize);
+      }
+      printf("/\r");
+
+  }
+  mem_based_bbt[0] = bad_blk_cnt;
+  printf("\n");
+
+  /* Write NAND params and Bad Block Table in Block0 */
+  write_params_bbt(mem_based_bbt);
+
+  return 0;
+}
+
+static void erase_blocks_skipping_blk0_bbt_blks(void)
+{
+  unsigned int page_num;
+  unsigned char bad = 0;
+  unsigned int blkoff = 0;
+
+  /* Now, Erase all the blocks excluding Factory Bad blocks */
+  printf("Erasing all the blocks skipping Factory Bad Blocks,");
+  printf("last four blocks of MTD BBT and Block 0\n");
+  NAND_CTRL->set_ce = NAND_SETCE_WP | NAND_SETCE_CV(0);
+
+  for(page_num = nandbootparams->pages_per_block, blkoff = 1;
+    page_num < (nandbootparams->nbr_of_blocks *
+    nandbootparams->pages_per_block);
+  page_num += nandbootparams->pages_per_block ,blkoff++) {
+    /* Erase Block */
+    bad = is_bad_block(blkoff * (nandbootparams->page_size_in_bytes *
+      nandbootparams->pages_per_block));
+    if(!bad) {
+      nand_erase_block(page_num);
+    }
+  }
+}
+
+static int get_bbt_info (void)
+{
+  size_t len = 0;
+  unsigned int page_num;
+  unsigned int page_addr;
+  unsigned char page_data[2048];
+  unsigned int *bbt_info = NULL;
+  unsigned int total_bad_blks = 0;
+  unsigned short i = 0;
+  unsigned int magic_word_off = 0;
+  unsigned int num_blks_str_in_memory = 0;
+  unsigned int num_badblks_per_page = 0;
+  unsigned short first_badblk_pos = 0;
+
+  /* Read Page 1 of Block0 to get Factory BBT inforamtion */
+  page_num = 1;
+
+  num_blks_str_in_memory = 0;
+  while(1) {
+
+    page_addr = page_num * nandbootparams->page_size_in_bytes;
+    len = nandbootparams->page_size_in_bytes;
+    if (nand_read(&nand_info[0], page_addr, &len, page_data))
+      return -1;
+
+    /* Check for number of bad block in this page.
+    * if it is > 0, than serach for "BAD" string.
+    * if "BAD" is found, copy Bad block table addresses to RAM
+    * Based table.
+    */
+
+    bbt_info = (unsigned int*)&page_data[0];
+    if(page_num == 1) {
+
+      /* As first 4 bytes are of number of Bad blocks */
+      first_badblk_pos = 1;
+      total_bad_blks = bbt_info[0];
+      /* 509 Bad blocks for Page 1 */
+      num_badblks_per_page = nandbootparams->page_size_in_32bit_words - 3;
+    }
+    else {
+      first_badblk_pos = 0;
+      /* 510 Bad blocks for Page (2-15) */
+      num_badblks_per_page = nandbootparams->page_size_in_32bit_words - 2;
+    }
+
+    if(total_bad_blks > 0 && (total_bad_blks != 0xFFFFFFFF)) {
+
+      if((total_bad_blks - num_blks_str_in_memory) > num_badblks_per_page) {
+        magic_word_off = nandbootparams->page_size_in_32bit_words - 2;
+      }
+      else {
+        magic_word_off = (total_bad_blks - num_blks_str_in_memory) + 1;
+      }
+
+      if((page_data[sizeof(unsigned int) * magic_word_off] == 'B') &&
+        (page_data[(sizeof(unsigned int) * magic_word_off) + 1] == 'A') &&
+        (page_data[(sizeof(unsigned int) * magic_word_off) + 2] == 'D')) {
+
+          printf("Page %d found with Factory BBT information\n",page_num);
+          for(i = first_badblk_pos; i < magic_word_off; i++) {
+            mem_based_bbt[num_blks_str_in_memory] = bbt_info[i];
+            num_blks_str_in_memory++;
+          }
+          if(num_blks_str_in_memory == total_bad_blks)
+            break;
+          page_num++;
+      }
+      else {
+        printf("No Factory BBT on Page %d\n",page_num);
+        printf("Please run nand_params first\n");
+        break;
+      }
+    }
+    else {
+      printf("No Factory marked bad blocks on this device.\n");
+      break;
+    }
+  }
+
+  /* End of BBT Marker in Memory */
+  mem_based_bbt[num_blks_str_in_memory] = 0xFFFFFFFF;
+
+  return num_blks_str_in_memory;
+}
+
+int do_lpcnand_format (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
+{
+  const char *cmd;
+  int ret = 0;
+
+  /* need at least two arguments */
+  if (argc < 2)
+    goto usage;
+
+  cmd = argv[1];
+
+  if (strcmp(cmd, "easy") == 0) {
+
+    printf("It will restore whole nand device back to ");
+    printf("the state indicated by block0\n");
+    printf("Do you really want to format <y/n>\n");
+    while(1) {
+      ret = getc();
+      if(ret != 0)
+        break;
+    }
+
+    if(ret != 'y')
+      return 0;
+
+    memset(mem_based_bbt,0x0,sizeof(mem_based_bbt));
+    ret = get_bbt_info();
+    if(ret == -1) {
+      printf("not able to read Page 1 of Block0\n");
+      return 1;
+    }
+    if(ret > 0)
+      erase_blocks_skipping_blk0_bbt_blks();
+  }
+
+  else if(strcmp(cmd, "hard") == 0) {
+    printf("It will erase whole nand device.");
+    printf("Do you really want to format <y/n>\n");
+    while(1) {
+      ret = getc();
+      if(ret != 0)
+        break;
+    }
+
+    if(ret != 'y')
+      return 0;
+    if(erase_all_blocks())
+      printf("nand hard format faile\n");
+  }
+  else
+    cmd_usage(cmdtp);
+
+  return 0;
+
+usage:
+  cmd_usage(cmdtp);
+  return 1;
+}
+
+U_BOOT_CMD(
+           nand_format, 3, 1, do_lpcnand_format,
+           "lpc313x nand format",
+           "easy  - Erase all the blocks skipping Factory\n" 
+           "              bad blocks Table which is stored in Block 0\n"
+           "nand_format hard - Erase all the blocks and write flash params,\n"
+           "              Bad block table in Block0\n"
+           ""
+           );
+
+int do_lpcnand_badbbt_dump (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
+{
+  int i = 0;
+  int ret = 0;
+
+  ret = get_bbt_info();
+  if(ret == -1) {
+    printf("not able to read Page 1 of Block0\n");
+    return 1;
+  }
+
+  if(ret > 0) {
+    printf("Block 0 based bad blocks:\n");
+    while(mem_based_bbt[i] != 0xFFFFFFFF) {
+      printf("%x\n",mem_based_bbt[i]);
+      i++;
+    }
+  }
+  return 0;
+}
+
+U_BOOT_CMD(nand_bad_block0_dump, 1, 1, do_lpcnand_badbbt_dump,
+           "Display Block 0 based Factory Bad blocks",
+           ""
+           );
+#endif
diff --git a/arch/arm/cpu/arm926ejs/lpc313x/nand_params.c b/arch/arm/cpu/arm926ejs/lpc313x/nand_params.c
new file mode 100644
index 0000000..2e55e12
--- /dev/null
+++ b/arch/arm/cpu/arm926ejs/lpc313x/nand_params.c
@@ -0,0 +1,314 @@
+/*
+ * (C) Copyright 2010 NXP Semiconductors
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <linux/mtd/mtd.h>
+#include <nand.h>
+#include <malloc.h>
+
+#if defined(CONFIG_CMD_NAND)
+#include <asm/arch/sysreg.h>
+#include <asm/arch/nand.h>
+
+#define LPC313x_NAND_BPARAM_PAGE_SZ	256
+
+const NAND_BOOT_CFG_PARAMS_T nandbootparams[] =
+{
+	{
+		.tag = "NANDflsh",
+		.interface_width = 8,
+		.page_size_in_bytes = 2048,
+		.page_size_in_32bit_words = 512,
+		.pages_per_block = 64,
+		.nbr_of_blocks = 2048,
+		.amount_of_address_bytes = 5,
+		.amount_of_erase_address_bytes = 3,
+		.support_read_terminate = 1,
+		.page_increment_byte_nr = 2,
+		/* first 4bytes to fill with readid response */
+		.device_name = { 0x2C, 0xAA, 0xFF, 0x15, 0x20, 'M', 'T', '2',
+				'9', 'F', '2', 'G', '0', '8',},
+		/* assuming 90MHz clock (1clock = 11ns)to NAND block */
+		/* Note, timing macros tcopy naake clk +1 values. */
+		/* tsrd=3, tals=3, talh=1, tcls=3, tclh=1, */
+		.timing1 = NAND_TIM1_TSRD(3) | NAND_TIM1_TALS(3) |
+			NAND_TIM1_TALH(1) | NAND_TIM1_TCLS(3) | NAND_TIM1_TCLH(1),
+		/* tdrd=3, tebi=1, tch=1, tcs=4, treh=2, trp=4, twh=2, twp = 3*/
+		.timing2 = NAND_TIM2_TDRD(3) | NAND_TIM2_TEBI(1) |
+			NAND_TIM2_TCH(1) | NAND_TIM2_TCS(4) | NAND_TIM2_TRH(2) |
+			NAND_TIM2_TRP(4) | NAND_TIM2_TWH(2) | NAND_TIM2_TWP(3),
+		.ecc_mode = 5,
+		.id_mask = 0x6, /*except 2nd & 3rd byte check remains id bytes */
+	},
+};
+
+static int write_bbt_in_blk0(struct nand_chip *chip,unsigned int *bad_list_buf)
+{
+	nand_info_t *nand = NULL;
+	unsigned int bad_blk_count = 0;
+	char* buff_ptr = NULL;
+	unsigned int temp_buff[2];
+	int curr_pos = 0;
+	int magic_word_pos;
+	int page_nr;
+	size_t page_addr;
+	size_t len;
+	unsigned int off = 0;
+
+	curr_pos = 0;
+	page_nr = 1;
+	bad_blk_count = *bad_list_buf;
+	while (curr_pos < (bad_blk_count + 1)) {
+
+		if ( (bad_blk_count + 1 - curr_pos) < (nandbootparams->page_size_in_32bit_words - 2)) {
+			magic_word_pos = bad_blk_count + 1;
+		}
+		else {
+			magic_word_pos = curr_pos + nandbootparams->page_size_in_32bit_words - 2;
+		}
+		// printf("curr_pos:%d, bad_blk_count:%d, magic_pos:%d\n", curr_pos, bad_blk_count, magic_word_pos);
+
+		/* 
+		 * save last 2 words in current page to write with magic id & CRC.
+		 * Not needed if CBad < (chip->page_size_in_32bit_words - 2)
+		 */
+		temp_buff[0] = bad_list_buf[magic_word_pos];
+		temp_buff[1] = bad_list_buf[magic_word_pos + 1];
+
+		/* insert magic word */
+		buff_ptr = (char*)&bad_list_buf[magic_word_pos];
+		buff_ptr[0] = 'B';
+		buff_ptr[1] = 'A';
+		buff_ptr[2] = 'D';
+		buff_ptr[3] = (char)(page_nr & 0xFF);
+
+		/* compute CRC32 */
+		bad_list_buf[magic_word_pos + 1] = crc32_compute((u8*)&bad_list_buf[curr_pos],
+				((u32)&buff_ptr[4] - (u32)&bad_list_buf[curr_pos]));
+
+		page_addr = page_nr * nandbootparams->page_size_in_bytes;
+		len = nandbootparams->page_size_in_bytes;
+		if (nand_write(&nand_info[0], page_addr, &len,
+					(void*)(bad_list_buf + curr_pos))) {
+			printf("nand write failed\n");
+			return 1;
+		}
+		/*put back last 2 words*/
+		bad_list_buf[magic_word_pos] = temp_buff[0];
+		bad_list_buf[magic_word_pos + 1] = temp_buff[1];
+		/* move to next page */
+		page_nr++;
+		/* update current position in bad block list */
+		curr_pos = magic_word_pos;
+	}
+	return 0;
+}
+
+static unsigned int* prepare_bbt_for_blk0(struct nand_chip *chip)
+{
+	nand_info_t *nand = NULL;
+	unsigned int bad_blk_count = 0;
+	unsigned int* bad_list_buf = (unsigned int*)EXT_SDRAM_BASE;
+	unsigned int off = 0;
+
+	/* Prepare BBT in Memory and Write it to NAND for ROM Bootloader */
+	nand = &nand_info[nand_curr_device];
+	for (off = 0; off < nand->size; off += nand->erasesize) {
+		if (nand_block_isbad(nand, off)) {
+			bad_blk_count++;
+			*((u32*)(bad_list_buf + bad_blk_count)) = off;
+		}
+	}
+
+	printf("total bad blocks: %d\n",bad_blk_count);
+
+	/* update bad block count */
+	*bad_list_buf = bad_blk_count;
+
+	return bad_list_buf;
+}
+
+static int checkflashparams (struct nand_chip *chip, size_t offset, unsigned char *writeparam)
+{
+	size_t end = offset + sizeof(NAND_BOOT_CFG_PARAMS_T);
+	size_t amount_loaded = 0;
+	size_t blocksize, len;
+	u_char *char_ptr = NULL;
+	NAND_BOOT_CFG_PARAMS_T *tmpparams = NULL;
+
+	char_ptr = (u_char*)malloc(chip->subpagesize);
+	memset(char_ptr,0x0,chip->subpagesize);
+
+	blocksize = nand_info[0].erasesize;
+	len = min(blocksize, sizeof(NAND_BOOT_CFG_PARAMS_T));
+
+	/* Aligned len to subpage boundary */
+	len = (((len) + (chip->subpagesize - 1)) & ~ (chip->subpagesize - 1));
+
+	while (amount_loaded < sizeof(NAND_BOOT_CFG_PARAMS_T) && offset < end) {
+		if (nand_block_isbad(&nand_info[0], offset)) {
+			offset += blocksize;
+		} else {
+			if (nand_read(&nand_info[0], offset, &len, char_ptr))
+				return 1;
+			offset += blocksize;
+			amount_loaded += len;
+		}
+	}
+	if (amount_loaded != len)
+		return 1;
+
+	tmpparams = (NAND_BOOT_CFG_PARAMS_T *)char_ptr;
+
+	if((strncmp(tmpparams->tag,"NANDflsh", 8) == 0) &&
+			(tmpparams->interface_width == nandbootparams->interface_width ) &&
+			(tmpparams->page_size_in_bytes == nandbootparams->page_size_in_bytes) &&
+			(tmpparams->page_size_in_32bit_words ==
+			 nandbootparams->page_size_in_32bit_words)) {
+		printf("flash params are already written into flash\n");
+		*writeparam = 0;
+		return 0;
+	}
+	else {
+		printf("flash params are not written into flash\n");
+		*writeparam = 1;
+		return 0;
+	}
+
+}
+
+static int writeparams(struct nand_chip *chip, size_t offset, u_char *buf)
+{
+	size_t end = offset + sizeof(NAND_BOOT_CFG_PARAMS_T);
+	size_t amount_saved = 0;
+	size_t blocksize, len;
+	u_char *char_ptr = NULL;
+
+	blocksize = nand_info[0].erasesize;
+	len = min(blocksize, sizeof(NAND_BOOT_CFG_PARAMS_T));
+
+	/* Aligned len to subpage boundary */
+	len = (((len) + (chip->subpagesize - 1)) & ~ (chip->subpagesize - 1));
+
+	char_ptr = (u_char*)malloc(chip->subpagesize);
+
+	memset(char_ptr,0x0,chip->subpagesize);
+	memcpy(char_ptr,buf,sizeof(NAND_BOOT_CFG_PARAMS_T));
+
+	/* Compute CRC32. */
+	*((u32*)(char_ptr + (LPC313x_NAND_BPARAM_PAGE_SZ - 4))) =
+		crc32_compute(char_ptr, LPC313x_NAND_BPARAM_PAGE_SZ - 4);
+
+	while (amount_saved < sizeof(NAND_BOOT_CFG_PARAMS_T) && offset < end) {
+		if (nand_block_isbad(&nand_info[0], offset)) {
+			offset += blocksize;
+		} else {
+			if (nand_write(&nand_info[0], offset, &len,
+						&char_ptr[amount_saved]))
+				return 1;
+			offset += blocksize;
+			amount_saved += len;
+		}
+	}
+	if (amount_saved != len) {
+		printf("amount saved: %d, while actual: %d\n",amount_saved,len);
+		return 1;
+	}
+	return 0;
+}
+
+int write_params_bbt(unsigned int* bad_list_buf)
+{
+	nand_erase_options_t nand_erase_options;
+	struct nand_chip *chip = (struct nand_chip*) nand_info[nand_curr_device].priv;
+
+	nand_erase_options.length =
+		nandbootparams->page_size_in_bytes * nandbootparams->pages_per_block;
+	nand_erase_options.quiet = 1;
+	nand_erase_options.jffs2 = 0;
+	nand_erase_options.scrub = 0;
+	nand_erase_options.offset = 0;
+
+	printf ("Erasing Nand...\n");
+	if (nand_erase_opts(&nand_info[0], &nand_erase_options))
+		return 1;
+	printf ("Writing Flash Params to Nand... ");
+	if (writeparams(chip,0x0, (u_char *) nandbootparams)) {
+		puts("FAILED!\n");
+		return 1;
+	}
+	puts ("done\n");
+	
+	if(bad_list_buf == NULL)
+		bad_list_buf = prepare_bbt_for_blk0(chip);
+	write_bbt_in_blk0(chip,bad_list_buf);
+	return 0;
+}
+
+int prepare_write_nand_params_bbt(unsigned char isbooting)
+{
+	int ret = 0;
+	unsigned char writeparam = 0;
+	struct nand_chip *chip = (struct nand_chip*) nand_info[nand_curr_device].priv;
+	unsigned int* bad_list_buf = NULL;
+
+	checkflashparams(chip,0x0,&writeparam);
+
+	if(writeparam) {
+		if(write_params_bbt(bad_list_buf))
+			return 1;
+	}
+	else { 
+		if(!isbooting) { 
+			printf("It will overwrite the current BBT of Block0 ");
+			printf("with MTD BBT and\n");
+			printf("make Block 0 BBT in sync with MTD BBT\n");
+			printf("Do you really want to overwrite Block0 BBT: <y/n>\n");
+
+			while(1) {
+				ret = getc();
+				if(ret != 0)
+					break;
+			}
+
+			if(ret != 'y')
+				return 0;
+
+			if(write_params_bbt(bad_list_buf))
+				return 1;
+		}
+	} 
+
+	return 0;
+}
+
+int do_lpcnand_params (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
+{
+	prepare_write_nand_params_bbt(0);
+	return 0;
+}
+
+U_BOOT_CMD(nand_params, 1, 1, do_lpcnand_params,
+	"write NAND Flash params to be used by LPC BootROM code",
+	""
+);
+#endif
diff --git a/arch/arm/cpu/arm926ejs/lpc313x/serial.c b/arch/arm/cpu/arm926ejs/lpc313x/serial.c
new file mode 100644
index 0000000..6034f58
--- /dev/null
+++ b/arch/arm/cpu/arm926ejs/lpc313x/serial.c
@@ -0,0 +1,283 @@
+/*
+ * (C) Copyright 2002-2004
+ * Wolfgang Denk, DENX Software Engineering, <wd@denx.de>
+ *
+ * (C) Copyright 2002
+ * Sysgo Real-Time Solutions, GmbH <www.elinos.com>
+ * Marius Groeger <mgroeger@sysgo.de>
+ *
+ * (C) Copyright 2002
+ * Sysgo Real-Time Solutions, GmbH <www.elinos.com>
+ * Alex Zuepke <azu@sysgo.de>
+ *
+ * Copyright (C) 1999 2000 2001 Erik Mouw (J.A.K.Mouw@its.tudelft.nl)
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+#include <common.h>
+#include <asm/arch/hardware.h>
+#include <asm/arch/uart.h>
+#include <asm/arch/clock.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+//static unsigned int uart_init = 0;
+
+long uart_set_divisors(ulong baudrate)
+{
+	long errorStatus = _ERROR;
+	UART_REGS_T *regptr = (UART_REGS_T *)UART_BASE;
+	ulong uClk;
+	ulong calcBaudrate = 0;
+	ulong temp = 0;
+	ulong mulFracDiv, dividerAddFracDiv;
+	ulong diviser = 0 ;
+	ulong mulFracDivOptimal = 1;
+	ulong dividerAddOptimal = 0;
+	ulong diviserOptimal = 0;
+	ulong relativeError = 0;
+	ulong relativeOptimalError = 100000;
+
+	/* get UART block clock */
+	uClk = cgu_get_clk_freq(CGU_SB_UART_U_CLK_ID);
+
+	/* div by 16 */
+	uClk = uClk >> 4;
+	/* 
+	 * In the Uart IP block, baud rate is calculated using FDR and DLL-DLM
+	 * registers. The formula is :
+	 * BaudRate= uClk * (mulFracDiv/(mulFracDiv+dividerAddFracDiv) / (16 * (DLL)
+	 * It involves floating point calculations. That's the reason the
+	 * formulae are adjusted with Multiply and divide method.
+	 * The value of mulFracDiv and dividerAddFracDiv should comply
+	 * to the following expressions:
+	 * 0 < mulFracDiv <= 15, 0 <= dividerAddFracDiv <= 15
+	 */
+	for (mulFracDiv = 1 ; mulFracDiv <= 15 ;mulFracDiv++) {
+		for (dividerAddFracDiv = 0 ; dividerAddFracDiv <= 15 ;dividerAddFracDiv++) {
+			temp = (mulFracDiv * uClk) / ((mulFracDiv + dividerAddFracDiv));
+
+			diviser = temp / baudrate;
+			if ((temp % baudrate) > (baudrate / 2))
+				diviser++;
+
+			if (diviser > 2 && diviser < 65536) {
+				calcBaudrate = temp / diviser;
+
+				if (calcBaudrate <= baudrate)
+					relativeError = baudrate - calcBaudrate;
+				else
+					relativeError = calcBaudrate - baudrate;
+
+				if ((relativeError < relativeOptimalError)) {
+					mulFracDivOptimal = mulFracDiv ;
+					dividerAddOptimal = dividerAddFracDiv;
+					diviserOptimal = diviser;
+					relativeOptimalError = relativeError;
+					if (relativeError == 0)
+						break;
+				}
+			} /* End of if */
+		} /* end of inner for loop */
+		if (relativeError == 0)
+			break;
+	} /* end of outer for loop */
+
+	if (relativeOptimalError < (baudrate / 30)) {
+		/* Disable all UART interrupts */
+		regptr->dlm_ie = 0;
+
+		/* Set the `Divisor Latch Access Bit` and enable so the DLL/DLM access*/
+		regptr->lcr |= UART_LCR_DIVLATCH_EN;
+		/* Initialise the `Divisor latch LSB` and `Divisor latch MSB` registers */
+		regptr->dll_fifo = UART_LOAD_DLL(diviserOptimal);
+		regptr->dlm_ie = UART_LOAD_DLM(diviserOptimal);
+		regptr->lcr &= ~ UART_LCR_DIVLATCH_EN;
+
+		/* Initialise the Fractional Divider Register */
+		regptr->fdr = UART_FDR_MUL_SET(mulFracDivOptimal) |
+				UART_FDR_DIVADD_SET(dividerAddOptimal);
+
+		errorStatus = _NO_ERROR;
+	}
+	return errorStatus;
+}
+
+long uart_setup_trans_mode(ulong baud_rate)
+{
+	UART_REGS_T *regptr = (UART_REGS_T *)UART_BASE;
+	ulong tmp = 0;
+	long err = _NO_ERROR;
+
+
+	tmp |= UART_LCR_WLEN_8BITS;
+	/* Find closest baud rate for desired clock frequency */
+	err = uart_set_divisors(baud_rate);
+
+	if (err == _NO_ERROR) {
+		/* Set new UART settings */
+		regptr->lcr = tmp;
+	}
+
+	return err;
+}
+
+long uart_read(void *buffer, long max_bytes)
+{
+	long bread = 0;
+	UART_REGS_T *regptr = (UART_REGS_T *)UART_BASE;
+	unsigned char *buff8 = (unsigned char *) buffer;
+
+	/* Wait for a character from the UART */
+	while ((regptr->lsr & UART_LSR_RDR) == 0);
+
+	while ((max_bytes > 0) && ((regptr->lsr & UART_LSR_RDR) != 0)) {
+		*buff8 = (unsigned char) regptr->dll_fifo;
+		buff8++;
+		max_bytes--;
+		bread++;
+	}
+
+	return bread;
+}
+
+
+long uart_write(void *buffer, long n_bytes)
+{
+	long bwrite = 0;
+	UART_REGS_T *regptr = (UART_REGS_T *)UART_BASE;
+	unsigned char *buff8 = (unsigned char *) buffer;
+
+	/* Only add data if the current FIFO level can be determined */
+	while ((regptr->lsr & UART_LSR_TEMT) == 0){}
+
+	if ((regptr->lsr & UART_LSR_TEMT) != 0) {
+		/* Assuming TX fifo is 32 byte deep. */
+		if (n_bytes > 32) {
+			n_bytes = 32;
+		}
+		while (n_bytes > 0) {
+			regptr->dll_fifo = (ulong) * buff8;
+			buff8++;
+			n_bytes--;
+			bwrite++;
+		}
+	}
+
+	return bwrite;
+}
+
+int uart_rx_char (unsigned char *buff)
+{
+	UART_REGS_T *regptr = (UART_REGS_T *)UART_BASE;
+
+	if((regptr->lsr & UART_LSR_RDR) == 0)
+		return 0;
+
+	*buff = (unsigned char)regptr->dll_fifo;
+
+	return 1;
+}
+
+void serial_setbrg (void)
+{
+}
+
+int serial_init (void)
+{
+	UART_REGS_T *regptr = (UART_REGS_T *)UART_BASE;
+	volatile ulong tmp;
+
+//	if(uart_init == 0) {
+		/* UART is free */
+//		uart_init = 1;
+
+		/* Enable UART system clock */
+		cgu_clk_en_dis(CGU_SB_UART_APB_CLK_ID, 1);
+		cgu_clk_en_dis(CGU_SB_UART_U_CLK_ID, 1);
+
+		uart_setup_trans_mode(gd->baudrate);
+
+		/* Clear FIFOs, set FIFO level, and pending interrupts */
+		regptr->iir_fcr = (UART_FCR_RXFIFO_TL16 |
+				UART_FCR_FIFO_EN | UART_FCR_TXFIFO_FLUSH |
+				UART_FCR_RXFIFO_FLUSH);
+		tmp = regptr->iir_fcr;
+		tmp = regptr->lsr;
+
+		/* Receive and RX line status interrupts enabled */
+		regptr->dlm_ie = (UART_IE_RXLINE_STS |
+				UART_IE_RDA | UART_IE_THRE);
+
+//	}
+	return (0);
+}
+
+/*
+ * Output a single byte to the serial port.
+ */
+void serial_putc (const char c)
+{
+	if (c == '\n')
+		uart_write("\r\n", 2);
+	else
+		uart_write((void *)&c, 1);
+}
+
+/*
+ *Test whether a character is in the RX buffer
+ */
+
+int serial_tstc (void)
+{
+	UART_REGS_T *regptr = (UART_REGS_T *)UART_BASE;
+
+//	if(uart_init == 1) {
+		if ((regptr->lsr & UART_LSR_RDR) == 0) {
+			return 0;
+		}
+		else
+			return 1;	
+//	}
+//	else
+//		return -1;
+}
+
+/*
+ * Read a single byte from the serial port. Returns 1 on success, 0
+ * otherwise. When the function is succesfull, the character read is
+ * written into its argument c.
+ */
+int serial_getc (void)
+{
+	char c = 0;
+	int ret = 0;
+	ret = uart_read(&c, 1);
+	return c;
+}
+
+void serial_puts (const char *s)
+{
+	while (*s) {
+		serial_putc (*s++);
+	}
+}
+
+int serial_getchar(unsigned char* buf)
+{
+	return uart_rx_char(buf);
+}
diff --git a/arch/arm/cpu/arm926ejs/lpc313x/spi.c b/arch/arm/cpu/arm926ejs/lpc313x/spi.c
new file mode 100644
index 0000000..b5ba64c
--- /dev/null
+++ b/arch/arm/cpu/arm926ejs/lpc313x/spi.c
@@ -0,0 +1,350 @@
+/*
+ * (C) Copyright 2010 NXP Semiconductors
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <asm/arch/spi.h>
+#include <asm/arch/clock.h>
+#include <asm/arch/ioconf.h>
+
+#ifdef CONFIG_HARD_SPI
+#define CMD_DP		0xB9	/* deep power down */
+#define CMD_RES		0xAB	/* release from deep power down */
+
+void spinor_cs_low(void)
+{
+	gpio_set_outpin_low(IOCONF_SPI, 4);
+}
+
+void spinor_cs_high(void)
+{
+	gpio_set_outpin_high(IOCONF_SPI, 4);
+}
+
+void spi_flush_rx_fifo(void)
+{
+	unsigned int tmp = 0;
+
+	SPI_REGS_T *regptr = (SPI_REGS_T *)SPI_BASE;
+
+	while ((regptr->status & SPI_ST_RX_EMPTY) == 0) {
+		tmp = regptr->fifo_data;
+	}
+}
+
+void spi_flush_tx_fifo(void)
+{
+	SPI_REGS_T *regptr = (SPI_REGS_T *)SPI_BASE;
+
+	while ((regptr->status & SPI_ST_TX_EMPTY) == 0) {
+		regptr->tx_fifo_flush = SPI_TXFF_FLUSH;
+	}
+}
+
+unsigned int spi_get_status()
+{
+	SPI_REGS_T *regptr = (SPI_REGS_T *)SPI_BASE;
+	return regptr->status;
+}
+
+static void spinor_exit_deep_power_down(void)
+{
+	long rbytes = 0;
+	unsigned char dummy;
+	long bytes = 1;
+	unsigned char command_byte = CMD_RES;
+	unsigned int status = 0;;
+
+	/* should we wait for command to txfer */
+	spinor_cs_low();
+
+	/* flush the FFOS */
+	spi_flush_rx_fifo();
+
+	/* write the commands */
+	spi_write(&command_byte, bytes);
+
+	/* wait till SPI is not busy */
+	do {
+		status = spi_get_status();
+	}
+	while ((status & SPI_ST_TX_EMPTY) != SPI_ST_TX_EMPTY);
+
+	while (rbytes < bytes) {
+		rbytes += spi_read(&dummy, 1);
+	}
+
+	spinor_cs_high();
+
+	/* max tEDPD in Atmel AT45DB161D-SU datasheet is given as 35 usec */
+	udelay(50);
+}
+
+SPI_SLAVE_ID_T spi_get_cur_slave(SPI_REGS_T *regptr)
+{
+	SPI_SLAVE_ID_T sid = SPI_INVALID_ID;
+	switch (regptr->slave_enable) {
+	case SPI_SLV_EN(SPI_SLAVE1_ID):
+		sid = SPI_SLAVE1_ID;
+		break;
+	case SPI_SLV_EN(SPI_SLAVE2_ID):
+		sid = SPI_SLAVE2_ID;
+		break;
+	case SPI_SLV_EN(SPI_SLAVE3_ID):
+		sid = SPI_SLAVE3_ID;
+		break;
+	default:
+		sid = SPI_INVALID_ID;
+		break;
+	}
+	return sid;
+}
+
+static long spi_get_clock_div(ulong target_clock,
+		ulong *pDivSet)
+{
+	ulong div, spi_clk, ps, div1;
+	long retvalue = _ERROR;
+
+	/*
+	 * The SPI clock is derived from the (main system oscillator / 2),
+	 * so compute the best divider from that clock
+	 */
+	spi_clk = cgu_get_clk_freq(CGU_SB_SPI_CLK_ID);
+
+	/*
+	 * Find closest divider to get at or under the target frequency.
+	 * Use smallest prescaler possible and rely on the divider to get
+	 * the closest target frequency
+	*/
+	div = (spi_clk + target_clock / 2) / target_clock;
+
+	if ((div < SPI_MAX_DIVIDER) && (div > SPI_MIN_DIVIDER)) {
+		ps = (((div - 1) / 512) + 1) * 2;
+		div1 = ((((div + ps / 2) / ps) - 1));
+
+		/* write the divider settings */
+		*pDivSet = SPI_SLV1_CLK_PS(ps) | SPI_SLV1_CLK_DIV1((div1));
+
+		retvalue = _NO_ERROR;
+	}
+
+	return retvalue;
+}
+
+long spi_write(void *buffer, long n_fifo)
+{
+	SPI_REGS_T *regptr = (SPI_REGS_T *)SPI_BASE;
+	long count = 0;
+	ushort *data16 = NULL;
+	unsigned char *data8 = NULL;
+	SPI_SLAVE_ID_T sid;
+	unsigned char tmpbuf[SPI_FIFO_DEPTH]; 
+
+	memset(&tmpbuf,0x0,SPI_FIFO_DEPTH);
+	if(!buffer)
+		buffer = &tmpbuf;
+
+	/* get current active slave */
+	sid = spi_get_cur_slave(regptr);
+
+	if (sid != SPI_INVALID_ID)
+	{
+		if (SPI_SLV2_WD_SZ(regptr->slv_setting[sid].setting2) > 8) {
+			data16 = (ushort *)buffer;
+		}
+		else {
+			data8 = (unsigned char *)buffer;
+		}
+		/* restrict single to max fifo depth */
+		n_fifo = (n_fifo > SPI_FIFO_DEPTH) ? SPI_FIFO_DEPTH : n_fifo;
+		
+		/* Loop until transmit ring buffer is full or until n_bytes expires */
+		while ((n_fifo > 0) &&
+				((regptr->status & SPI_ST_TX_FF) != SPI_ST_TX_FF)) {
+			if (data16 == NULL) {
+				regptr->fifo_data = (ulong) * data8;
+				data8++;
+			}
+			else {
+				regptr->fifo_data = (ulong) * data16;
+				data16++;
+			}
+
+			/* Increment data count and decrement buffer size count */
+			count++;
+			n_fifo--;
+		}
+	}
+	return count;
+}
+
+long spi_read(void *buffer, long max_fifo)
+{
+	SPI_REGS_T *regptr = (SPI_REGS_T *)SPI_BASE;
+	long count = 0;
+	ushort *data16 = NULL;
+	unsigned char *data8 = NULL;
+	SPI_SLAVE_ID_T sid;
+	unsigned char tmpbuf[SPI_FIFO_DEPTH];
+
+	memset(&tmpbuf,0x0,SPI_FIFO_DEPTH);
+	if(!buffer)
+		buffer = &tmpbuf;
+
+	/* get current active slave */
+	sid = spi_get_cur_slave(regptr);
+
+	if (sid != SPI_INVALID_ID) {
+		/* determine sample width */
+		if (SPI_SLV2_WD_SZ(regptr->slv_setting[sid].setting2) > 8) {
+			data16 = (ushort *)buffer;
+		}
+		else {
+			data8 = (unsigned char *)buffer;
+		}
+		/* Loop until transmit ring buffer is full or until n_bytes expires */
+		while ((max_fifo > 0) &&
+				((regptr->status & SPI_ST_RX_EMPTY) != SPI_ST_RX_EMPTY)) {
+			if (data16 == NULL) {
+				*data8 = (unsigned char)regptr->fifo_data;
+				data8++;
+			}
+			else {
+				*data16 = (ushort)regptr->fifo_data;
+				data16++;
+			}
+
+			/* Increment data count and decrement buffer size count */
+			count++;
+			max_fifo--;
+		}
+	}
+	return count;
+}
+
+static long spi_slave_configure(SPI_SLAVE_CONFIG_T *pSlaveCfg)
+{
+	ulong set1, set2;
+	long setup = _ERROR;
+	SPI_REGS_T *regptr = (SPI_REGS_T *)SPI_BASE;
+
+	/* get clock divider setting */
+	if (spi_get_clock_div(pSlaveCfg->clk, &set1) == _NO_ERROR) {
+		/* set no of words for SMS mode and inter frame delay timing */
+		set1 |= SPI_SLV1_NUM_WORDS(pSlaveCfg->words) |
+			SPI_SLV1_INTER_TX_DLY(pSlaveCfg->inter_delay);
+
+		/* set data width & pre-post delay timing */
+		set2 = SPI_SLV2_WD_SZ(pSlaveCfg->databits - 1) |
+			SPI_SLV2_PPCS_DLY(pSlaveCfg->pp_delay);
+
+		/* set the transfer mode */
+		switch (pSlaveCfg->mode) {
+		case SSI_MODE:
+			set2 = SPI_SLV2_SSI_MODE;
+			break;
+		case SPI_MODE1:
+			set2 |= SPI_SLV2_SPH;
+			break;
+		case SPI_MODE2:
+			set2 |= SPI_SLV2_SPO;
+			break;
+		case SPI_MODE3:
+			set2 |= SPI_SLV2_SPO | SPI_SLV2_SPH;
+			break;
+		default:
+			break;
+		}
+		/* check is CS high is needed */
+		if (pSlaveCfg->cs_high)
+			set2 |= SPI_SLV2_CS_HIGH;
+
+		/* finally write to the register */
+		regptr->slv_setting[pSlaveCfg->sid].setting1 = set1;
+		regptr->slv_setting[pSlaveCfg->sid].setting2 = set2;
+
+		setup = _NO_ERROR;
+	}
+	return setup;
+}
+
+long lpc313x_setup_slave(SPI_SLAVE_CONFIG_T *slavecfg)
+{
+	SPI_REGS_T *regptr = (SPI_REGS_T *)SPI_BASE;
+
+	lpc313x_spi_init();
+	
+	/* de-select the device by pulling the CS high. */
+	gpio_set_outpin_high(IOCONF_SPI, 4);
+
+	/* Reset SPI block */
+	regptr->spi_config = SPI_CFG_SW_RESET;
+
+	/* Configure SPI slave */
+	if(spi_slave_configure(slavecfg) != 0) {
+		printf("failed to configure spi slave\n");
+		return -1;
+	}
+
+	/* enable the last configured slave only */
+	regptr->slave_enable = SPI_SLV_EN(0);
+	/* inform the SPI block about changes in slave enable */
+	regptr->spi_config |= SPI_CFG_UPDATE_EN;
+
+	/* make sure SPI module is enabled */
+	regptr->spi_config |= SPI_CFG_ENABLE;
+
+	spinor_exit_deep_power_down();
+	return 0;
+}
+
+static spi_init = 0;
+
+long lpc313x_spi_init(void)
+{
+	if (!spi_init) {
+		SPI_REGS_T *regptr = (SPI_REGS_T *)SPI_BASE;
+
+		/* Enable SPI clock */
+		cgu_clk_en_dis(CGU_SB_SPI_PCLK_ID, 1);
+		cgu_clk_en_dis(CGU_SB_SPI_PCLK_GATED_ID, 1);
+		cgu_clk_en_dis(CGU_SB_SPI_CLK_ID, 1);
+		cgu_clk_en_dis(CGU_SB_SPI_CLK_GATED_ID, 1);
+
+		/* set master mode & also set inter slave delay */
+		regptr->spi_config |= SPI_CFG_INTER_DLY(1);
+
+		/* Empty FIFO */
+		regptr->tx_fifo_flush = SPI_TXFF_FLUSH;
+
+		/* Clear latched interrupts */
+		regptr->int_clr_enable = SPI_ALL_INTS;
+		regptr->int_clr_status = SPI_ALL_INTS;
+
+		/* Enable interrupts */
+		regptr->int_set_enable = (SPI_OVR_INT |
+				SPI_RX_INT | SPI_TX_INT);
+		spi_init = 1;
+	}
+	return 0;
+}
+#endif
diff --git a/arch/arm/cpu/arm926ejs/lpc313x/spl.c b/arch/arm/cpu/arm926ejs/lpc313x/spl.c
new file mode 100644
index 0000000..4ba353b
--- /dev/null
+++ b/arch/arm/cpu/arm926ejs/lpc313x/spl.c
@@ -0,0 +1,596 @@
+/*
+ * (C) Copyright 2010 NXP Semiconductors
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <nand.h>
+#include <spi_flash.h>
+#include <mmc.h>
+#include <malloc.h>
+#include <image.h>
+#include <asm/arch/hardware.h>
+#include <asm/arch/clock.h>
+#include <asm/arch/sysreg.h>
+#include <asm/arch/ioconf.h>
+#include <asm/arch/mci.h>
+#include <asm/arch/timer.h>
+#include <asm/arch/i2c.h>
+#include <asm/arch/common.h>
+#include "dos_partition.h"
+
+typedef enum
+{
+	LPC313X_BOOT_MODE_NAND = 0,
+	LPC313X_BOOT_MODE_SPI,
+	LPC313X_BOOT_MODE_DFU_USB,
+	LPC313X_BOOT_MODE_SD_MMC,
+	LPC313X_BOOT_MODE_RESERVED,
+	LPC313X_BOOT_MODE_NOR_FLASH,
+	LPC313X_BOOT_MODE_UART,
+	LPC313X_BOOT_MODE_TEST,
+} LPC313X_BOOT_MODE_T;
+
+/* LPC313x macros */
+#define LPC313X_BOOTMODE_MASK		0x00000007
+#define UART_DOWNLOAD_TIMEOUT_END_US	10000
+#define UART_DOWNLOAD_TIMEOUT_START_US	10000000
+#define READ_BLOCK_SIZE			(512)
+
+#ifdef CONFIG_EA3152
+#define AD_SLAVE_ADDR			(0x18)
+#define AD_REG_OTGDCLIC_RW		0x0000
+#define ANALOG_1V8_RAIL			2
+/* 1v4 io voltage rail adjustments */
+#define PSU_VOUT3_1_80			_BIT(16)
+#endif
+
+/* Memory macros */
+#define LPC313X_ISRAM_BASE_ADD		0x11029000
+#define LPC313X_SDRAM_TEMP_DATA_ADDR	0x32000000
+
+/* SPI NOR flash macros */
+#define LPC313X_SPI_NOR_UBOOT_SECTOR	0x0
+#define LPC313X_SPI_NOR_SECTOR_SIZE	0x40000
+
+/* SD/MMC macros */
+#define LBA_STEP_MCI			32
+/* based on LBA_STEP_MCI define we will search first 32MB of the partition only */
+#define MAX_IMAGE_SEARCH_NUM_OF_BLOCKS	2048
+
+/* USB macros */
+#define EVT_usb_pll_bank		3
+#define EVT_usb_atx_pll_lock_bit	_BIT(25)
+
+//extern long __INITIAL_DATA_END;
+extern long __initial_boot_image_size;
+
+//int is_nand_init_done = 0;
+//int is_spi_init_done = 0;
+
+/* Define global data structure pointer to it*/
+static gd_t gdata __attribute__ ((section(".data")));
+static bd_t bdata __attribute__ ((section(".data")));
+
+inline void hang(void)
+{
+	puts("### ERROR ### Please RESET the board ###\n");
+	for (;;)
+		;
+}
+
+void GPIOMuxSetup(void)
+{
+	gpio_set_outpin_high(IOCONF_GPIO, 2);
+}
+
+void board_init_f(ulong dummy)
+{
+	//GPIOMuxSetup();
+	/*
+	 * We call relocate_code() with relocation target same as the
+	 * CONFIG_SYS_SPL_TEXT_BASE. This will result in relocation getting
+	 * skipped. Instead, only .bss initialization will happen. That's
+	 * all we need
+	 */
+	debug(">>board_init_f()\n");
+	relocate_code(CONFIG_SYS_INIT_SP_ADDR, &gdata, CONFIG_SPL_TEXT_BASE);
+}
+
+#ifdef CONFIG_CPU_USBDFU_BOOT
+extern unsigned char stop_polling;
+#endif
+
+DECLARE_GLOBAL_DATA_PTR;
+
+typedef struct boot_header {
+	int vector;
+	int magic;
+	long crc;
+	unsigned char reserved[16];
+	int imageType;
+	int imageLength;
+} boot_header_t;
+
+#ifdef CONFIG_CPU_MMC_BOOT
+int find_and_load_mci_image (volatile unsigned char * loadPointer,
+		unsigned int startLBA, unsigned int sizeInLBA)
+{
+	unsigned int mci_block_index;
+	unsigned int mci_block_limit;
+	unsigned int image_length;
+	boot_header_t *bhdr = (boot_header_t *)loadPointer;
+	image_header_t *ihdr = (image_header_t *)loadPointer;
+
+	mci_block_index = startLBA;
+	mci_block_limit = startLBA;
+
+	if (sizeInLBA > ((unsigned int) (MAX_IMAGE_SEARCH_NUM_OF_BLOCKS *
+					LBA_STEP_MCI))) {
+		mci_block_limit += ((unsigned int) (MAX_IMAGE_SEARCH_NUM_OF_BLOCKS *
+					 LBA_STEP_MCI));
+	}
+	else {
+		mci_block_limit += sizeInLBA;
+	}
+
+	while (mci_block_index < mci_block_limit) {
+		/* Read the header */
+		if (mci_read_blocks((int)mmc_get_dev(0), mci_block_index, 1, loadPointer) == 0) {
+			/* This error while reading was not expected so return with failure */
+			return (-1);
+		}
+		/* skip over the SPL boot image */
+		if (bhdr->magic == 0x41676d69) {
+			mci_block_index += bhdr->imageLength / READ_BLOCK_SIZE;
+			continue;
+		}
+		if (!image_check_magic(ihdr)) {
+			puts("Bad Magic Number\n");
+			mci_block_index += (unsigned int) LBA_STEP_MCI;
+			continue;
+		}
+		image_length = image_get_data_size(ihdr) + sizeof(*ihdr);
+
+		/* Yes it makes sense, so try loading the rest of the image
+		 * first test if the image fits the medium */
+		if ((((image_length + READ_BLOCK_SIZE - 1)/READ_BLOCK_SIZE)
+					+ mci_block_index) > (startLBA + sizeInLBA)) {
+			mci_block_index += (unsigned int) LBA_STEP_MCI;
+			continue;
+		}
+		/* Yes, the image fits the medium so load it */
+		if (mci_read_blocks((int)mmc_get_dev(0),mci_block_index+1,
+				((image_length + READ_BLOCK_SIZE - 1)/READ_BLOCK_SIZE),
+				loadPointer + READ_BLOCK_SIZE) == 0)
+			/* this error while reading was not expected so return with failure */
+			return (-1);
+
+		if (!image_check_hcrc(ihdr)) {
+			puts("Bad Header Checksum\n");
+			mci_block_index += (unsigned int) LBA_STEP_MCI;
+			continue;
+		}
+		return 0;
+	}
+
+	return -1;
+}
+#endif
+
+static int timer_expired(ulong timeStart, ulong timeDelta)
+{
+	ulong currTime = 0;
+
+	currTime = get_timer(0);
+	if (((currTime - timeStart) > timeDelta))
+		return 1;
+
+	return 0;
+}
+
+static int usb_copy_boot_image(ulong image_length, volatile unsigned char * loadPointer)
+{
+#ifdef CONFIG_CPU_USBDFU_BOOT
+	u32 i = 500;
+
+	while(!stop_polling) {
+		usbtty_poll();
+	}
+	/* do usbtty_poll() for the DFU Class status request to complete */
+	while(i) {
+		usbtty_poll();
+		i--;
+	}
+#else
+	printf("Please enable USB Gadget supoprt before selecting USB DFU boot mode\n");
+#endif
+	return 0;
+}
+
+static int sdmmc_copy_boot_image(volatile unsigned char * loadPointer)
+{
+#ifdef CONFIG_CPU_MMC_BOOT
+	unsigned int partition_number;
+	partition_t partitionInfo;
+	unsigned int max_num_sectors = mmc_get_card_size((int)mmc_get_dev(0));
+	unsigned int ret = 0;
+
+	/* Check if there is partition table on the device */
+	if (0 == partition_table_probe()) {
+		/* Yes there is, so try the partitions for the image. Search bootIt partition first
+		 * so pass partition_number = 0 first. Usualy 0 is invalid partition number.
+		 */
+		for (partition_number = 0; partition_number <= MAX_PARTITION;
+					 partition_number++) {
+			if (0 == partition_get_info (&partitionInfo, partition_number)) {
+				/* Check if the partition fits in the media (corrupt partition table check) */
+				if ((partitionInfo.start_lba + partitionInfo.size_lba) <=
+					max_num_sectors) {
+					/* Found a valid partition, so try finding a image */
+					ret = find_and_load_mci_image (loadPointer,
+							partitionInfo.start_lba,
+							partitionInfo.size_lba);
+					if (ret == 0) {
+						/* Good image found. */
+						return 0;
+					}
+				}
+			}
+		}
+	}
+#else
+	printf("Please enable MMC supoprt before selecting MMC boot mode\n");
+#endif
+	return 0;
+}
+
+static int flash_copy_boot_image(ulong image_length, volatile unsigned char * loadPointer)
+{
+	printf("Parallel flash boot mode is not supported\n");
+	return 0;
+}
+static int nand_copy_boot_image(ulong image_length, volatile unsigned char * loadPointer)
+{
+#ifdef CONFIG_CPU_NAND_BOOT
+	size_t len = 0;
+	int ret = 0;
+
+	len = image_length;
+	printf("reading NAND..");
+	ret = nand_read_skip_bad(&nand_info[0], 0x20000, &len,
+			(u_char *)loadPointer);
+	if(ret) {
+		printf("Failed\n");
+		return -1;
+	}
+	else {
+		printf("Done\n");
+	}
+#else
+	printf("Please enable NAND supoprt before selecting NAND boot mode\n");
+#endif
+	return 0;
+}
+
+static int spi_copy_boot_image(ulong image_length, volatile unsigned char * loadPointer)
+{
+#ifdef CONFIG_CPU_SPI_BOOT
+	struct spi_flash *flash = NULL;
+	int ret = 0;
+
+	flash = spi_flash_probe(0, 0, 0, 0);
+	if (!flash) {
+		printf("Failed to initialize SPI flash\n");
+		return 1;
+	}
+
+	printf("reading SPI NOR..");
+	ret = spi_flash_read(flash,(LPC313X_SPI_NOR_UBOOT_SECTOR * LPC313X_SPI_NOR_SECTOR_SIZE),
+			image_length, (void *)loadPointer);
+
+	if (ret) {
+		printf("Failed\n");
+		return -1;
+	}
+	printf("Done\n");
+#else
+	printf("Please enable SPI supoprt before selecting SPI boot mode\n");
+#endif
+	return 0;
+}
+
+static int uart_copy_boot_image(volatile unsigned char *loadPointer)
+{
+	u32 byteCount = 0;
+	ulong timeoutValue = 0;
+	ulong timerexpire = 0;
+	ulong timeStart = 0;
+	image_header_t *hdr = (image_header_t *)loadPointer;
+	uint32_t image_length = sizeof(image_header_t);
+
+	/* Download the image until the maximal size is reached
+	 * or a timeout on the byte reception happened.
+	 */
+
+	timeoutValue = UART_DOWNLOAD_TIMEOUT_START_US;
+	printf("READY TO RECEIVE DATA IN BINARY MODE\n");
+
+
+	while (1) {
+		reset_timer();
+		timeStart = get_timer(0);
+
+		while (serial_getchar (loadPointer) == 0) {
+			timerexpire = timer_expired(timeStart, timeoutValue);
+			if(timerexpire == 1) {
+				break;
+			}
+			if(byteCount >= image_length)
+				break;
+		}
+
+		if(timerexpire == 1) {
+			if (timeoutValue == UART_DOWNLOAD_TIMEOUT_END_US) {
+				printf("Download finished\n" );
+			}
+			else {
+				printf("Timeout!!!\n" );
+			}
+			break;
+		}
+
+		timeoutValue = UART_DOWNLOAD_TIMEOUT_END_US;
+
+		loadPointer++;
+		byteCount++;
+		if(byteCount == sizeof(image_header_t)) {
+			image_length += image_get_data_size(hdr);
+		}
+		if (byteCount >= image_length) {
+			break;
+		}
+	}
+
+	printf("%d bytes are transfered\n",byteCount);
+
+	return 0;
+}
+
+#if defined(CONFIG_USB_EHCI_LPC313X) || defined(CONFIG_USB_DEVICE)
+void usb_init_clocks(void)
+{
+
+	/* enable USB to AHB clock */
+	cgu_clk_en_dis(CGU_SB_USB_OTG_AHB_CLK_ID, 1);
+	/* enable clock to Event router */
+	cgu_clk_en_dis(CGU_SB_EVENT_ROUTER_PCLK_ID, 1);
+
+	/* reset USB block */
+	cgu_soft_reset_module(USB_OTG_AHB_RST_N_SOFT);
+
+	if(SYS_REGS->usb_atx_pll_pd_reg != 0) {
+		/* enable USB OTG PLL */
+		SYS_REGS->usb_atx_pll_pd_reg = 0x0;
+		/* wait for PLL to lock */
+		while (!(EVRT_RSR(EVT_usb_pll_bank) & EVT_usb_atx_pll_lock_bit));
+	}
+
+	return;
+}
+#endif
+
+#ifdef CONFIG_EA3152
+void psu_set_voltage(u32 rail, u32 volt)
+{
+	u32 reg_val;
+	int bit_pos;
+
+	/* read PSU register */
+	i2c_read(I2C1_CTRL, AD_SLAVE_ADDR, AD_REG_OTGDCLIC_RW,
+			2, &reg_val,4);
+
+	/* check if this is to set VOUT3 rail */
+	if (ANALOG_1V8_RAIL == rail) {
+		reg_val |= (volt)?_BIT(16):0;
+	} else {
+		/* for 1v2 bitpos is 17 and for 3v3 bit pos 20 */
+		bit_pos = (rail)? 17 : 20;
+
+		if (volt > 0x7)
+			volt = 0x7;
+
+		/* zero the dcdc1 adjust bits */
+		reg_val &= ~(0x7 << bit_pos);
+		/* write the new adjust value */
+		reg_val |= (volt << bit_pos);
+	}
+
+	i2c_write(I2C1_CTRL, AD_SLAVE_ADDR, AD_REG_OTGDCLIC_RW,
+			2, reg_val,4);
+	return;
+}
+
+void setup_sdram_voltage(void)
+{
+	unsigned int reg_val = 0;
+
+	i2c_init(CGU_SB_I2C1_PCLK_ID,I2C1_CTRL);
+
+	/* Set SDRAM voltage rail to 1.8V default is 1.4V */
+	psu_set_voltage(ANALOG_1V8_RAIL, PSU_VOUT3_1_80);
+}
+#endif
+
+static unsigned long load_address;
+
+static void jump_to_image_no_args(void)
+{
+	typedef void (*image_entry_noargs_t)(void)__attribute__ ((noreturn));
+	image_entry_noargs_t image_entry =
+			(image_entry_noargs_t) load_address;
+
+	debug("image entry point: 0x%X\n", load_address);
+	image_entry();
+}
+void jump_to_image_no_args(void) __attribute__ ((noreturn));
+
+void board_init_r(gd_t *id, ulong dummy)
+{
+	long uartid, image_length, os;
+	int rc;
+	ulong bootmode;
+	volatile unsigned char * tmploadPointer =
+		(volatile unsigned char *)(LPC313X_SDRAM_TEMP_DATA_ADDR);
+
+	image_header_t *hdr = (image_header_t *)tmploadPointer;
+
+	gd = id;
+
+	mem_malloc_init (_TEXT_BASE - CONFIG_SYS_MALLOC_LEN,
+			CONFIG_SYS_MALLOC_LEN);
+	/* Initialize Timer0 */
+	timer_init1();
+
+	/* Initialize UART0 */
+	gd->baudrate = CONFIG_BAUDRATE;
+	gd->flags = 0;
+	uartid = serial_init();
+	gd->have_console = 1;
+
+	GPIOMuxSetup();
+
+#if defined(CONFIG_USB_EHCI_LPC313X) || defined(CONFIG_USB_DEVICE)
+	usb_init_clocks();
+#endif
+
+	/* Read Boot mode pins and copy u-boot image from
+	 * selected BOOT device 
+	 */
+	IOCONF->block[IOCONF_GPIO].mode0_clear = LPC313X_BOOTMODE_MASK;
+	IOCONF->block[IOCONF_GPIO].mode1_clear = LPC313X_BOOTMODE_MASK;
+
+	udelay(1000);
+
+	bootmode = IOCONF->block[IOCONF_GPIO].pins;
+	bootmode &= LPC313X_BOOTMODE_MASK;
+
+	bootmode = (((bootmode & 0x1) << 1) | ((bootmode & 0x2) << 1) |
+			((bootmode & 0x4) >> 2));
+
+//	image_length = UBOOT_FILESIZE;
+	image_length = 0;
+
+	switch(bootmode) {
+#ifdef CONFIG_CPU_NAND_BOOT
+	case LPC313X_BOOT_MODE_NAND:
+		printf("BOOTMODE: NAND\n");
+		nand_init();
+		//is_nand_init_done = 1;
+		rc = nand_copy_boot_image(image_length, tmploadPointer);
+		break;
+#endif
+#ifdef CONFIG_CPU_SPI_BOOT
+	case LPC313X_BOOT_MODE_SPI:
+		printf("BOOTMODE: SPI\n");
+		spi_init();
+		//is_spi_init_done = 1;
+		rc = spi_copy_boot_image(image_length, tmploadPointer);
+		break;
+#endif
+#ifdef CONFIG_CPU_USBDFU_BOOT
+	case LPC313X_BOOT_MODE_DFU_USB:
+		printf("BOOTMODE: USB\n");
+		drv_usbtty_init();
+		rc = usb_copy_boot_image(image_length, tmploadPointer);
+		break;
+#endif
+#ifdef CONFIG_CPU_MMC_BOOT
+	case LPC313X_BOOT_MODE_SD_MMC:
+		printf("BOOTMODE: SDMMC\n");
+		mmc_legacy_init(0);
+		rc = sdmmc_copy_boot_image(tmploadPointer);
+		break;
+#endif
+#ifdef CONFIG_CPU_NOR_BOOT
+	case LPC313X_BOOT_MODE_NOR_FLASH:
+		printf("BOOTMODE: NOR\n");
+		rc = flash_copy_boot_image(image_length, tmploadPointer);
+		break;
+#endif
+#ifdef CONFIG_CPU_UART_BOOT
+	case LPC313X_BOOT_MODE_UART:
+		printf("BOOTMODE: UART\n");
+		rc = uart_copy_boot_image(tmploadPointer);
+		break;
+#endif
+	default:
+		break;
+	}
+
+	if(rc == -1) {
+		printf("valid image is not found\n");
+		hang();
+	}
+
+	if (!image_check_magic(hdr)) {
+		puts("Bad Magic Number\n");
+		hang();
+	}
+	if (!image_check_hcrc(hdr)) {
+		puts("Bad Header Checksum\n");
+		hang();
+	}
+	image_print_contents(hdr);
+
+	puts("   Verifying Checksum ... ");
+	if (!image_check_dcrc(hdr)) {
+		printf("Bad Data CRC\n");
+		hang();
+	}
+	puts("OK\n");
+
+	if (!image_check_target_arch(hdr)) {
+		printf("Unsupported Architecture 0x%x\n", image_get_arch(hdr));
+		hang();
+	}
+
+	os = image_get_os(hdr);
+	load_address = image_get_load(hdr);
+
+	memmove(load_address, tmploadPointer + sizeof(image_header_t), image_get_size(hdr));
+
+	switch (os) {
+	case IH_OS_U_BOOT:
+		puts("Jumping to U-Boot\n");
+		jump_to_image_no_args();
+		break;
+	default:
+		printf("Unsupported OS image %d.. Jumping nevertheless..\n", os);
+		jump_to_image_no_args();
+	}
+}
+
+
+int setenv(const char *varname, const char *varvalue)
+{
+	return 0;
+}
+
diff --git a/arch/arm/cpu/arm926ejs/lpc313x/timer.c b/arch/arm/cpu/arm926ejs/lpc313x/timer.c
new file mode 100644
index 0000000..dbd6ebd
--- /dev/null
+++ b/arch/arm/cpu/arm926ejs/lpc313x/timer.c
@@ -0,0 +1,225 @@
+/*
+ * (C) Copyright 2010 NXP Semiconductors
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <asm/arch/hardware.h>
+#include <asm/arch/timer.h>
+#include <asm/arch/clock.h>
+
+static long timer0dev = 0;
+static ulong timestamp;
+static ulong lastinc;
+static ulong timer0_clk_freq;
+
+#define DIV_MS   (1000)
+#define TIMER0_LOAD_VALUE (0xFFFFFFFF)
+
+ulong timer_usec_to_val(u32 clk_id, ulong usec, ulong* pcon)
+{
+	u32 clkdlycnt;
+	u32 freq;
+
+	/*
+	 * Determine the value to exceed before the count
+	 * reaches the desired delay time
+	 */
+	freq = (unsigned long long)cgu_get_clk_freq(clk_id);
+	if ((freq > 1000000) && (pcon != NULL)) {
+		/* if timer freq is greater than 1MHz use pre-dividers */
+		*pcon &= ~TM_CTRL_PS_MASK;
+		if (usec > 100000) {
+			/* use divide by 256 pre-divider for delay greater than 100 msec*/
+			*pcon |= TM_CTRL_PS256;
+			/* divide by 256 */
+			freq = freq >> 8;
+		}
+		else if (usec > 1000) {
+			/* use divide by 16 pre-divider for delay greater than 1 msec*/
+			*pcon |= TM_CTRL_PS16;
+			/* divide by 16 */
+			freq = freq >> 4;
+		}
+	}
+
+	clkdlycnt = ((freq * (u32)usec) / 1000000);
+
+	return (ulong)clkdlycnt;
+}
+
+
+void timer_delay_cmn(TIMER_REGS_T* regptr, ulong usec)
+{
+	ulong control = 0;
+	ulong clkdlycnt;
+
+	timer_init1();
+
+	/* Enable timer system clock */
+	cgu_clk_en_dis(CGU_SB_TIMER1_PCLK_ID, 1);
+
+	/*
+	 * Determine the value to exceed before the count
+	 *reaches the desired delay time
+	 */
+	clkdlycnt = timer_usec_to_val(CGU_SB_TIMER1_PCLK_ID, usec, &control);
+
+	/* Reset timer */
+	regptr->control &= ~TM_CTRL_ENABLE;
+	regptr->load = clkdlycnt;
+
+	/* Enable the timer in free running mode*/
+	regptr->control = control | TM_CTRL_ENABLE;
+
+	/* Loop until terminal count matches or exceeds computed delay count */
+	while (regptr->value <= clkdlycnt);
+
+	/* Disable timer system clock */
+	cgu_clk_en_dis(CGU_SB_TIMER1_PCLK_ID, 0);
+
+	/* Stop timer */
+	regptr->control &= ~TM_CTRL_ENABLE;
+}
+
+int timer_init(void)
+{
+	TIMER_REGS_T *regptr = (TIMER_REGS_T *)TIMER_CNTR0;
+//	if(timer0dev == 0) {
+		/* Enable timer0 system clock */
+		cgu_clk_en_dis(CGU_SB_TIMER0_PCLK_ID, 1);
+
+//		timer0_clk_freq = (ulong) cgu_get_clk_freq(CGU_SB_TIMER0_PCLK_ID);
+
+		regptr->control = TM_CTRL_PS256;
+		regptr->load = TIMER0_LOAD_VALUE;
+
+		/* Enable the timer0 */
+		regptr->control |= TM_CTRL_ENABLE;
+
+		/* Using Predivider */
+//		timer0_clk_freq = timer0_clk_freq >> 8;
+
+		/* Reset Time stamps */
+//		reset_timer_masked();
+
+//		timer0dev = 1;
+//	}
+
+	return 0;
+}
+
+int timer_init1(void)
+{
+	TIMER_REGS_T *regptr = (TIMER_REGS_T *)TIMER_CNTR0;
+	if(timer0dev == 0) {
+		/* Enable timer0 system clock */
+		cgu_clk_en_dis(CGU_SB_TIMER0_PCLK_ID, 1);
+
+		timer0_clk_freq = (ulong) cgu_get_clk_freq(CGU_SB_TIMER0_PCLK_ID);
+
+		regptr->control = TM_CTRL_PS256;
+		regptr->load = TIMER0_LOAD_VALUE;
+
+		/* Enable the timer0 */
+		regptr->control |= TM_CTRL_ENABLE;
+
+		/* Using Predivider */
+		timer0_clk_freq = timer0_clk_freq >> 8;
+
+		/* Reset Time stamps */
+		reset_timer_masked();
+
+		timer0dev = 1;
+	}
+
+	return 0;
+}
+
+void reset_timer_masked(void)
+{
+	/* Capture current decrementer counter value */
+	TIMER_REGS_T *regptr = (TIMER_REGS_T *)TIMER_CNTR0;
+
+	lastinc = ((TIMER0_LOAD_VALUE - regptr->value) / (timer0_clk_freq / DIV_MS));
+	timestamp = 0;		/* start "advancing" time stamp from 0 */
+}
+
+ulong get_timer_masked (void)
+{
+	TIMER_REGS_T *regptr = (TIMER_REGS_T *)TIMER_CNTR0;
+
+	/* Current time in ms */
+	ulong now = (TIMER0_LOAD_VALUE - regptr->value) / (timer0_clk_freq / DIV_MS);
+
+	if (now >= lastinc)	/* normal mode (non roll) */
+		/* move stamp fordward with absoulte diff ticks */
+		timestamp += (now - lastinc);
+	else	/* we have rollover of incrementer */
+		timestamp += ((TIMER0_LOAD_VALUE / (timer0_clk_freq / DIV_MS))
+				- lastinc) + now;
+	lastinc = now;
+
+	return timestamp;
+}
+
+unsigned long get_timer(unsigned long base)
+{
+	return (get_timer_masked() - base) ;
+}
+
+void __udelay(unsigned long usec)
+{
+	timer_delay_cmn(TIMER_CNTR1, usec);
+}
+
+void reset_cpu(ulong ignored)
+{
+	while (1);
+	/* Never reached */
+}
+
+void reset_timer()
+{
+	TIMER_CNTR0->control &= ~TM_CTRL_ENABLE;
+	TIMER_CNTR0->load = TIMER0_LOAD_VALUE;
+	TIMER_CNTR0->control |= TM_CTRL_ENABLE;
+
+	/* Reset Time stamps */
+	reset_timer_masked();
+}
+
+/*
+ * This function is derived from PowerPC code (read timebase as long long).
+ * On ARM it just returns the timer value.
+ */
+unsigned long long get_ticks(void)
+{
+	return get_timer(0);
+}
+
+/*
+ * This function is derived from PowerPC code (timebase clock frequency).
+ * On ARM it returns the number of timer ticks per second.
+ */
+ulong get_tbclk (void)
+{
+	return (ulong)CONFIG_SYS_HZ;
+}
diff --git a/arch/arm/cpu/arm926ejs/lpc313x/u-boot-spl.lds b/arch/arm/cpu/arm926ejs/lpc313x/u-boot-spl.lds
new file mode 100644
index 0000000..85dd87b
--- /dev/null
+++ b/arch/arm/cpu/arm926ejs/lpc313x/u-boot-spl.lds
@@ -0,0 +1,80 @@
+/*
+ * (C) Copyright 2002
+ * Gary Jennejohn, DENX Software Engineering, <garyj@denx.de>
+ *
+ * (C) Copyright 2010
+ * Texas Instruments, <www.ti.com>
+ *	Aneesh V <aneesh@ti.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+MEMORY { .sram : ORIGIN = CONFIG_SPL_TEXT_BASE,\
+		LENGTH = CONFIG_SPL_MAX_SIZE }
+MEMORY { .sdram : ORIGIN = CONFIG_SPL_BSS_START_ADDR, \
+		LENGTH = CONFIG_SPL_BSS_MAX_SIZE }
+
+OUTPUT_FORMAT("elf32-littlearm", "elf32-littlearm", "elf32-littlearm")
+OUTPUT_ARCH(arm)
+ENTRY(_start)
+SECTIONS
+{
+	.text      :
+	{
+	__start = .;
+	  arch/arm/cpu/arm926ejs/start.o	(.text)
+	  *(.text*)
+	} >.sram
+
+	. = ALIGN(4);
+	.rodata : { *(SORT_BY_ALIGNMENT(.rodata*)) } >.sram
+
+	. = ALIGN(4);
+	.data : { 
+		*(SORT_BY_ALIGNMENT(.data*))
+		FILL(0);
+		. = ALIGN(512);
+	 } >.sram
+	. = ALIGN(4);
+	__image_copy_end = .;
+	_end = .;
+
+	. = ALIGN(4);
+
+	.rel.dyn : {
+		__rel_dyn_start = .;
+		*(.rel*)
+		__rel_dyn_end = .;
+	} >.sram
+
+	.dynsym : {
+		__dynsym_start = .;
+		*(.dynsym)
+	} >.sram
+
+	_end = .;
+        __initial_boot_image_size    = (((__image_copy_end - __start) + 511) & ~ 511);
+
+	.bss __rel_dyn_start (OVERLAY) : {
+		__bss_start = .;
+		*(.bss)
+		 . = ALIGN(4);
+		__bss_end__ = .;
+	} >.sdram
+}
diff --git a/arch/arm/cpu/arm926ejs/lpc313x/usbdfu.c b/arch/arm/cpu/arm926ejs/lpc313x/usbdfu.c
new file mode 100644
index 0000000..1c16008
--- /dev/null
+++ b/arch/arm/cpu/arm926ejs/lpc313x/usbdfu.c
@@ -0,0 +1,30 @@
+/*
+ * (C) Copyright 2010 NXP Semiconductors
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <config.h>
+
+#ifdef CONFIG_USB_DFU
+ulong dfu_load_addr = 0x32000000;
+
+#endif
+
diff --git a/arch/arm/cpu/arm926ejs/lpc313x/usbpoll.c b/arch/arm/cpu/arm926ejs/lpc313x/usbpoll.c
new file mode 100644
index 0000000..5678079
--- /dev/null
+++ b/arch/arm/cpu/arm926ejs/lpc313x/usbpoll.c
@@ -0,0 +1,68 @@
+/*
+ * (C) Copyright 2010 NXP Semiconductors
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <config.h>
+
+#ifdef CONFIG_USB_DFU
+extern ulong dfu_load_addr; 
+extern unsigned char stop_polling;
+extern unsigned char xfer_error;
+
+int do_usbpoll (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
+{
+	u32 i = 500;
+	int ret = 0;
+
+	if(argc < 2)
+		goto usage;
+	stop_polling = 0;
+	xfer_error = 0;
+
+	dfu_load_addr = (ulong)simple_strtoul(argv[1], NULL, 16);
+
+	while(!stop_polling && (!xfer_error)) {
+		usbtty_poll();
+	}
+	/* do usbtty_poll() for the DFU Class status request to complete */
+	while(i && (!xfer_error)) {
+		usbtty_poll();
+		i--;
+	}
+	return 0;
+usage:
+	cmd_usage(cmdtp);
+	return 0;
+}
+#else
+int do_usbpoll (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
+{
+	return 0;
+}
+#endif
+
+U_BOOT_CMD(
+		usbpoll, 2, 1, do_usbpoll,
+		"Poll USB bus Transfering data using DFU Protocol",
+		"usbpoll addr\n"
+		""
+	  );
diff --git a/arch/arm/cpu/arm926ejs/lpc313x/usbpoll.c~patched b/arch/arm/cpu/arm926ejs/lpc313x/usbpoll.c~patched
new file mode 100644
index 0000000..7ea8edf
--- /dev/null
+++ b/arch/arm/cpu/arm926ejs/lpc313x/usbpoll.c~patched
@@ -0,0 +1,68 @@
+/*
+ * (C) Copyright 2010 NXP Semiconductors
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <config.h>
+
+#ifdef CONFIG_USB_DFU
+ulong dfu_load_addr = 0x32000000;
+extern unsigned char stop_polling;
+extern unsigned char xfer_error;
+
+int do_usbpoll (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
+{
+	u32 i = 500;
+	int ret = 0;
+
+	if(argc < 2)
+		goto usage;
+	stop_polling = 0;
+	xfer_error = 0;
+
+	dfu_load_addr = (ulong)simple_strtoul(argv[1], NULL, 16);
+
+	while(!stop_polling && (!xfer_error)) {
+		usbtty_poll();
+	}
+	/* do usbtty_poll() for the DFU Class status request to complete */
+	while(i && (!xfer_error)) {
+		usbtty_poll();
+		i--;
+	}
+	return 0;
+usage:
+	cmd_usage(cmdtp);
+	return 0;
+}
+#else
+int do_usbpoll (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
+{
+	return 0;
+}
+#endif
+
+U_BOOT_CMD(
+		usbpoll, 2, 1, do_usbpoll,
+		"Poll USB bus Transfering data using DFU Protocol",
+		"usbpoll addr\n"
+		""
+	  );
diff --git a/arch/arm/cpu/arm926ejs/start.S b/arch/arm/cpu/arm926ejs/start.S
index 6a09c02..b658b12 100644
--- a/arch/arm/cpu/arm926ejs/start.S
+++ b/arch/arm/cpu/arm926ejs/start.S
@@ -64,6 +64,13 @@ _start:
 	b	reset
 #endif
 #ifdef CONFIG_SPL_BUILD
+#ifdef CONFIG_LPC313x_BOOT_HEADER
+        .word 0x41676d69        /* image magic number, imgA */
+        .word 0,0,0,0,0
+        .word 0x0000000A        /*Plain text no CRC check*/
+	.word (__initial_boot_image_size)       /* image length */
+        .word 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
+#else
 /* No exception handlers in preloader */
 	ldr	pc, _hang
 	ldr	pc, _hang
@@ -83,6 +90,7 @@ _hang:
 	.word	0x12345678
 	.word	0x12345678
 	.word	0x12345678
+#endif
 #else
 	ldr	pc, _undefined_instruction
 	ldr	pc, _software_interrupt
@@ -230,6 +238,7 @@ relocate_code:
 stack_setup:
 	mov	sp, r4
 
+	mov	r9, #0x00000000		/* relocation offset starts at zero */
 	adr	r0, _start
 	sub	r9, r6, r0		/* r9 <- relocation offset */
 	cmp	r0, r6
@@ -292,7 +301,9 @@ clear_bss:
 	ldr	r1, =__bss_end__
 #else
 	ldr	r0, _bss_start_ofs
+//	add	r0, r0, r9
 	ldr	r1, _bss_end_ofs
+//	add	r1, r1, r9
 	mov	r4, r6			/* reloc addr */
 	add	r0, r0, r4
 	add	r1, r1, r4
diff --git a/arch/arm/include/asm/arch-lpc313x/clock.h b/arch/arm/include/asm/arch-lpc313x/clock.h
new file mode 100644
index 0000000..f4fc614
--- /dev/null
+++ b/arch/arm/include/asm/arch-lpc313x/clock.h
@@ -0,0 +1,469 @@
+/*
+ * (C) Copyright 2010 NXP Semiconductors
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef CLOCK_H
+#define CLOCK_H
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+#include "clock_main.h"
+#include "clock_switchbox.h"
+
+#define CGU_DEF_DIV_BY_0	0x00000000
+#define CGU_DEF_DIV_BY_2	0x00040404
+#define CGU_DEF_DIV_BY_3	0x00060404
+#define CGU_DEF_DIV_BY_4	0x00060604
+#define CGU_DEF_DIV_BY_6	0x00070604
+#define CGU_DEF_DIV_BY_32	0x0007c7c4
+#define CGU_DEF_DIV_BY_38	0x0007e4a4
+#define CGU_DEF_DIV_BY_40	0x0007e4e4
+#define CGU_DEF_DIV_BY_256	0x1fe0ff04
+
+/* Define dividers for domains which have HPLL1 as 
+ * their base frequency. These dividers will be 
+ * different for PLL_180 and PLL_270 configurations.
+ */
+#ifdef CONFIG_PLL_270
+#define PLL_FREQUENCY           270000000
+/*(NS_TO_MPMCCLK(7812, PLLCLK)/16) | _BIT(12) = (270 * 7.812)/16 | _BIT(12)*/
+#define SYSREG_TEST0_VAL	0x182
+/* (10 + NS_TO_MPMCCLK(20, HCLK) + NS_TO_MPMCCLK(66, HCLK)) * (PLLCLK/HCLK)
+ * = (10 + (20 * 90/1000) +  (66 * 90/1000)) * 3)
+ * = (10 + 1.8 + 5.94) * 3
+ * = 54
+ */
+#define SYSREG_TEST1_VAL	0x36
+
+#define CGU_DEF_FDIV0_VAL	CGU_DEF_DIV_BY_3
+#define CGU_DEF_FDIV1_VAL	CGU_DEF_DIV_BY_0
+#define CGU_DEF_FDIV2_VAL	CGU_DEF_DIV_BY_3
+#define CGU_DEF_FDIV3_VAL	CGU_DEF_DIV_BY_6
+#define CGU_DEF_FDIV4_VAL	CGU_DEF_DIV_BY_6
+#define CGU_DEF_FDIV5_VAL	CGU_DEF_DIV_BY_3
+#define CGU_DEF_FDIV6_VAL	CGU_DEF_DIV_BY_3
+
+#define CGU_DEF_FDIV11_VAL	CGU_DEF_DIV_BY_3
+#define CGU_DEF_FDIV12_VAL	CGU_DEF_DIV_BY_40
+#define CGU_DEF_FDIV13_VAL	CGU_DEF_DIV_BY_0
+
+#define CGU_DEF_FDIV15_VAL	CGU_DEF_DIV_BY_3
+
+#define CGU_DEF_FDIV23_VAL	CGU_DEF_DIV_BY_3
+
+#else
+
+#define PLL_FREQUENCY           180000000
+/*(NS_TO_MPMCCLK(7812, PLLCLK)/16) | _BIT(12) = (180 * 7.812)/16 | _BIT(12)*/
+#define SYSREG_TEST0_VAL	0x158
+/* (10 + NS_TO_MPMCCLK(20, HCLK) + NS_TO_MPMCCLK(66, HCLK)) * (PLLCLK/HCLK)
+ * = (10 + (20 * 90/1000) +  (66 * 90/1000)) * 2)
+ * = (10 + 1.8 + 5.94) * 2
+ * = 36
+ */
+#define SYSREG_TEST1_VAL	0x24
+
+#define CGU_DEF_FDIV0_VAL	CGU_DEF_DIV_BY_2
+#define CGU_DEF_FDIV1_VAL	CGU_DEF_DIV_BY_0
+#define CGU_DEF_FDIV2_VAL	CGU_DEF_DIV_BY_2
+#define CGU_DEF_FDIV3_VAL	CGU_DEF_DIV_BY_4
+#define CGU_DEF_FDIV4_VAL	CGU_DEF_DIV_BY_4
+#define CGU_DEF_FDIV5_VAL	CGU_DEF_DIV_BY_2
+#define CGU_DEF_FDIV6_VAL	CGU_DEF_DIV_BY_2
+
+#define CGU_DEF_FDIV11_VAL	CGU_DEF_DIV_BY_2
+#define CGU_DEF_FDIV12_VAL	CGU_DEF_DIV_BY_40
+#define CGU_DEF_FDIV13_VAL	CGU_DEF_DIV_BY_0
+
+#define CGU_DEF_FDIV15_VAL	CGU_DEF_DIV_BY_2
+
+#define CGU_DEF_FDIV23_VAL	CGU_DEF_DIV_BY_2
+
+#endif
+/* Define dividers for domains which don't have 
+ * HPLL1 as their base frequency. These dividers
+ * will be same in bot PLL_180 and PLL_270 configurations.
+ */
+#define CGU_DEF_FDIV7_VAL	CGU_DEF_DIV_BY_38
+#define CGU_DEF_FDIV8_VAL	CGU_DEF_DIV_BY_2
+#define CGU_DEF_FDIV9_VAL	CGU_DEF_DIV_BY_2
+#define CGU_DEF_FDIV10_VAL	CGU_DEF_DIV_BY_2
+#define CGU_DEF_FDIV14_VAL	CGU_DEF_DIV_BY_2
+#define CGU_DEF_FDIV16_VAL	CGU_DEF_DIV_BY_0
+#define CGU_DEF_FDIV17_VAL	CGU_DEF_DIV_BY_256
+#define CGU_DEF_FDIV18_VAL	CGU_DEF_DIV_BY_4
+#define CGU_DEF_FDIV19_VAL	CGU_DEF_DIV_BY_0
+#define CGU_DEF_FDIV20_VAL	CGU_DEF_DIV_BY_4
+#define CGU_DEF_FDIV21_VAL	CGU_DEF_DIV_BY_32
+#define CGU_DEF_FDIV22_VAL	CGU_DEF_DIV_BY_2
+
+/* dynamic dividers */
+#define CGU_DEF_DYNFDIV0_VAL    CGU_DEF_DIV_BY_256
+#define CGU_DEF_DYNFDIV1_VAL    CGU_DEF_DIV_BY_0
+#define CGU_DEF_DYNFDIV2_VAL    CGU_DEF_DIV_BY_0
+#define CGU_DEF_DYNFDIV3_VAL    CGU_DEF_DIV_BY_0
+#define CGU_DEF_DYNFDIV4_VAL    CGU_DEF_DIV_BY_0
+#define CGU_DEF_DYNFDIV5_VAL    CGU_DEF_DIV_BY_0
+#define CGU_DEF_DYNFDIV6_VAL    CGU_DEF_DIV_BY_0
+/* dynamic divs configurations. All events. */
+#define CGU_DEF_DYNFDIV0_CFG    0x0
+#define CGU_DEF_DYNFDIV1_CFG    0x0
+#define CGU_DEF_DYNFDIV2_CFG    0x0
+#define CGU_DEF_DYNFDIV3_CFG    0x0
+#define CGU_DEF_DYNFDIV4_CFG    0x0
+#define CGU_DEF_DYNFDIV5_CFG    0x0
+#define CGU_DEF_DYNFDIV6_CFG    0x0
+
+
+#define CGU_INVALID_ID		0xFFFF
+
+/* Following clocks are enabled after init.
+CGU_DEF_CLKS_0_31 contains bits for clocks with id between 0 & 31
+CGU_DEF_CLKS_32_63 contains bits for clocks with id between 32 & 63
+CGU_DEF_CLKS_64_92 contains bits for clocks with id between 64 & 92
+*/
+#define CGU_DEF_CLKS_0_31	(_BIT(CGU_SB_APB0_CLK_ID) | _BIT(CGU_SB_APB1_CLK_ID) | \
+				_BIT(CGU_SB_APB2_CLK_ID) | _BIT(CGU_SB_APB3_CLK_ID) |_BIT(CGU_SB_APB4_CLK_ID) | \
+				_BIT(CGU_SB_AHB2INTC_CLK_ID) | _BIT(CGU_SB_AHB0_CLK_ID) | \
+				_BIT(CGU_SB_ARM926_CORE_CLK_ID) | _BIT(CGU_SB_ARM926_BUSIF_CLK_ID) | \
+				_BIT(CGU_SB_ARM926_RETIME_CLK_ID) | _BIT(CGU_SB_ISRAM0_CLK_ID) | \
+				_BIT(CGU_SB_ISRAM1_CLK_ID) | _BIT(CGU_SB_ISROM_CLK_ID) | \
+				_BIT(CGU_SB_INTC_CLK_ID) | _BIT(CGU_SB_AHB2APB0_ASYNC_PCLK_ID) | \
+				_BIT(CGU_SB_MPMC_CFG_CLK_ID) | _BIT(CGU_SB_MPMC_CFG_CLK2_ID) | _BIT(CGU_SB_MPMC_CFG_CLK3_ID) | \
+				_BIT(CGU_SB_EBI_CLK_ID) | \
+				_BIT(CGU_SB_EVENT_ROUTER_PCLK_ID) | _BIT(CGU_SB_CLOCK_OUT_ID))
+
+#define CGU_DEF_CLKS_32_63	(_BIT(CGU_SB_IOCONF_PCLK_ID - 32) | _BIT(CGU_SB_CGU_PCLK_ID - 32) | \
+				_BIT(CGU_SB_SYSCREG_PCLK_ID - 32) | _BIT(CGU_SB_OTP_PCLK_ID - 32) | \
+				_BIT(CGU_SB_TIMER0_PCLK_ID -32) | \
+				_BIT(CGU_SB_AHB2APB1_ASYNC_PCLK_ID - 32) | _BIT(CGU_SB_AHB2APB2_ASYNC_PCLK_ID - 32) | \
+				_BIT(CGU_SB_AHB2APB3_ASYNC_PCLK_ID - 32) | _BIT(CGU_SB_EDGE_DET_PCLK_ID- 32))
+
+#define CGU_DEF_CLKS_64_92	(0)
+
+/*
+ * Following macros are used to define clocks
+ * belonging to different sub-domains
+ * with-in each domain.
+ */
+#define D0_BIT(clkid)	(1 << (clkid))
+#define D1_BIT(clkid)	(1 << ((clkid) - CGU_AHB0APB0_FIRST))
+#define D2_BIT(clkid)	(1 << ((clkid) - CGU_AHB0APB1_FIRST))
+#define D3_BIT(clkid)	(1 << ((clkid) - CGU_AHB0APB2_FIRST))
+#define D4_BIT(clkid)	(1 << ((clkid) - CGU_AHB0APB3_FIRST))
+#define D5_BIT(clkid)	(1 << ((clkid) - CGU_PCM_FIRST))
+#define D6_BIT(clkid)	(1 << ((clkid) - CGU_UART_FIRST))
+#define D7_BIT(clkid)	(1 << ((clkid) - CGU_CLK1024FS_FIRST))
+/* 8 & 9 have one clk per domain so no macros */
+#define D10_BIT(clkid)	(1 << ((clkid) - CGU_SPI_FIRST))
+
+
+/*
+ * Group the clocks 0 - 29 belonging to SYS_BASE domain into 7 different sub-domains using
+ * following macro. Clocks not defined in the macros will be sourced with SYS_BASE_CLK.
+ */
+/* define clocks belonging to subdomain DOMAIN0_DIV0 */
+#define CGU_DEF_DOMAIN0_DIV0	(D0_BIT(CGU_SB_APB0_CLK_ID) | D0_BIT(CGU_SB_APB1_CLK_ID) | \
+				D0_BIT(CGU_SB_APB2_CLK_ID) | D0_BIT(CGU_SB_APB3_CLK_ID) | \
+				D0_BIT(CGU_SB_APB4_CLK_ID) | D0_BIT(CGU_SB_AHB2INTC_CLK_ID) | \
+				D0_BIT(CGU_SB_AHB0_CLK_ID) | D0_BIT(CGU_SB_DMA_PCLK_ID) | \
+				D0_BIT(CGU_SB_DMA_CLK_GATED_ID) | D0_BIT(CGU_SB_NANDFLASH_S0_CLK_ID) | \
+				D0_BIT(CGU_SB_NANDFLASH_PCLK_ID) | D0_BIT(CGU_SB_ARM926_BUSIF_CLK_ID) | \
+				D0_BIT(CGU_SB_SD_MMC_HCLK_ID) | D0_BIT(CGU_SB_USB_OTG_AHB_CLK_ID) | \
+				D0_BIT(CGU_SB_ISRAM0_CLK_ID) | D0_BIT(CGU_SB_ISRAM1_CLK_ID) | \
+				D0_BIT(CGU_SB_ISROM_CLK_ID) | D0_BIT(CGU_SB_MPMC_CFG_CLK_ID) | \
+				D0_BIT(CGU_SB_MPMC_CFG_CLK2_ID) | D0_BIT(CGU_SB_INTC_CLK_ID))
+
+/* define clocks belonging to subdomain DOMAIN0_DIV1 */
+#define CGU_DEF_DOMAIN0_DIV1	(D0_BIT(CGU_SB_ARM926_CORE_CLK_ID))
+
+/* define clocks belonging to subdomain DOMAIN0_DIV2 */
+#define CGU_DEF_DOMAIN0_DIV2	(D0_BIT(CGU_SB_NANDFLASH_AES_CLK_ID) | \
+				D0_BIT(CGU_SB_NANDFLASH_NAND_CLK_ID))
+
+/* define clocks belonging to subdomain DOMAIN0_DIV3 */
+#define CGU_DEF_DOMAIN0_DIV3	(D0_BIT(CGU_SB_NANDFLASH_ECC_CLK_ID))
+
+/* define clocks belonging to subdomain DOMAIN0_DIV4 */
+#define CGU_DEF_DOMAIN0_DIV4	(D0_BIT(CGU_SB_SD_MMC_CCLK_IN_ID))
+/* define clocks belonging to subdomain DOMAIN0_DIV5 */
+#define CGU_DEF_DOMAIN0_DIV5	(D0_BIT(CGU_SB_CLOCK_OUT_ID))
+/* define clocks belonging to subdomain DOMAIN0_DIV6 */
+#define CGU_DEF_DOMAIN0_DIV6	(D0_BIT(CGU_SB_EBI_CLK_ID))
+
+/*
+ * Group the clocks 30 - 39 belonging to AHB_APB0_BASE domain into 2 different sub-domains using
+ * following macro. Clocks not defined in the macros will be sourced with AHB_APB0_BASE_CLK.
+ */
+/* define clocks belonging to subdomain DOMAIN1_DIV7 */
+#define CGU_DEF_DOMAIN1_DIV7	(D1_BIT(CGU_SB_ADC_CLK_ID))
+/* define clocks belonging to subdomain DOMAIN1_DIV8 */
+#define CGU_DEF_DOMAIN1_DIV8	(D1_BIT(CGU_SB_AHB2APB0_ASYNC_PCLK_ID) | \
+				D1_BIT(CGU_SB_EVENT_ROUTER_PCLK_ID) | D1_BIT(CGU_SB_ADC_PCLK_ID) | \
+				D1_BIT(CGU_SB_WDOG_PCLK_ID) | D1_BIT(CGU_SB_IOCONF_PCLK_ID) | \
+				D1_BIT(CGU_SB_CGU_PCLK_ID) | D1_BIT(CGU_SB_SYSCREG_PCLK_ID) | \
+				D1_BIT(CGU_SB_OTP_PCLK_ID) | D1_BIT(CGU_SB_RNG_PCLK_ID))
+
+/*
+ * Group the clocks 40 - 49 belonging to AHB_APB1_BASE domain into 2 different sub-domains using
+ * following macro. Clocks not defined in the macros will be sourced with AHB_APB1_BASE_CLK.
+ */
+/* define clocks belonging to subdomain DOMAIN2_DIV9 */
+#define CGU_DEF_DOMAIN2_DIV9	(D2_BIT(CGU_SB_AHB2APB1_ASYNC_PCLK_ID) | \
+				D2_BIT(CGU_SB_TIMER0_PCLK_ID) | D2_BIT(CGU_SB_TIMER1_PCLK_ID) | \
+				D2_BIT(CGU_SB_TIMER2_PCLK_ID) | D2_BIT(CGU_SB_TIMER3_PCLK_ID) | \
+				D2_BIT(CGU_SB_PWM_PCLK_ID) | D2_BIT(CGU_SB_PWM_PCLK_REGS_ID) | \
+				D2_BIT(CGU_SB_I2C0_PCLK_ID) | D2_BIT(CGU_SB_I2C1_PCLK_ID))
+
+/* define clocks belonging to subdomain DOMAIN2_DIV10 */
+#define CGU_DEF_DOMAIN2_DIV10	(D2_BIT(CGU_SB_PWM_CLK_ID))
+
+/*
+ * Group the clocks 50 - 57 belonging to AHB_APB2_BASE domain into 3 different sub-domains using
+ * following macro. Clocks not defined in the macros will be sourced with AHB_APB2_BASE_CLK.
+ */
+/* define clocks belonging to subdomain DOMAIN3_DIV11 */
+#define CGU_DEF_DOMAIN3_DIV11	(D3_BIT(CGU_SB_AHB2APB2_ASYNC_PCLK_ID) | \
+				D3_BIT(CGU_SB_PCM_PCLK_ID) | D3_BIT(CGU_SB_PCM_APB_PCLK_ID) | \
+				D3_BIT(CGU_SB_UART_APB_CLK_ID) | D3_BIT(CGU_SB_LCD_PCLK_ID) | \
+				D3_BIT(CGU_SB_SPI_PCLK_ID) | D3_BIT(CGU_SB_SPI_PCLK_GATED_ID))
+
+/* define clocks belonging to subdomain DOMAIN3_DIV12 */
+#define CGU_DEF_DOMAIN3_DIV12	(D3_BIT(CGU_SB_LCD_CLK_ID))
+/* Currently no clocks are connected to this subdomain */
+#define CGU_DEF_DOMAIN3_DIV13	(0)
+
+/*
+ * Group the clocks 58 - 70 belonging to AHB_APB3_BASE domain into a sub-domains using
+ * following macro. Clocks not defined in the macros will be sourced wih AHB_APB3_BASE_CLK.
+ */
+#define CGU_DEF_DOMAIN4_DIV14	(D4_BIT(CGU_SB_AHB2APB3_ASYNC_PCLK_ID) | \
+				D4_BIT(CGU_SB_I2S_CFG_PCLK_ID) | D4_BIT(CGU_SB_EDGE_DET_PCLK_ID) | \
+				D4_BIT(CGU_SB_I2STX_FIFO_0_PCLK_ID) | D4_BIT(CGU_SB_I2STX_IF_0_PCLK_ID) | \
+				D4_BIT(CGU_SB_I2STX_FIFO_1_PCLK_ID) | D4_BIT(CGU_SB_I2STX_IF_1_PCLK_ID) | \
+				D4_BIT(CGU_SB_I2SRX_FIFO_0_PCLK_ID) | D4_BIT(CGU_SB_I2SRX_IF_0_PCLK_ID) | \
+				D4_BIT(CGU_SB_I2SRX_FIFO_1_PCLK_ID) | D4_BIT(CGU_SB_I2SRX_IF_1_PCLK_ID))
+
+/*
+ * Define whether CGU_SB_PCM_CLK_IP_ID clock uses the FDC_15 fractional divider or not. If
+ * the following macro is set 0 then CGU_SB_PCM_CLK_IP_ID clock is sourced with PCM_BASE_CLK.
+ */
+#define CGU_DEF_DOMAIN5_DIV15	(D5_BIT(CGU_SB_PCM_CLK_IP_ID))
+
+/*
+ * Define whether CGU_SB_UART_U_CLK_ID clock uses the FDC_16 fractional divider or not. If
+ * the following macro is set 0 then CGU_SB_UART_U_CLK_ID clock is sourced with UART_BASE_CLK.
+ */
+#define CGU_DEF_DOMAIN6_DIV16	(0)
+
+/*
+ *Group the clocks 73 - 86 belonging to CLK1024FS_BASE domain into 6 different sub-domains using
+ *following macro. Clocks not defined in the macros will be sourced with CLK1024FS_BASE_CLK.
+ */
+/* define clocks belonging to subdomain DOMAIN7_DIV17. This divider has 13 bit resolution
+ *  *    for madd & msub values compared to other dividers which have 8 bit only.*/
+#define CGU_DEF_DOMAIN7_DIV17	(D7_BIT(CGU_SB_I2S_EDGE_DETECT_CLK_ID) | \
+				D7_BIT(CGU_SB_I2STX_WS0_ID) | D7_BIT(CGU_SB_I2STX_WS1_ID) | \
+				D7_BIT(CGU_SB_I2SRX_WS0_ID) | D7_BIT(CGU_SB_I2SRX_WS1_ID))
+
+/* define clocks belonging to subdomain DOMAIN7_DIV18 */
+#define CGU_DEF_DOMAIN7_DIV18	(D7_BIT(CGU_SB_I2STX_BCK0_N_ID) | \
+				D7_BIT(CGU_SB_I2STX_BCK1_N_ID))
+
+/* define clocks belonging to subdomain DOMAIN7_DIV19 */
+#define CGU_DEF_DOMAIN7_DIV19	(D7_BIT(CGU_SB_I2STX_CLK0_ID) | \
+				D7_BIT(CGU_SB_CLK_256FS_ID))
+
+/* define clocks belonging to subdomain DOMAIN7_DIV20 */
+#define CGU_DEF_DOMAIN7_DIV20	(D7_BIT(CGU_SB_I2SRX_BCK0_N_ID) | \
+				D7_BIT(CGU_SB_I2SRX_BCK1_N_ID))
+
+/* define clocks belonging to subdomain DOMAIN7_DIV21 */
+#define CGU_DEF_DOMAIN7_DIV21	(0)
+/* define clocks belonging to subdomain DOMAIN7_DIV22 */
+#define CGU_DEF_DOMAIN7_DIV22	(0)
+
+/* I2SRX_BCK0_BASE and I2SRX_BCK1_BASE domains are directly connected. So, no entry exists here */
+
+/*
+ * Group the clocks 89 - 90 belonging to SPI_CLK_BASE domain into a sub-domain using
+ * following macro. Clocks not defined in the macros will be sourced wih SPI_CLK_BASE_CLK.
+ */
+#define CGU_DEF_DOMAIN10_DIV23	(D10_BIT(CGU_SB_SPI_CLK_ID) | \
+				D10_BIT(CGU_SB_SPI_CLK_GATED_ID))
+
+#ifndef __ASSEMBLY__
+/* CGU soft reset module ID enumerations */
+typedef enum
+{
+	APB0_RST_SOFT,
+	AHB2APB0_PNRES_SOFT,
+	APB1_RST_SOFT,
+	AHB2APB1_PNRES_SOFT,
+	APB2_RESETN_SOFT,
+	AHB2APB2_PNRES_SOFT,
+	APB3_RESETN_SOFT,
+	AHB2APB3_PNRES_SOFT,
+	APB4_RESETN_SOFT,
+	AHB2INTC_RESETN_SOFT,
+	AHB0_RESETN_SOFT,
+	EBI_RESETN_SOFT,
+	PCM_PNRES_SOFT,
+	PCM_RESET_N_SOFT,
+	PCM_RESET_ASYNC_N_SOFT,
+	TIMER0_PNRES_SOFT,
+	TIMER1_PNRES_SOFT,
+	TIMER2_PNRES_SOFT,
+	TIMER3_PNRES_SOFT,
+	ADC_PRESETN_SOFT,
+	ADC_RESETN_ADC10BITS_SOFT,
+	PWM_RESET_AN_SOFT,
+	UART_SYS_RST_AN_SOFT,
+	I2C0_PNRES_SOFT,
+	I2C1_PNRES_SOFT,
+	I2S_CFG_RST_N_SOFT,
+	I2S_NSOF_RST_N_SOFT,
+	EDGE_DET_RST_N_SOFT,
+	I2STX_FIFO_0_RST_N_SOFT,
+	I2STX_IF_0_RST_N_SOFT,
+	I2STX_FIFO_1_RST_N_SOFT,
+	I2STX_IF_1_RST_N_SOFT,
+	I2SRX_FIFO_0_RST_N_SOFT,
+	I2SRX_IF_0_RST_N_SOFT,
+	I2SRX_FIFO_1_RST_N_SOFT,
+	I2SRX_IF_1_RST_N_SOFT,
+
+	LCD_INTERFACE_PNRES_SOFT = I2SRX_IF_1_RST_N_SOFT + 6,
+	SPI_PNRES_APB_SOFT,
+	SPI_PNRES_IP_SOFT,
+	DMA_PNRES_SOFT,
+	NANDFLASH_ECC_RESET_N_SOFT,
+	NANDFLASH_AES_RESET_N_SOFT,
+	NANDFLASH_NAND_RESET_N_SOFT,
+	RNG_RESETN_SOFT,
+	SD_MMC_PNRES_SOFT,
+	SD_MMC_NRES_CCLK_IN_SOFT,
+	USB_OTG_AHB_RST_N_SOFT,
+	RED_CTL_RESET_N_SOFT,
+	AHB_MPMC_HRESETN_SOFT,
+	AHB_MPMC_REFRESH_RESETN_SOFT,
+	INTC_RESETN_SOFT
+} CGU_MOD_ID_T;
+
+typedef struct
+{
+	ulong fin_select;
+	ulong ndec;
+	ulong mdec;
+	ulong pdec;
+	ulong selr;
+	ulong seli;
+	ulong selp;
+	ulong mode;
+	ulong freq;
+} CGU_HPLL_SETUP_T;
+
+typedef struct
+{
+	u32 id;
+	ulong fin_sel;
+	ulong clk_min;
+	ulong clk_cnt;
+	ulong fdiv_min;
+	ulong fdiv_cnt;
+} CGU_DOMAIN_CFG_T;
+
+
+/* Reset all clocks to be sourced from FFAST. */
+void cgu_reset_all_clks(void);
+
+/* Initialize all clocks at startup using the defaults structure */
+long cgu_init_clks(u32 fidv_val[], u32 fdiv_clks[]);
+
+/* Change the base frequency for the requested domain */
+void cgu_set_base_freq(u32 baseid, ulong fin_sel);
+
+/* Return the current frequecy of the requested clock*/
+ulong cgu_get_clk_freq(u32 clkid);
+
+/* Configure the selected HPLL */
+void cgu_hpll_config(u32 pllid, CGU_HPLL_SETUP_T *pllinfo);
+
+/* Get selected HPLL ulong */
+ulong cgu_hpll_status (u32 id);
+
+/* Issue a software reset to the requested module */
+void cgu_soft_reset_module(CGU_MOD_ID_T mod);
+
+/* enable / disable external enabling of the requested clock in CGU */
+void cgu_clk_set_exten(u32 clkid, ulong enable);
+
+static __inline ulong cgu_get_watchdog_bark(void)
+{
+	return ((CGU_CFG->wd_bark & CGU_WD_BARK) == CGU_WD_BARK);
+}
+
+static __inline ulong cgu_get_ffast_on(void)
+{
+	return ((CGU_CFG->ffast_on & CGU_FFAST_ON) == CGU_FFAST_ON);
+}
+
+static __inline void cgu_set_ffast_on(ulong enable)
+{
+	if (enable) {
+		CGU_CFG->ffast_on = CGU_FFAST_ON;
+	}
+	else {
+		CGU_CFG->ffast_on = 0;
+	}
+}
+
+static __inline void cgu_set_ffast_bypass(ulong enable)
+{
+	if (enable) {
+		CGU_CFG->ffast_bypass = CGU_FFAST_BYPASS;
+	}
+	else {
+		CGU_CFG->ffast_bypass = 0;
+	}
+}
+
+/* enable / disable the requested clock in CGU */
+static __inline void cgu_clk_en_dis(u32 clkid, ulong enable)
+{
+	if (enable) {
+		CGU_SB->clk_pcr[clkid] |= CGU_SB_PCR_RUN;
+	}
+	else {
+		CGU_SB->clk_pcr[clkid] &= ~CGU_SB_PCR_RUN;
+	}
+
+}
+
+#endif /*__ASSEMBLY__*/
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* CLOCK_H */
diff --git a/arch/arm/include/asm/arch-lpc313x/clock_main.h b/arch/arm/include/asm/arch-lpc313x/clock_main.h
new file mode 100644
index 0000000..c5fa8a5
--- /dev/null
+++ b/arch/arm/include/asm/arch-lpc313x/clock_main.h
@@ -0,0 +1,188 @@
+/*
+ * (C) Copyright 2010 NXP Semiconductors
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef CLOCK_MAIN_H
+#define CLOCK_MAIN_H
+
+#include <common.h>
+#include <asm/arch/hardware.h>
+
+#ifdef __cplusplus
+extern "C"	/* Assume C declarations for C++ */
+{
+#endif
+
+#ifndef	__ASSEMBLY__
+/* ----------------
+* HP PLL Registers
+* ----------------
+*/
+typedef volatile struct
+{
+	volatile ulong fin_select;
+	volatile ulong mdec;
+	volatile ulong ndec;
+	volatile ulong pdec;
+	volatile ulong mode;
+	volatile ulong status;
+	volatile ulong ack;
+	volatile ulong req;
+	volatile ulong inselr;
+	volatile ulong inseli;
+	volatile ulong inselp;
+	volatile ulong selr;
+	volatile ulong seli;
+	volatile ulong selp;
+} CGU_HP_CFG_REGS;
+
+
+typedef volatile struct
+{
+	volatile ulong powermode;
+	volatile ulong wd_bark;
+	volatile ulong ffast_on;
+	volatile ulong ffast_bypass;
+	volatile ulong apb0_resetn_soft[56];
+	CGU_HP_CFG_REGS hp[2];
+} CGU_CONFIG_REGS;
+
+/* Macro pointing to CGU configuration registers */
+#define CGU_CFG	((CGU_CONFIG_REGS *)(CGU_BASE))
+
+#endif /*__ASSEMBLY__*/
+
+/**********************************************************************
+* Register description of POWERMODE
+**********************************************************************/
+#define CGU_POWERMODE_MASK	0x3
+#define CGU_POWERMODE_NORMAL	0x1
+#define CGU_POWERMODE_WAKEUP	0x3
+
+/**********************************************************************
+* Register description of WD_BARK
+**********************************************************************/
+#define CGU_WD_BARK		0x1
+
+/**********************************************************************
+* Register description of FFAST_ON
+**********************************************************************/
+#define CGU_FFAST_ON		0x1
+
+/**********************************************************************
+* Register description of FFAST_BYPASS
+**********************************************************************/
+#define CGU_FFAST_BYPASS	0x1
+
+/**********************************************************************
+* Register description of soft reset registers
+**********************************************************************/
+#define CGU_CONFIG_SOFT_RESET	0x1
+
+/**********************************************************************
+* Register description of HPll REGISTERS
+**********************************************************************/
+#define CGU_HPLL0_ID		0
+#define CGU_HPLL1_ID		1
+
+/**********************************************************************
+* Register description of HP_FIN_SELECT
+**********************************************************************/
+#define CGU_HPLL_FIN_SEL_MASK		0xf
+#define CGU_FIN_SELECT_FFAST		0x0
+#define CGU_FIN_SELECT_XT_I2SRX_BCK0	0x1
+#define CGU_FIN_SELECT_XT_I2SRX_WS0	0x2
+#define CGU_FIN_SELECT_XT_I2SRX_BCK1	0x3
+#define CGU_FIN_SELECT_XT_I2SRX_WS1	0x4
+#define CGU_FIN_SELECT_HPPLL0		0x5
+#define CGU_FIN_SELECT_HPPLL1		0x6
+#define CGU_FIN_SELECT_MAX		7
+
+/**********************************************************************
+* Register description of HP_MDEC
+**********************************************************************/
+#define CGU_HPLL_MDEC_MASK		0x1ffff
+/**********************************************************************
+* Register description of HP_NDEC
+**********************************************************************/
+#define CGU_HPLL_NDEC_MSK		0x3ff
+/**********************************************************************
+* Register description of HP_PDEC
+**********************************************************************/
+#define CGU_HPLL_PDEC_MSK		0x7f
+/**********************************************************************
+* Register description of HP_MODE
+**********************************************************************/
+#define CGU_HPLL_MODE_POR_VAL		0x6
+#define CGU_HPLL_MODE_CLKEN		_BIT(0)
+#define CGU_HPLL_MODE_SKEWEN		_BIT(1)
+#define CGU_HPLL_MODE_PD		_BIT(2)
+#define CGU_HPLL_MODE_DIRECTO		_BIT(3)
+#define CGU_HPLL_MODE_DIRECTI		_BIT(4)
+#define CGU_HPLL_MODE_FRM		_BIT(5)
+#define CGU_HPLL_MODE_BANDSEL		_BIT(6)
+#define CGU_HPLL_MODE_LIMUP_OFF		_BIT(7)
+#define CGU_HPLL_MODE_BYPASS		_BIT(8)
+
+/**********************************************************************
+* Register description of HP1_STATUS
+**********************************************************************/
+#define CGU_HPLL_STATUS_FR		_BIT(1)
+#define CGU_HPLL_STATUS_LOCK		_BIT(0)
+
+/**********************************************************************
+* Register description of HP_ACK & HP_REQ
+**********************************************************************/
+#define CGU_HPLL_ACK_P			_BIT(2)
+#define CGU_HPLL_ACK_N			_BIT(1)
+#define CGU_HPLL_ACK_M			_BIT(0)
+
+/**********************************************************************
+* Register description of HP1_INSELR
+**********************************************************************/
+#define CGU_HPLL_INSELR_MASK		0xf
+/**********************************************************************
+* Register description of HP1_INSELI
+**********************************************************************/
+#define CGU_HPLL_INSELI_MASK		0x3f
+/**********************************************************************
+* Register description of HP1_INSELP
+**********************************************************************/
+#define CGU_HPLL_INSELP_MASK		0x1f
+/**********************************************************************
+* Register description of HP1_SELR
+**********************************************************************/
+#define CGU_HPLL_SELR_MASK		0xf
+/**********************************************************************
+* Register description of HP1_SELI
+**********************************************************************/
+#define CGU_HPLL_SELI_MASK		0x3f
+/**********************************************************************
+* Register description of HP1_SELP
+**********************************************************************/
+#define CGU_HPLL_SELP_MASK		0x1f
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* CLOCK_MAIN_H */
+
diff --git a/arch/arm/include/asm/arch-lpc313x/clock_switchbox.h b/arch/arm/include/asm/arch-lpc313x/clock_switchbox.h
new file mode 100644
index 0000000..c088100
--- /dev/null
+++ b/arch/arm/include/asm/arch-lpc313x/clock_switchbox.h
@@ -0,0 +1,358 @@
+/*
+ * (C) Copyright 2010 NXP Semiconductors
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef CLOCK_SWITCHBOX_H
+#define CLOCK_SWITCHBOX_H
+
+#include <common.h>
+#include <asm/arch/hardware.h>
+
+#ifdef __cplusplus
+extern "C"	/* Assume C declarations for C++ */
+{
+#endif
+
+#ifndef __ASSEMBLY__
+/***********************************************************************
+* CGU Switchbox register structure
+**********************************************************************/
+typedef volatile struct
+{
+	/* Switches controls */
+	volatile ulong base_scr[12]; /* Switch control */
+	volatile ulong base_fs1[12]; /* Frequency select side 1 */
+	volatile ulong base_fs2[12]; /* Frequency select side 2 */
+	volatile ulong base_ssr[12]; /* Switch status */
+	/* Clock enable controls (positive and inverted clock pairs share
+	 * control register)
+	 */
+	volatile ulong clk_pcr[92]; /* power control */
+	volatile ulong clk_psr[92]; /* power status */
+	/* enable select from fractional dividers (positive and inverted
+	 * clock pairs share esr)
+	 */
+	volatile ulong clk_esr[89]; /* enable select */
+	/* Base controls, currently only fd_run (base wide fractional
+	 *  divider enable) bit.
+	 */
+	volatile ulong base_bcr[5]; /* Base control */
+	/* Fractional divider config & ctrl */
+	volatile ulong base_fdc[24]; 
+	/* Fractional divider config & ctrl for dynamic fracdivs */
+	volatile ulong base_dyn_fdc[7]; 
+	 /* Fractional divider register for 
+	  * selecting an external signal to
+	  * trigger high-speed operation
+	  */
+	volatile ulong base_dyn_sel[7];
+} CGU_SB_REGS_T;
+
+/* Macro pointing to CGU switch box registers */
+#define CGU_SB	((CGU_SB_REGS_T *)(CGU_SWITCHBOX_BASE))
+
+#endif /*__ASSEMBLY__*/
+#ifdef __cplusplus
+}
+#endif
+
+#define CGU_SB_FSR_WIDTH	3
+#define CGU_SB_NR_BASE		12
+#define CGU_SB_NR_CLK		92
+#define CGU_SB_NR_BCR		5
+#define CGU_SB_NR_FRACDIV	24
+#define CGU_SB_NR_DYN_FDIV	7
+#define CGU_SB_NR_ESR		89
+
+
+/***********************************************************************
+ Register section offsets in APB address space
+***********************************************************************/
+#define SCR_OFFSET		0
+#define FS1_OFFSET		12
+#define FS2_OFFSET		24
+#define SSR_OFFSET		36
+#define PCR_OFFSET		48
+#define PSR_OFFSET		140
+#define ESR_OFFSET		232
+#define BCR_OFFSET		321
+#define FDC_OFFSET		326
+
+/***********************************************************************
+* Bit positions
+***********************************************************************/
+/* Switch Control Register */
+#define CGU_SB_SCR_EN1			_BIT(0)
+#define CGU_SB_SCR_EN2			_BIT(1)
+#define CGU_SB_SCR_RST			_BIT(2)
+#define CGU_SB_SCR_STOP			_BIT(3)
+#define CGU_SB_SCR_FS_MASK		0x3
+
+/* Switch Status Register */
+#define CGU_SB_SSR_FS_GET(x)	(((x) >> 2) & 0x7)
+/* Power Control Register */
+#define CGU_SB_PCR_RUN			_BIT(0)
+#define CGU_SB_PCR_AUTO			_BIT(1)
+#define CGU_SB_PCR_WAKE_EN		_BIT(2)
+#define CGU_SB_PCR_EXTEN_EN		_BIT(3)
+#define CGU_SB_PCR_ENOUT_EN		_BIT(4)
+/* Power Status Register */
+#define CGU_SB_PSR_ACTIVE		_BIT(0)
+#define CGU_SB_PSR_WAKEUP		_BIT(1)
+/* Enable Select Register */
+#define CGU_SB_ESR_ENABLE		_BIT(0)
+#define CGU_SB_ESR_SELECT(x)		_SBF(1, (x))
+#define CGU_SB_ESR_SEL_GET(x)		(((x) >> 1) & 0x7)
+
+/* Base control Register */
+#define CGU_SB_BCR_FD_RUN		_BIT(0)
+/* Fractional Divider Configuration Register */
+#define CGU_SB_FDC_RUN			_BIT(0)
+#define CGU_SB_FDC_RESET		_BIT(1)
+#define CGU_SB_FDC_STRETCH		_BIT(2)
+#define CGU_SB_FDC_MADD(x)		_SBF( 3, ((x) & 0xFF))
+#define CGU_SB_FDC_MSUB(x)		_SBF(11, ((x) & 0xFF))
+#define CGU_SB_FDC17_MADD(x)		_SBF( 3, ((x) & 0x1FFF))
+#define CGU_SB_FDC17_MSUB(x)		_SBF(16, ((x) & 0x1FFF))
+#define CGU_SB_FDC_MADD_GET(x)		(((x) >> 3) & 0xFF)
+#define CGU_SB_FDC_MSUB_GET(x)		((((x) >> 11) & 0xFF) | 0xFFFFFF00)
+#define CGU_SB_FDC17_MADD_GET(x)	(((x) >> 3) & 0x1FFF)
+#define CGU_SB_FDC17_MSUB_GET(x)	((((x) >> 16) & 0x1FFF) | 0xFFFFE000)
+#define CGU_SB_FDC_MADD_POS		3
+
+/* Dynamic Fractional Divider Configuration Register */
+#define CGU_SB_DYN_FDC_RUN		_BIT(0)
+#define CGU_SB_DYN_FDC_ALLOW		_BIT(1)
+#define CGU_SB_DYN_FDC_STRETCH		_BIT(2)
+
+/***********************************************************************
+* Clock domain base id's
+***********************************************************************/
+#define CGU_SB_SYS_BASE_ID                0
+#define CGU_SB_BASE_FIRST                 CGU_SB_SYS_BASE_ID
+#define CGU_SB_AHB0_APB0_BASE_ID          1
+#define CGU_SB_AHB0_APB1_BASE_ID          2
+#define CGU_SB_AHB0_APB2_BASE_ID          3
+#define CGU_SB_AHB0_APB3_BASE_ID          4
+#define CGU_SB_PCM_BASE_ID                5
+#define CGU_SB_UART_BASE_ID               6
+#define CGU_SB_CLK1024FS_BASE_ID          7
+#define CGU_SB_I2SRX_BCK0_BASE_ID         8
+#define CGU_SB_I2SRX_BCK1_BASE_ID         9
+#define CGU_SB_SPI_CLK_BASE_ID            10
+#define CGU_SB_SYSCLK_O_BASE_ID           11
+#define CGU_SB_BASE_LAST                  CGU_SB_SYSCLK_O_BASE_ID
+
+
+/***********************************************************************
+ Clock id's (= clkid in address calculation)
+***********************************************************************/
+/* domain 0 = SYS_BASE */
+#define CGU_SB_APB0_CLK_ID                 0
+#define CGU_SYS_FIRST                      CGU_SB_APB0_CLK_ID
+#define CGU_SB_APB1_CLK_ID                 1
+#define CGU_SB_APB2_CLK_ID                 2
+#define CGU_SB_APB3_CLK_ID                 3
+#define CGU_SB_APB4_CLK_ID                 4
+#define CGU_SB_AHB2INTC_CLK_ID             5
+#define CGU_SB_AHB0_CLK_ID                 6
+#define CGU_SB_EBI_CLK_ID                  7
+#define CGU_SB_DMA_PCLK_ID                 8
+#define CGU_SB_DMA_CLK_GATED_ID            9
+#define CGU_SB_NANDFLASH_S0_CLK_ID         10
+#define CGU_SB_NANDFLASH_ECC_CLK_ID        11
+#define CGU_SB_NANDFLASH_AES_CLK_ID        12 /* valid on LPC3153 & LPC3154 only */
+#define CGU_SB_NANDFLASH_NAND_CLK_ID       13
+#define CGU_SB_NANDFLASH_PCLK_ID           14
+#define CGU_SB_CLOCK_OUT_ID                15
+#define CGU_SB_ARM926_CORE_CLK_ID          16
+#define CGU_SB_ARM926_BUSIF_CLK_ID         17
+#define CGU_SB_ARM926_RETIME_CLK_ID        18
+#define CGU_SB_SD_MMC_HCLK_ID              19
+#define CGU_SB_SD_MMC_CCLK_IN_ID           20
+#define CGU_SB_USB_OTG_AHB_CLK_ID          21
+#define CGU_SB_ISRAM0_CLK_ID               22
+#define CGU_SB_RED_CTL_RSCLK_ID            23
+#define CGU_SB_ISRAM1_CLK_ID               24
+#define CGU_SB_ISROM_CLK_ID                25
+#define CGU_SB_MPMC_CFG_CLK_ID             26
+#define CGU_SB_MPMC_CFG_CLK2_ID            27
+#define CGU_SB_MPMC_CFG_CLK3_ID            28
+#define CGU_SB_INTC_CLK_ID                 29
+#define CGU_SYS_LAST                       CGU_SB_INTC_CLK_ID
+/* domain 1 = AHB0APB0_BASE */
+#define CGU_SB_AHB2APB0_ASYNC_PCLK_ID      30
+#define CGU_AHB0APB0_FIRST                 CGU_SB_AHB2APB0_ASYNC_PCLK_ID
+#define CGU_SB_EVENT_ROUTER_PCLK_ID        31
+#define CGU_SB_ADC_PCLK_ID                 32
+#define CGU_SB_ADC_CLK_ID                  33
+#define CGU_SB_WDOG_PCLK_ID                34
+#define CGU_SB_IOCONF_PCLK_ID              35
+#define CGU_SB_CGU_PCLK_ID                 36
+#define CGU_SB_SYSCREG_PCLK_ID             37
+#define CGU_SB_OTP_PCLK_ID                 38 /* valid on LPC315x series only */
+#define CGU_SB_RNG_PCLK_ID                 39
+#define CGU_AHB0APB0_LAST                  CGU_SB_RNG_PCLK_ID
+/* domain 2 = AHB0APB1_BASE */
+#define CGU_SB_AHB2APB1_ASYNC_PCLK_ID      40
+#define CGU_AHB0APB1_FIRST                 CGU_SB_AHB2APB1_ASYNC_PCLK_ID
+#define CGU_SB_TIMER0_PCLK_ID              41
+#define CGU_SB_TIMER1_PCLK_ID              42
+#define CGU_SB_TIMER2_PCLK_ID              43
+#define CGU_SB_TIMER3_PCLK_ID              44
+#define CGU_SB_PWM_PCLK_ID                 45
+#define CGU_SB_PWM_PCLK_REGS_ID            46
+#define CGU_SB_PWM_CLK_ID                  47
+#define CGU_SB_I2C0_PCLK_ID                48
+#define CGU_SB_I2C1_PCLK_ID                49
+#define CGU_AHB0APB1_LAST                  CGU_SB_I2C1_PCLK_ID
+/* domain 3 = AHB0APB2_BASE */
+#define CGU_SB_AHB2APB2_ASYNC_PCLK_ID      50
+#define CGU_AHB0APB2_FIRST                 CGU_SB_AHB2APB2_ASYNC_PCLK_ID
+#define CGU_SB_PCM_PCLK_ID                 51
+#define CGU_SB_PCM_APB_PCLK_ID             52
+#define CGU_SB_UART_APB_CLK_ID             53
+#define CGU_SB_LCD_PCLK_ID                 54
+#define CGU_SB_LCD_CLK_ID                  55
+#define CGU_SB_SPI_PCLK_ID                 56
+#define CGU_SB_SPI_PCLK_GATED_ID           57
+#define CGU_AHB0APB2_LAST                  CGU_SB_SPI_PCLK_GATED_ID
+/* domain 4 = AHB0APB3_BASE */
+#define CGU_SB_AHB2APB3_ASYNC_PCLK_ID      58
+#define CGU_AHB0APB3_FIRST                 CGU_SB_AHB2APB3_ASYNC_PCLK_ID
+#define CGU_SB_I2S_CFG_PCLK_ID             59
+#define CGU_SB_EDGE_DET_PCLK_ID            60
+#define CGU_SB_I2STX_FIFO_0_PCLK_ID        61
+#define CGU_SB_I2STX_IF_0_PCLK_ID          62 
+#define CGU_SB_I2STX_FIFO_1_PCLK_ID        63
+#define CGU_SB_I2STX_IF_1_PCLK_ID          64
+#define CGU_SB_I2SRX_FIFO_0_PCLK_ID        65
+#define CGU_SB_I2SRX_IF_0_PCLK_ID          66
+#define CGU_SB_I2SRX_FIFO_1_PCLK_ID        67
+#define CGU_SB_I2SRX_IF_1_PCLK_ID          68
+#define CGU_SB_RSVD69_ID                   69
+#define CGU_SB_AHB2APB3_RSVD_ID            70
+#define CGU_AHB0APB3_LAST                  CGU_SB_AHB2APB3_RSVD_ID
+/* domain 5 = PCM_BASE */
+#define CGU_SB_PCM_CLK_IP_ID               71
+#define CGU_PCM_FIRST                      CGU_SB_PCM_CLK_IP_ID
+#define CGU_PCM_LAST                       CGU_SB_PCM_CLK_IP_ID
+/* domain 6 = UART_BASE */
+#define CGU_SB_UART_U_CLK_ID               72 
+#define CGU_UART_FIRST                     CGU_SB_UART_U_CLK_ID
+#define CGU_UART_LAST                      CGU_SB_UART_U_CLK_ID
+/* domain 7 = CLK1024FS_BASE */
+#define CGU_SB_I2S_EDGE_DETECT_CLK_ID      73
+#define CGU_CLK1024FS_FIRST                CGU_SB_I2S_EDGE_DETECT_CLK_ID
+#define CGU_SB_I2STX_BCK0_N_ID             74
+#define CGU_SB_I2STX_WS0_ID                75
+#define CGU_SB_I2STX_CLK0_ID               76
+#define CGU_SB_I2STX_BCK1_N_ID             77
+#define CGU_SB_I2STX_WS1_ID                78
+#define CGU_SB_CLK_256FS_ID                79
+#define CGU_SB_I2SRX_BCK0_N_ID             80
+#define CGU_SB_I2SRX_WS0_ID                81
+#define CGU_SB_I2SRX_BCK1_N_ID             82
+#define CGU_SB_I2SRX_WS1_ID                83
+#define CGU_SB_RSVD84_ID                   84
+#define CGU_SB_RSVD85_ID                   85
+#define CGU_SB_RSVD86_ID                   86
+#define CGU_CLK1024FS_LAST                 CGU_SB_RSVD86_ID
+/* domain 8 = BCK0_BASE */
+#define CGU_SB_I2SRX_BCK0_ID               87
+#define CGU_I2SRX_BCK0_FIRST               CGU_SB_I2SRX_BCK0_ID
+#define CGU_I2SRX_BCK0_LAST                CGU_SB_I2SRX_BCK0_ID
+
+/* domain 9 = BCK1_BASE */
+#define CGU_SB_I2SRX_BCK1_ID               88
+#define CGU_I2SRX_BCK1_FIRST               CGU_SB_I2SRX_BCK1_ID
+#define CGU_I2SRX_BCK1_LAST                CGU_SB_I2SRX_BCK1_ID
+
+/* domain 10 = SPI_BASE */
+#define CGU_SB_SPI_CLK_ID                  89
+#define CGU_SPI_FIRST                      CGU_SB_SPI_CLK_ID
+#define CGU_SB_SPI_CLK_GATED_ID            90
+#define CGU_SPI_LAST                       CGU_SB_SPI_CLK_GATED_ID
+
+/* domain 11 = SYSCLKO_BASE */
+#define CGU_SB_SYSCLK_O_ID                 91
+#define CGU_SYSCLK_O_FIRST                 CGU_SB_SYSCLK_O_ID
+#define CGU_SYSCLK_O_LAST                  CGU_SB_SYSCLK_O_ID
+
+#define CGU_SB_INVALID_CLK_ID              -1
+
+/*
+ * NR of fractional dividers available for each base frequency,
+ * their bit widths and extractions for sub elements from the
+ * fractional divider configuration register
+ */
+#define CGU_SB_BASE0_FDIV_CNT		7
+#define CGU_SB_BASE0_FDIV_LOW_ID	0
+#define CGU_SB_BASE0_FDIV_HIGH_ID	6
+#define CGU_SB_BASE0_FDIV0_W		8
+
+#define CGU_SB_BASE1_FDIV_CNT		2
+#define CGU_SB_BASE1_FDIV_LOW_ID	7
+#define CGU_SB_BASE1_FDIV_HIGH_ID	8
+#define CGU_SB_BASE1_FDIV0_W		8
+
+#define CGU_SB_BASE2_FDIV_CNT		2
+#define CGU_SB_BASE2_FDIV_LOW_ID	9
+#define CGU_SB_BASE2_FDIV_HIGH_ID	10
+#define CGU_SB_BASE2_FDIV0_W		8
+
+#define CGU_SB_BASE3_FDIV_CNT		3
+#define CGU_SB_BASE3_FDIV_LOW_ID	11
+#define CGU_SB_BASE3_FDIV_HIGH_ID	13
+#define CGU_SB_BASE3_FDIV0_W		8
+
+#define CGU_SB_BASE4_FDIV_CNT		1
+#define CGU_SB_BASE4_FDIV_LOW_ID	14
+#define CGU_SB_BASE4_FDIV_HIGH_ID	14
+#define CGU_SB_BASE4_FDIV0_W		8
+
+#define CGU_SB_BASE5_FDIV_CNT		1
+#define CGU_SB_BASE5_FDIV_LOW_ID	15
+#define CGU_SB_BASE5_FDIV_HIGH_ID	15
+#define CGU_SB_BASE5_FDIV0_W		8
+
+#define CGU_SB_BASE6_FDIV_CNT		1
+#define CGU_SB_BASE6_FDIV_LOW_ID	16
+#define CGU_SB_BASE6_FDIV_HIGH_ID	16
+#define CGU_SB_BASE6_FDIV0_W		8
+
+#define CGU_SB_BASE7_FDIV_CNT		6
+#define CGU_SB_BASE7_FDIV_LOW_ID	17
+#define CGU_SB_BASE7_FDIV_HIGH_ID	22
+#define CGU_SB_BASE7_FDIV0_W		13
+
+#define CGU_SB_BASE8_FDIV_CNT		0
+#define CGU_SB_BASE9_FDIV_CNT		0
+#define CGU_SB_BASE10_FDIV_CNT		1
+#define CGU_SB_BASE10_FDIV_LOW_ID	23
+#define CGU_SB_BASE10_FDIV_HIGH_ID	23
+#define CGU_SB_BASE10_FDIV0_W		8
+
+#define CGU_SB_BASE11_FDIV_CNT		0
+
+
+
+#endif /* CLOCK_SWITCHBOX_H */
diff --git a/arch/arm/include/asm/arch-lpc313x/common.h b/arch/arm/include/asm/arch-lpc313x/common.h
new file mode 100644
index 0000000..52361b4
--- /dev/null
+++ b/arch/arm/include/asm/arch-lpc313x/common.h
@@ -0,0 +1,10 @@
+struct spl_image_info {
+	const char *name;
+	u8 os;
+	u32 load_addr;
+	u32 entry_point;
+	u32 size;
+};
+
+extern struct spl_image_info spl_image;
+
diff --git a/arch/arm/include/asm/arch-lpc313x/hardware.h b/arch/arm/include/asm/arch-lpc313x/hardware.h
new file mode 100644
index 0000000..39b22d4
--- /dev/null
+++ b/arch/arm/include/asm/arch-lpc313x/hardware.h
@@ -0,0 +1,102 @@
+/*
+ * (C) Copyright 2010 NXP Semiconductors
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __ASM_ARCH_HARDWARE_H
+#define __ASM_ARCH_HARDWARE_H
+
+#include <config.h>
+
+#define _BIT(n)		(((ulong)(1)) << (n))
+
+#undef _SBF
+/* Set bit field macro */
+#define _SBF(f,v)	(((ulong)(v)) << (f))
+#define _BITMASK(field_width)	(_BIT(field_width) - 1)
+
+#define _NO_ERROR	(long)(0)
+#define _ERROR		(long)(-1)
+
+#define ISRAM_BASE			0x11028000
+#define ISRAM_ESRAM0_BASE		0x11028000
+#define ISRAM_ESRAM1_BASE		0x11040000
+#define ISROM_BASE			0x12000000
+#define EVENT_ROUTER_BASE		0x13000000
+#define ADC_BASE			0x13002000
+#define WDOG_BASE			0x13002400
+#define SYSCREG_BASE			0x13002800
+#define IOCONF_BASE			0x13003000
+#define CGU_SWITCHBOX_BASE		0x13004000
+#define CGU_BASE			0x13004c00
+#define CIC_RNG_BASE			0x13006000
+#define TIMER0_BASE			0x13008000
+#define TIMER1_BASE			0x13008400
+#define TIMER2_BASE			0x13008800
+#define TIMER3_BASE			0x13008c00
+#define PWM_BASE			0x13009000
+#define I2C0_BASE			0x1300a000
+#define I2C1_BASE			0x1300a400
+#define IPINT_BASE			0x15000000
+#define LCD_INTERFACE_BASE		0x15000400
+#define UART_BASE			0x15001000
+#define SPI_BASE			0x15002000
+#define I2S_SYS_CONFIG			0x16000000
+#define I2S_TX0_BASE			0x16000080
+#define I2S_TX1_BASE			0x16000100
+#define I2S_RX0_BASE			0x16000180
+#define I2S_RX1_BASE			0x16000200
+#define DMA_BASE			0x17000000
+#define NANDFLASH_CTRL_CFG_BASE		0x17000800
+#define MPMC_CFG_BASE			0x17008000
+#define SD_MMC_BASE			0x18000000
+#define USBOTG_BASE			0x19000000
+#define EXT_SRAM0_0_BASE		0x20000000
+#define EXT_SRAM0_1_BASE		0x20020000
+#define EXT_SDRAM_BASE			0x30000000
+#define AHB2MMIO_BASE			0x60000000
+#define INTC_BASE			0x60000000
+#define NANDFLASH_CTRL_S0_BASE		0x70000000
+
+#ifndef __ASSEMBLY__
+#define __REG(x)	(*((volatile u32 *)(x)))
+#else
+#define __REG(x)	(x)
+#endif
+
+/***********************************************************************
+ * Event router register definitions
+ **********************************************************************/
+#define EVRT_INT_PEND(bank)  __REG (EVENT_ROUTER_BASE + 0xC00 + ((bank) << 2))
+#define EVRT_INT_CLR(bank)   __REG (EVENT_ROUTER_BASE + 0xC20 + ((bank) << 2))
+#define EVRT_INT_SET(bank)   __REG (EVENT_ROUTER_BASE + 0xC40 + ((bank) << 2))
+#define EVRT_MASK(bank)      __REG (EVENT_ROUTER_BASE + 0xC60 + ((bank) << 2))
+#define EVRT_MASK_CLR(bank)  __REG (EVENT_ROUTER_BASE + 0xC80 + ((bank) << 2))
+#define EVRT_MASK_SET(bank)  __REG (EVENT_ROUTER_BASE + 0xCA0 + ((bank) << 2))
+#define EVRT_APR(bank)       __REG (EVENT_ROUTER_BASE + 0xCC0 + ((bank) << 2))
+#define EVRT_ATR(bank)       __REG (EVENT_ROUTER_BASE + 0xCE0 + ((bank) << 2))
+#define EVRT_RSR(bank)       __REG (EVENT_ROUTER_BASE + 0xD20 + ((bank) << 2))
+#define EVRT_OUT_PEND(vec,bank)     __REG (EVENT_ROUTER_BASE + 0x1000 + ((vec) << 5) + ((bank) << 2))
+#define EVRT_OUT_MASK(vec,bank)     __REG (EVENT_ROUTER_BASE + 0x1400 + ((vec) << 5) + ((bank) << 2))
+#define EVRT_OUT_MASK_CLR(vec,bank) __REG (EVENT_ROUTER_BASE + 0x1800 + ((vec) << 5) + ((bank) << 2))
+#define EVRT_OUT_MASK_SET(vec,bank) __REG (EVENT_ROUTER_BASE + 0x1C00 + ((vec) << 5) + ((bank) << 2))
+
+#endif /* ASM_ARCH_HARDWARE_H */
+
diff --git a/arch/arm/include/asm/arch-lpc313x/i2c.h b/arch/arm/include/asm/arch-lpc313x/i2c.h
new file mode 100644
index 0000000..4d18437
--- /dev/null
+++ b/arch/arm/include/asm/arch-lpc313x/i2c.h
@@ -0,0 +1,108 @@
+/*
+ * (C) Copyright 2010 NXP Semiconductors
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ * 
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ * 
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *  
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+
+#ifndef I2C_H
+#define I2C_H
+
+#include <common.h>
+#include <asm/arch/hardware.h>
+#include <asm/arch/clock.h>
+
+#if defined(__cplusplus)
+extern "C"
+{
+#endif
+
+/* I2C Master Slave interface Controller Module Register Structure */
+typedef volatile struct
+{
+	volatile ulong fifo;
+	volatile ulong sts;
+	volatile ulong ctl;
+	volatile ulong ckh;
+	volatile ulong ckl;
+	volatile ulong adr;
+	volatile const ulong rfl;
+	volatile const ulong tfl;
+	volatile const ulong rxb;
+	volatile const ulong txb;
+	volatile ulong txs;
+	volatile const ulong stfl;
+} I2C_REGS_T;
+
+/***********************************************************************
+ * I2C Tx FIFO register definitions
+ **********************************************************************/
+#define I2C_TXFF_STOP_CND	_BIT(9)
+#define I2C_TXFF_START_CND	_BIT(8)
+#define I2C_TXFF_DATA_MSK	0xFF
+
+/***********************************************************************
+ * I2C status register definitions
+ **********************************************************************/
+#define I2C_STS_TFES		_BIT(13)
+#define I2C_STS_TFFS		_BIT(12)
+#define I2C_STS_TFE		_BIT(11)
+#define I2C_STS_TFF		_BIT(10)
+#define I2C_STS_RFE		_BIT(9)
+#define I2C_STS_RFF		_BIT(8)
+#define I2C_STS_SDA		_BIT(7)
+#define I2C_STS_SCL		_BIT(6)
+#define I2C_STS_ACTIVE		_BIT(5)
+#define I2C_STS_DRSI		_BIT(4)
+#define I2C_STS_DRMI		_BIT(3)
+#define I2C_STS_NAI		_BIT(2)
+#define I2C_STS_AFI		_BIT(1)
+#define I2C_STS_TDI		_BIT(0)
+
+/***********************************************************************
+ * I2C control register definitions
+ **********************************************************************/
+#define I2C_CTL_TFFSIE		_BIT(10)
+#define I2C_CTL_SEVEN		_BIT(9)
+#define I2C_CTL_SOFT_RESET	_BIT(8)
+#define I2C_CTL_TFFIE		_BIT(7)
+#define I2C_CTL_DAIE		_BIT(6)
+#define I2C_CTL_RFFIE		_BIT(5)
+#define I2C_CTL_DRSIE		_BIT(4)
+#define I2C_CTL_DRMIE		_BIT(3)
+#define I2C_CTL_NAIE		_BIT(2)
+#define I2C_CTL_AFIE		_BIT(1)
+#define I2C_CTL_TDIE		_BIT(0)
+
+/* Macro pointing to I2C controller registers */
+#define I2C0_CTRL	((I2C_REGS_T *)(I2C0_BASE))
+#define I2C1_CTRL	((I2C_REGS_T *)(I2C1_BASE))
+
+void i2c_init(u32 id, I2C_REGS_T *pI2cBase);
+void i2c_write(I2C_REGS_T *pI2cBase, u32 slave_addr, u32 reg_addr,
+		u32 addr_len, u32 reg_value,u32 data_len);
+
+void i2c_read(I2C_REGS_T *pI2cBase, u32 slave_addr, u32 reg_addr,
+		u32 addr_len, u32 *pReg_value,u32 data_len);
+
+#if defined(__cplusplus)
+}
+#endif
+
+#endif /* I2C_H */
diff --git a/arch/arm/include/asm/arch-lpc313x/ioconf.h b/arch/arm/include/asm/arch-lpc313x/ioconf.h
new file mode 100644
index 0000000..d00ec33
--- /dev/null
+++ b/arch/arm/include/asm/arch-lpc313x/ioconf.h
@@ -0,0 +1,114 @@
+/*
+ * (C) Copyright 2010 NXP Semiconductors
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef IOCONF_H
+#define IOCONF_H
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+/* IOCONF Function Block Register Structure */
+typedef volatile struct
+{
+	volatile ulong pins;
+	volatile ulong _d1[3];
+	volatile ulong mode0;
+	volatile ulong mode0_set;
+	volatile ulong mode0_clear;
+	volatile ulong _d2[1];
+	volatile ulong mode1;
+	volatile ulong mode1_set;
+	volatile ulong mode1_clear;
+	volatile ulong _d3[5];
+} IOCONF_FUNC_REGS_T;
+
+/* IOCONF Register Structure */
+typedef volatile struct
+{
+	IOCONF_FUNC_REGS_T block[13];
+} IOCONF_REGS_T;
+
+typedef enum
+{
+	IOCONF_MUX0,
+	IOCONF_MUX1,
+	IOCONF_CGU,
+	IOCONF_DAI0,
+	IOCONF_DAI1,
+	IOCONF_DAO1,
+	IOCONF_EBI,
+	IOCONF_GPIO,
+	IOCONF_I2C1,
+	IOCONF_SPI,
+	IOCONF_NAND_CTRL,
+	IOCONF_PWM,
+	IOCONF_UART
+} IOCONF_BLOCK_T;
+
+/**********************************************************************
+ * * Macro to access IOCONF registers
+ * **********************************************************************/
+#define IOCONF	((IOCONF_REGS_T*)IOCONF_BASE)
+
+
+/* Returns current input states of the input pin */
+static __inline ulong gpio_get_pin_state(IOCONF_BLOCK_T gpio_block, ulong bitnum)
+{
+	/* If high, return TRUE. If low, return FALSE */
+	return (IOCONF->block[gpio_block].pins & _BIT(bitnum));
+}
+
+/* Sets GPIO pin as input pin */
+static __inline void gpio_set_as_input(IOCONF_BLOCK_T gpio_block, ulong bitnum)
+{
+	IOCONF->block[gpio_block].mode1_clear = _BIT(bitnum);
+	IOCONF->block[gpio_block].mode0_clear = _BIT(bitnum);
+}
+
+/* Sets GPIO output pin to high state */
+static __inline void gpio_set_outpin_high(IOCONF_BLOCK_T gpio_block, ulong bitnum)
+{
+	IOCONF->block[gpio_block].mode1_set = _BIT(bitnum);
+	IOCONF->block[gpio_block].mode0_set = _BIT(bitnum);
+}
+
+/* Sets GPIO output pin to high state */
+static __inline void gpio_set_outpin_low(IOCONF_BLOCK_T gpio_block, ulong bitnum)
+{
+	IOCONF->block[gpio_block].mode1_set = _BIT(bitnum);
+	IOCONF->block[gpio_block].mode0_clear = _BIT(bitnum);
+}
+
+/* Sets GPIO/MUX pin as driven by IP pin */
+static __inline void gpio_set_as_ip_driven(IOCONF_BLOCK_T gpio_block, ulong bitnum)
+{
+	IOCONF->block[gpio_block].mode1_clear = _BIT(bitnum);
+	IOCONF->block[gpio_block].mode0_set = _BIT(bitnum);
+}
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* IOCONFR_H */
diff --git a/arch/arm/include/asm/arch-lpc313x/mci.h b/arch/arm/include/asm/arch-lpc313x/mci.h
new file mode 100644
index 0000000..bdb6f36
--- /dev/null
+++ b/arch/arm/include/asm/arch-lpc313x/mci.h
@@ -0,0 +1,203 @@
+/*
+ * (C) Copyright 2010 NXP Semiconductors
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef MCI_H
+#define MCI_H
+
+#include <common.h>
+#include <asm/arch/hardware.h>
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+struct _mci_card_struct
+{
+	ulong response[4];	/* Most recent response */
+	ulong cid[4];		/* CID of acquired card */
+	ulong csd[4];		/* CSD of acquired card */
+	ulong card_type;
+	ulong rca;		/* Relative address assigned to card */
+	ulong speed;
+	ulong block_len;
+	ulong device_size;
+	ulong blocknr;
+};
+typedef struct _mci_card_struct MCI_CARD_INFO_T;
+
+/* Memory Card Interface (MCI) Module Register Structure */
+typedef volatile struct
+{
+	volatile ulong ctrl;	/* control register (R/W) */
+	volatile ulong pwren;	/* power-enable register (R/W) */
+	volatile ulong clkdiv;	/* clock-divider register (R/W) */
+	volatile ulong clksrc;	/* clock-source register (R/W) */
+	volatile ulong clkena;	/* clock enable register (R/W) */
+	volatile ulong tmout;	/* time-out register (R/W) */
+	volatile ulong ctype;	/* card-type register (R/W) */
+	volatile ulong blksiz;	/* blck-size register (R/W) */
+	volatile ulong bytcnt;	/* byte-count register (R/W) */
+	volatile ulong intmsk;	/* interrupt-mask register (R/W) */
+	volatile ulong cmdarg;	/* command-argument register (R/W) */
+	volatile ulong cmd;	/* command register (R/W) */
+	volatile ulong resp0;	/* response-0 register (R) */
+	volatile ulong resp1;	/* response-1 register (R) */
+	volatile ulong resp2;	/* response-2 register (R) */
+	volatile ulong resp3;	/* response-3 register (R) */
+	volatile ulong mintsts;	/* masked interrupt-status register (R) */
+	volatile ulong rintsts;	/* raw interrupt-status register (R/W) */
+	volatile ulong status;	/* status; mainly for debug register (R) */
+	volatile ulong fifoth;	/* FIFO treshold register (R/W) */
+	volatile ulong cdetec;	/* card-detect register (R) */
+	volatile ulong wrtprt;	/* write-protect register (R) */
+	volatile ulong gpio;	/* GPIO register (R/W) */
+	volatile ulong tcbcnt;	/* transferred CIU card byte count register (R) */
+	volatile ulong tbbcnt;	/* transferred host/DMA to/from BIU-FIFO byte count register (R) */
+	volatile ulong debnce;	/* card detect debounce register (R/W) */
+	volatile ulong usrid;	/* user ID register (R/W) */
+	volatile ulong verid;	/* synopsys version ID register (R) */
+	volatile ulong hcon;	/* hardware configuration register (R) */
+	volatile ulong reserved[23];	/* Data FIFO (R) */
+	volatile ulong data;	/* Data FIFO (R) */
+} MCI_REGS_T;
+
+#ifdef __cplusplus
+}
+#endif
+/***********************************************************************
+* useful defines
+***********************************************************************/
+#define SD_MMC_ENUM_CLOCK	400000
+#define MMC_MAX_CLOCK		20000000
+#define MMC_LOW_BUS_MAX_CLOCK	26000000
+#define MMC_HIGH_BUS_MAX_CLOCK	52000000
+#define SD_MAX_CLOCK		25000000
+#define MCI_FIFO_SZ		32
+#define SYS_REG_SD_CARD_DELAY	0x1B
+#define SYS_REG_MMC_CARD_DELAY	0x16
+
+/***********************************************************************
+* Control register defines
+***********************************************************************/
+#define MCI_CTRL_CEATA_INT_EN	_BIT(11)
+#define MCI_CTRL_SEND_AS_CCSD	_BIT(10)
+#define MCI_CTRL_SEND_CCSD	_BIT(9)
+#define MCI_CTRL_ABRT_READ_DATA	_BIT(8)
+#define MCI_CTRL_SEND_IRQ_RESP	_BIT(7)
+#define MCI_CTRL_READ_WAIT	_BIT(6)
+#define MCI_CTRL_DMA_ENABLE	_BIT(5)
+#define MCI_CTRL_INT_ENABLE	_BIT(4)
+#define MCI_CTRL_DMA_RESET	_BIT(2)
+#define MCI_CTRL_FIFO_RESET	_BIT(1)
+#define MCI_CTRL_RESET		_BIT(0)
+
+/***********************************************************************
+* Clock Enable register defines
+***********************************************************************/
+#define MCI_CLKEN_LOW_PWR	_BIT(16)
+#define MCI_CLKEN_ENABLE	_BIT(0)
+
+/***********************************************************************
+* time-out register defines
+***********************************************************************/
+#define MCI_TMOUT_DATA(n)	_SBF(8, (n))
+#define MCI_TMOUT_DATA_MSK	0xFFFFFF00
+#define MCI_TMOUT_RESP(n)	((n) & 0xFF)
+#define MCI_TMOUT_RESP_MSK	0xFF
+
+/***********************************************************************
+* card-type register defines
+***********************************************************************/
+#define MCI_CTYPE_8BIT		_BIT(16)
+#define MCI_CTYPE_4BIT		_BIT(0)
+
+/***********************************************************************
+* Interrupt status & mask register defines
+***********************************************************************/
+#define MCI_INT_SDIO		_BIT(16)
+#define MCI_INT_EBE		_BIT(15)
+#define MCI_INT_ACD		_BIT(14)
+#define MCI_INT_SBE		_BIT(13)
+#define MCI_INT_HLE		_BIT(12)
+#define MCI_INT_FRUN		_BIT(11)
+#define MCI_INT_HTO		_BIT(10)
+#define MCI_INT_DTO		_BIT(9)
+#define MCI_INT_RTO		_BIT(8)
+#define MCI_INT_DCRC		_BIT(7)
+#define MCI_INT_RCRC		_BIT(6)
+#define MCI_INT_RXDR		_BIT(5)
+#define MCI_INT_TXDR		_BIT(4)
+#define MCI_INT_DATA_OVER	_BIT(3)
+#define MCI_INT_CMD_DONE	_BIT(2)
+#define MCI_INT_RESP_ERR	_BIT(1)
+#define MCI_INT_CD		_BIT(0)
+#define MCI_INT_ERROR		0xbfc2
+
+/***********************************************************************
+* Command register defines
+***********************************************************************/
+#define MCI_CMD_START		_BIT(31)
+#define MCI_CMD_CCS_EXP		_BIT(23)
+#define MCI_CMD_CEATA_RD	_BIT(22)
+#define MCI_CMD_UPD_CLK		_BIT(21)
+#define MCI_CMD_UPD_CLK		_BIT(21)
+
+#define MCI_CMD_INIT		_BIT(15)
+#define MCI_CMD_STOP		_BIT(14)
+#define MCI_CMD_PRV_DAT_WAIT	_BIT(13)
+#define MCI_CMD_SEND_STOP	_BIT(12)
+#define MCI_CMD_STRM_MODE	_BIT(11)
+#define MCI_CMD_DAT_WR		_BIT(10)
+#define MCI_CMD_DAT_EXP		_BIT(9)
+#define MCI_CMD_RESP_CRC	_BIT(8)
+#define MCI_CMD_RESP_LONG	_BIT(7)
+#define MCI_CMD_RESP_EXP	_BIT(6)
+#define MCI_CMD_INDX(n)		((n) & 0x1F)
+
+/***********************************************************************
+* status register defines
+***********************************************************************/
+#define MCI_STS_GET_FCNT(x)	(((x)>>17) & 0x1FF)
+
+/**********************************************************************
+* Macro to access MCI registers
+**********************************************************************/
+#define MCI	((MCI_REGS_T*)SD_MMC_BASE)
+
+/* card type defines */
+#define CARD_TYPE_SD		(1 << 0)
+#define CARD_TYPE_4BIT		(1 << 1)
+#define CARD_TYPE_8BIT		(1 << 2)
+#define CARD_TYPE_HC		(OCR_HC_CCS) /* high capacity card > 2GB */
+
+/* MCI read function - read all 16 data registers */
+ulong mci_read_blocks(int devid, ulong start_block,
+		long blkcnt, void* buffer);
+
+/* MCI write function - writes all 16 data registers */
+ulong mci_write_blocks(int devid, ulong start_block,
+		long blkcnt, void* buffer);
+/* MCI command execution */
+long mci_execute_command(MCI_CARD_INFO_T* pdev, ulong cmd,
+		ulong arg, ulong wait_status);
+#endif /* MCI_H */
diff --git a/arch/arm/include/asm/arch-lpc313x/nand.h b/arch/arm/include/asm/arch-lpc313x/nand.h
new file mode 100644
index 0000000..d494397
--- /dev/null
+++ b/arch/arm/include/asm/arch-lpc313x/nand.h
@@ -0,0 +1,252 @@
+/*
+ * (C) Copyright 2010 NXP Semiconductors
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef NAND_H
+#define NAND_H
+
+#include <common.h>
+#include <asm/arch/hardware.h>
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+/***********************************************************************
+ * NAND device structure and it defines
+***********************************************************************/
+/*
+ * Timing information structure for the NAND interface. Although there are
+ * multiple chip selects for the NAND controller, there is only 1 set of
+ * timing data shared among all chip selects. All the parts should be of
+ * These values are used to adjust the NAND timing to the current system
+ * clock speed.
+ *
+ * These values are NanoSecond timings. See the LPC31xx Users Guide for
+ * information on what these timings are and set the value for each timing
+ * with the matching value from the NAND device data sheet.
+ */
+struct lpc313x_nand_timing
+{
+	u32 ns_trsd;
+	u32 ns_tals;
+	u32 ns_talh;
+	u32 ns_tcls;
+	u32 ns_tclh;
+	u32 ns_tdrd;
+	u32 ns_tebidel;
+	u32 ns_tch;
+	u32 ns_tcs;
+	u32 ns_treh;
+	u32 ns_trp;
+	u32 ns_trw;
+	u32 ns_twp;
+};
+
+/* NAND Flash configuration parameters structure used by bootROM */
+typedef struct
+{
+	char tag[8];
+	u8 interface_width;
+	u8 reserv_1;
+	u16 page_size_in_bytes;
+	u16 page_size_in_32bit_words;
+	u16 pages_per_block;
+	u32 nbr_of_blocks;
+	u8 amount_of_address_bytes;
+	u8 amount_of_erase_address_bytes;
+	u8 support_read_terminate;
+	u8 page_increment_byte_nr;
+	char device_name[40];
+	u32 timing1;
+	u32 timing2;
+	u8 ecc_mode;
+	u8 id_mask;
+	u8 reserv_2[2];
+} NAND_BOOT_CFG_PARAMS_T;
+
+/* NAND Flash controller Module Register Structure */
+typedef volatile struct
+{
+	volatile unsigned long irq_status;
+	volatile unsigned long irq_mask;
+	volatile unsigned long irq_status_raw;
+	volatile unsigned long config;
+	volatile unsigned long io_config;
+	volatile unsigned long timing1;
+	volatile unsigned long timing2;
+	volatile unsigned long _unused1[1];
+	volatile unsigned long set_cmd;
+	volatile unsigned long set_addr;
+	volatile unsigned long write_data;
+	volatile unsigned long set_ce;
+	volatile unsigned long read_data;
+	volatile unsigned long check_sts;
+	volatile unsigned long control_flow;
+	volatile unsigned long _unused2[1];
+	volatile unsigned long gpio1;
+	volatile unsigned long gpio2;
+	volatile unsigned long irq_status2;
+	volatile unsigned long irq_mask2;
+	volatile unsigned long irq_status_raw2;
+	volatile unsigned long aes_key[4];
+	volatile unsigned long aes_iv[4];
+	volatile unsigned long aes_state;
+	volatile unsigned long ecc_error_stat;
+	volatile unsigned long aes_from_ahb;
+} NAND_FLASH_CTRL_REGS_T;
+
+/**********************************************************************
+* Register description of irq_status
+**********************************************************************/
+#define NAND_IRQ_RB4_POS_EDGE		_BIT(31)
+#define NAND_IRQ_RB3_POS_EDGE		_BIT(30)
+#define NAND_IRQ_RB2_POS_EDGE		_BIT(29)
+#define NAND_IRQ_RB1_POS_EDGE		_BIT(28)
+#define NAND_IRQ_ERASED_RAM1		_BIT(27)
+#define NAND_IRQ_ERASED_RAM0		_BIT(26)
+#define NAND_IRQ_WR_RAM1		_BIT(25)
+#define NAND_IRQ_WR_RAM0		_BIT(24)
+#define NAND_IRQ_RD_RAM1		_BIT(23)
+#define NAND_IRQ_RD_RAM0		_BIT(22)
+#define NAND_IRQ_ECC_DEC_RAM0		_BIT(21)
+#define NAND_IRQ_ECC_ENC_RAM0		_BIT(20)
+#define NAND_IRQ_ECC_DEC_RAM1		_BIT(19)
+#define NAND_IRQ_ECC_ENC_RAM1		_BIT(18)
+#define NAND_IRQ_NOERR_RAM0		_BIT(17)
+#define NAND_IRQ_ERR1_RAM0		_BIT(16)
+#define NAND_IRQ_ERR2_RAM0		_BIT(15)
+#define NAND_IRQ_ERR3_RAM0		_BIT(14)
+#define NAND_IRQ_ERR4_RAM0		_BIT(13)
+#define NAND_IRQ_ERR5_RAM0		_BIT(12)
+#define NAND_IRQ_ERR_UNR_RAM0		_BIT(11)
+#define NAND_IRQ_NOERR_RAM1		_BIT(10)
+#define NAND_IRQ_ERR1_RAM1		_BIT(9)
+#define NAND_IRQ_ERR2_RAM1		_BIT(8)
+#define NAND_IRQ_ERR3_RAM1		_BIT(7)
+#define NAND_IRQ_ERR4_RAM1		_BIT(6)
+#define NAND_IRQ_ERR5_RAM1		_BIT(5)
+#define NAND_IRQ_ERR_UNR_RAM1		_BIT(4)
+#define NAND_IRQ_AES_DONE_RAM1		_BIT(1)
+#define NAND_IRQ_AES_DONE_RAM0		_BIT(0)
+
+/**********************************************************************
+* Register description of config
+**********************************************************************/
+#define NAND_CFG_ECGC			_BIT(13)
+#define NAND_CFG_8BIT_ECC		_BIT(12)
+#define NAND_CFG_TL_528			_SBF(10, 0x0)
+#define NAND_CFG_TL_516			_SBF(10, 0x2)
+#define NAND_CFG_TL_512			_SBF(10, 0x3)
+#define NAND_CFG_TL_MASK		_SBF(10, 0x3)
+#define NAND_CFG_EO			_BIT(9)
+#define NAND_CFG_DC			_BIT(8)
+#define NAND_CFG_M			_BIT(7)
+#define NAND_CFG_LC_0			_SBF(5, 0x0)
+#define NAND_CFG_LC_1			_SBF(5, 0x1)
+#define NAND_CFG_LC_2			_SBF(5, 0x2)
+#define NAND_CFG_LC_MASK		_SBF(5, 0x3)
+#define NAND_CFG_ES			_BIT(4)
+#define NAND_CFG_DE			_BIT(3)
+#define NAND_CFG_AO			_BIT(2)
+#define NAND_CFG_WD			_BIT(1)
+#define NAND_CFG_EC			_BIT(0)
+
+/**********************************************************************
+* Register description of io_config
+**********************************************************************/
+#define NAND_IO_CFG_IO_DRIVE		_BIT(24)
+#define NAND_IO_CFG_DATA_DEF(n)		_SBF(8, ((n) & 0xFFFF))
+#define NAND_IO_CFG_CLE_1		_SBF(6, 0x01)
+#define NAND_IO_CFG_ALE_1		_SBF(4, 0x01)
+#define NAND_IO_CFG_WE_1		_SBF(2, 0x01)
+#define NAND_IO_CFG_RE_1		_SBF(0, 0x01)
+
+/**********************************************************************
+* Register description of timing1
+**********************************************************************/
+#define NAND_TIM1_TSRD(n)		_SBF(20, ((n) & 0x3))
+#define NAND_TIM1_TALS(n)		_SBF(16, ((n) & 0x7))
+#define NAND_TIM1_TALH(n)		_SBF(12, ((n) & 0x7))
+#define NAND_TIM1_TCLS(n)		_SBF(4, ((n) & 0x7))
+#define NAND_TIM1_TCLH(n)		((n) & 0x7)
+
+/**********************************************************************
+* Register description of timing2
+**********************************************************************/
+#define NAND_TIM2_TDRD(n)		_SBF(28, ((n) & 0x7))
+#define NAND_TIM2_TEBI(n)		_SBF(24, ((n) & 0x7))
+#define NAND_TIM2_TCH(n)		_SBF(20, ((n) & 0x7))
+#define NAND_TIM2_TCS(n)		_SBF(16, ((n) & 0x7))
+#define NAND_TIM2_TRH(n)		_SBF(12, ((n) & 0x7))
+#define NAND_TIM2_TRP(n)		_SBF(8, ((n) & 0x7))
+#define NAND_TIM2_TWH(n)		_SBF(4, ((n) & 0x7))
+#define NAND_TIM2_TWP(n)		((n) & 0x7)
+
+/**********************************************************************
+* Register description of set_ce
+**********************************************************************/
+#define NAND_SETCE_OVR_EN(n)		_BIT(((n) & 0x3) + 12)
+#define NAND_SETCE_OVR_V(n)		_BIT(((n) & 0x3) + 8)
+#define NAND_SETCE_WP			_BIT(4)
+#define NAND_SETCE_CV_MASK		0x0F
+#define NAND_SETCE_CV(n)		(0x0F & ~_BIT(((n) & 0x3)))
+
+/**********************************************************************
+* Register description of check_sts
+**********************************************************************/
+#define NAND_CHK_STS_RB4_EDGE		_BIT(8)
+#define NAND_CHK_STS_RB3_EDGE		_BIT(7)
+#define NAND_CHK_STS_RB2_EDGE		_BIT(6)
+#define NAND_CHK_STS_RB1_EDGE		_BIT(5)
+#define NAND_CHK_STS_RB4_LVL		_BIT(4)
+#define NAND_CHK_STS_RB3_LVL		_BIT(3)
+#define NAND_CHK_STS_RB2_LVL		_BIT(2)
+#define NAND_CHK_STS_RB1_LVL		_BIT(1)
+#define NAND_CHK_STS_APB_BSY		_BIT(0)
+
+/**********************************************************************
+* Register description of aes_from_ahb
+**********************************************************************/
+#define NAND_CTRL_WR_RAM1		_BIT(5)
+#define NAND_CTRL_WR_RAM0		_BIT(4)
+#define NAND_CTRL_RD_RAM1		_BIT(1)
+#define NAND_CTRL_RD_RAM0		_BIT(0)
+
+/**********************************************************************
+* Register description of control_flow
+**********************************************************************/
+#define NAND_AES_AHB_EN			_BIT(7)
+#define NAND_AES_AHB_DCRYPT_RAM1	_BIT(1)
+#define NAND_AES_AHB_DCRYPT_RAM0	_BIT(0)
+
+/* Macro pointing to CGU switch box registers */
+#define NAND_CTRL	((NAND_FLASH_CTRL_REGS_T *)(NANDFLASH_CTRL_CFG_BASE))
+
+unsigned int crc32_compute(unsigned char *data, int length);
+int prepare_write_nand_params_bbt(unsigned char isbooting);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* NAND_H */
diff --git a/arch/arm/include/asm/arch-lpc313x/sdmmc.h b/arch/arm/include/asm/arch-lpc313x/sdmmc.h
new file mode 100644
index 0000000..85a47f7
--- /dev/null
+++ b/arch/arm/include/asm/arch-lpc313x/sdmmc.h
@@ -0,0 +1,322 @@
+/*
+ * (C) Copyright 2010 NXP Semiconductors
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef SDMMC_H
+#define SDMMC_H
+
+#if defined (__cplusplus)
+extern "C"
+{
+#endif
+
+/* 
+ * SD/MMC commands - this matrix shows the command, response types, and
+ * supported card type for that command.
+ * Command                 Number Resp  SD  MMC
+ * ----------------------- ------ ----- --- ---
+ * Reset (go idle)         CMD0   NA    x   x
+ * Send op condition       CMD1   R3        x
+ * All send CID            CMD2   R2    x   x
+ * Send relative address   CMD3   R1        x
+ * Send relative address   CMD3   R6    x
+ * Program DSR             CMD4   NA        x
+ * Select/deselect card    CMD7   R1b       x
+ * Select/deselect card    CMD7   R1    x
+ * Send CSD                CMD9   R2    x   x
+ * Send CID                CMD10  R2    x   x
+ * Read data until stop    CMD11  R1    x   x
+ * Stop transmission       CMD12  R1/b  x   x
+ * Send status             CMD13  R1    x   x
+ * Go inactive state       CMD15  NA    x   x
+ * Set block length        CMD16  R1    x   x
+ * Read single block       CMD17  R1    x   x
+ * Read multiple blocks    CMD18  R1    x   x
+ * Write data until stop   CMD20  R1        x
+ * Setblock count          CMD23  R1        x
+ * Write single block      CMD24  R1    x   x
+ * Write multiple blocks   CMD25  R1    x   x
+ * Program CID             CMD26  R1        x
+ * Program CSD             CMD27  R1    x   x
+ * Set write protection    CMD28  R1b   x   x
+ * Clear write protection  CMD29  R1b   x   x
+ * Send write protection   CMD30  R1    x   x
+ * Erase block start       CMD32  R1    x
+ * Erase block end         CMD33  R1    x
+ * Erase block start       CMD35  R1        x
+ * Erase block end         CMD36  R1        x
+ * Erase blocks            CMD38  R1b       x
+ * Fast IO                 CMD39  R4        x
+ * Go IRQ state            CMD40  R5        x
+ * Lock/unlock             CMD42  R1b       x
+ * Application command     CMD55  R1        x
+ * General command         CMD56  R1b       x
+ * SD card application commands - these must be preceded with
+ * MMC CMD55 application specific command first
+ * Set bus width           ACMD6  R1    x
+ * Send SD status          ACMD13 R1    x
+ * Send number WR blocks   ACMD22 R1    x
+ * Set WR block erase cnt  ACMD23 R1    x
+ * Send op condition       ACMD41 R3    x
+ * Set clear card detect   ACMD42 R1    x
+ * Send CSR                ACMD51 R1    x */
+typedef enum
+{
+	SDMMC_IDLE,		/* Put card in idle mode */
+	MMC_SENDOP_COND,	/* Send operating condition */
+	SDMMC_ALL_SEND_CID,	/* All cards send CID */
+	SDMMC_SRA,		/* Set relative address */
+	MMC_PROGRAM_DSR,	/* Program DSR */
+	SDMMC_SELECT_CARD,	/* Select card */
+	SDMMC_SEND_CSD,		/* Send CSD data */
+	SDMMC_SEND_CID,		/* Send CID register data (with rel.
+					addr) */
+	SDMMC_READ_UNTIL_STOP,	/* Read data until stop */
+	SDMMC_STOP_XFER,	/* Stop current transmission */
+	SDMMC_SSTAT,		/* Send status */
+	SDMMC_INACTIVE,		/* Put card in inactive state */
+	SDMMC_SET_BLEN,		/* Set block transfer length */
+	SDMMC_READ_SINGLE,	/* Read single block */
+	SDMMC_READ_MULTIPLE,	/* Read multiple blocks */
+	SDMMC_WRITE_UNTIL_STOP,	/* Write data until stop */
+	SDMMC_SET_BLOCK_COUNT,	/* Set block count */
+	SDMMC_WRITE_SINGLE,	/* Write single block */
+	SDMMC_WRITE_MULTIPLE,	/* Write multiple blocks */
+	MMC_PROGRAM_CID,	/* Program CID */
+	SDMMC_PROGRAM_CSD,	/* Program CSD */
+	SDMMC_SET_WR_PROT,	/* Set write protection */
+	SDMMC_CLEAR_WR_PROT,	/* Clear write protection */
+	SDMMC_SEND_WR_PROT,	/* Send write protection */
+	SD_ERASE_BLOCK_START,	/* Set starting erase block */
+	SD_ERASE_BLOCK_END,	/* Set ending erase block */
+	MMC_ERASE_BLOCK_START,	/* Set starting erase block */
+	MMC_ERASE_BLOCK_END,	/* Set ending erase block */
+	MMC_ERASE_BLOCKS,	/* Erase blocks */
+	MMC_FAST_IO,		/* Fast IO */
+	MMC_GO_IRQ_STATE,	/* Go into IRQ state */
+	MMC_LOCK_UNLOCK,	/* Lock/unlock */
+	SDMMC_APP_CMD,		/* Application specific command */
+	SDMMC_GEN_CMD,		/* General purpose command */
+	SDMMC_INVALID_CMD	/* Invalid SDMMC command */
+} SDMMC_COMMAND_T;
+
+/*
+ * SDMMC application specific commands for SD cards only - these must
+ * be preceded by the SDMMC CMD55 to work correctly
+ */
+typedef enum
+{
+	SD_SET_BUS_WIDTH,
+	SD_SEND_STATUS,
+	SD_SEND_WR_BLOCKS,
+	SD_SET_ERASE_COUNT,
+	SD_SENDOP_COND,
+	SD_CLEAR_CARD_DET,
+	SD_SEND_SCR,
+	SD_INVALID_APP_CMD
+} SD_APP_CMD_T;
+
+/* Possible SDMMC response types */
+typedef enum
+{
+	SDMMC_RESPONSE_R1,	/* Typical status */
+	SDMMC_RESPONSE_R1B,	/* Typical status with busy */
+	SDMMC_RESPONSE_R2,	/* CID/CSD registers (CMD2 and CMD10) */
+	SDMMC_RESPONSE_R3,	/* OCR register (CMD1, ACMD41) */
+	SDMMC_RESPONSE_R4,	/* Fast IO response word */
+	SDMMC_RESPONSE_R5,	/* Go IRQ state response word */
+	SDMMC_RESPONSE_R6,	/* Published RCA response */
+	SDMMC_RESPONSE_NONE	/* No response expected */
+} SDMMC_RESPONSE_T;
+
+/* Possible SDMMC card state types */
+typedef enum
+{
+	SDMMC_IDLE_ST = 0,
+	SDMMC_READY_ST,
+	SDMMC_IDENT_ST,
+	SDMMC_STBY_ST,
+	SDMMC_TRAN_ST,
+	SDMMC_DATA_ST,
+	SDMMC_RCV_ST,
+	SDMMC_PRG_ST,
+	SDMMC_DIS_ST
+} SDMMC_STATE_T;
+
+#if defined (__cplusplus)
+}
+#endif /*__cplusplus */
+
+/* Standard MMC commands (3.1) type argument response */
+/* class 1 */
+#define MMC_GO_IDLE_STATE		0	/* bc */
+#define MMC_SEND_OP_COND		1	/* bcr [31:0] OCR R3 */
+#define MMC_ALL_SEND_CID		2	/* bcr R2 */
+#define MMC_SET_RELATIVE_ADDR		3	/* ac [31:16] RCA R1 */
+#define MMC_SET_DSR			4	/* bc [31:16] RCA */
+#define MMC_SELECT_CARD			7	/* ac [31:16] RCA R1 */
+#define MMC_SEND_EXT_CSD		8	/* bc R1 */
+#define MMC_SEND_CSD			9	/* ac [31:16] RCA R2 */
+#define MMC_SEND_CID			10	/* ac [31:16] RCA R2 */
+#define MMC_STOP_TRANSMISSION		12	/* ac R1b */
+#define MMC_SEND_STATUS			13	/* ac [31:16] RCA R1 */
+#define MMC_GO_INACTIVE_STATE		15	/* ac [31:16] RCA */
+
+/* class 2 */
+#define MMC_SET_BLOCKLEN		16	/* ac [31:0] block len R1 */
+#define MMC_READ_SINGLE_BLOCK		17	/* adtc [31:0] data addr R1 */
+#define MMC_READ_MULTIPLE_BLOCK		18	/* adtc [31:0] data addr R1 */
+
+/* class 3 */
+#define MMC_WRITE_DAT_UNTIL_STOP	20	/* adtc [31:0] data addr R1 */
+
+/* class 4 */
+#define MMC_SET_BLOCK_COUNT		23	/* adtc [31:0] data addr R1 */
+#define MMC_WRITE_BLOCK			24	/* adtc [31:0] / data addr R1 */
+#define MMC_WRITE_MULTIPLE_BLOCK	25	/* adtc R1 */
+#define MMC_PROGRAM_CID			26	/* adtc R1 */
+#define MMC_PROGRAM_CSD			27	/* adtc R1 */
+
+/* class 6 */
+#define MMC_SET_WRITE_PROT		28	/* ac [31:0] data addr R1b */
+#define MMC_CLR_WRITE_PROT		29	/* ac [31:0] data addr R1b */
+#define MMC_SEND_WRITE_PROT		30	/* adtc [31:0] wpdata addr R1 */
+
+/* class 5 */
+#define MMC_ERASE_GROUP_START		35	/* ac [31:0] data addr R1 */
+#define MMC_ERASE_GROUP_END		36	/* ac [31:0] data addr R1 */
+#define MMC_ERASE			37	/* ac R1b */
+
+/* class 9 */
+#define MMC_FAST_IO			39	/* ac <Complex> R4 */
+#define MMC_GO_IRQ_STATE		40	/* bcr R5 */
+
+/* class 7 */
+#define MMC_LOCK_UNLOCK			42	/* adtc R1b */
+
+/* class 8 */
+#define MMC_APP_CMD			55	/* ac [31:16] RCA R1 */
+#define MMC_GEN_CMD			56	/* adtc [0] RD/WR R1b */
+
+/* SD commands type argument response */
+/* class 8 */
+/* This is basically the same command as for MMC with some quirks. */
+#define SD_SEND_RELATIVE_ADDR		3	/* ac R6 */
+#define SD_CMD8				8	/* bcr [31:0] OCR R3 */
+
+/* Application commands */
+#define SD_APP_SET_BUS_WIDTH		6	/* ac [1:0] bus width R1 */
+#define SD_APP_OP_COND			41	/* bcr [31:0] OCR R1 (R4) */
+#define SD_APP_SEND_SCR			51	 /* adtc R1 */
+
+/*
+  MMC status in R1
+  Type
+    e : error bit
+    s : status bit
+    r : detected and set for the actual command response
+    x : detected and set during command execution. the host must poll
+        the card by sending status command in order to read these bits.
+  Clear condition
+    a : according to the card state
+    b : always related to the previous command. Reception of
+        a valid command will clear it (with a delay of one command)
+    c : clear by read
+ */
+
+#define R1_OUT_OF_RANGE			_BIT(31)	/* er, c */
+#define R1_ADDRESS_ERROR		_BIT(30)	/* erx, c */
+#define R1_BLOCK_LEN_ERROR		_BIT(29)	/* er, c */
+#define R1_ERASE_SEQ_ERROR		_BIT(28)	/* er, c */
+#define R1_ERASE_PARAM			_BIT(27)	/* ex, c */
+#define R1_WP_VIOLATION			_BIT(26)	/* erx, c */
+#define R1_CARD_IS_LOCKED		_BIT(25)	/* sx, a */
+#define R1_LOCK_UNLOCK_FAILED		_BIT(24)	/* erx, c */
+#define R1_COM_CRC_ERROR		_BIT(23)	/* er, b */
+#undef R1_ILLEGAL_COMMAND
+#define R1_ILLEGAL_COMMAND		_BIT(22)	/* er, b */
+#define R1_CARD_ECC_FAILED		_BIT(21)	/* ex, c */
+#define R1_CC_ERROR			_BIT(20)	/* erx, c */
+#define R1_ERROR			_BIT(19)	/* erx, c */
+#define R1_UNDERRUN			_BIT(18)	/* ex, c */
+#define R1_OVERRUN			_BIT(17)	/* ex, c */
+#define R1_CID_CSD_OVERWRITE		_BIT(16)	/* erx, c, CID/CSD overwrite */
+#define R1_WP_ERASE_SKIP		_BIT(15)	/* sx, c */
+#define R1_CARD_ECC_DISABLED		_BIT(14)	/* sx, a */
+#define R1_ERASE_RESET			_BIT(13)	/* sr, c */
+#define R1_STATUS(x)			(x & 0xFFFFE000)
+#define R1_CURRENT_STATE(x)		((x & 0x00001E00) >> 9) /* sx, b (4 bits) */
+#define R1_READY_FOR_DATA		_BIT(8) /* sx, a */
+#undef R1_APP_CMD
+#define R1_APP_CMD			_BIT(5) /* sr, c */
+
+#define OCR_ALL_READY			_BIT(31)	/* Card Power up status bit */
+#define OCR_HC_CCS			_BIT(30)	/* High capacity card */
+#define OCR_VOLTAGE_RANGE_MSK		0x00ff8000
+
+#define SD_SEND_IF_ARG			0x000001AA
+#define SD_SEND_IF_ECHO_MSK		0x000000FF
+#define SD_SEND_IF_RESP			0x000000AA
+
+
+#define CMD_MASK_RESP			_SBF(28, 0x3)
+#define CMD_RESP(r)			_SBF(28, ((r) & 0x3))
+#define CMD_RESP_R0			_SBF(28, 0)
+#define CMD_RESP_R1			_SBF(28, 1)
+#define CMD_RESP_R2			_SBF(28, 2)
+#define CMD_RESP_R3			_SBF(28, 3)
+#define CMD_BIT_AUTO_STOP		_BIT(24)
+#define CMD_BIT_APP			_BIT(23)
+#define CMD_BIT_INIT			_BIT(22)
+#define CMD_BIT_BUSY			_BIT(21)
+#define CMD_BIT_LS			_BIT(20)	/* Low speed, used during acquire */
+#define CMD_BIT_DATA			_BIT(19)
+#define CMD_BIT_WRITE			_BIT(18)
+#define CMD_BIT_STREAM			_BIT(17)
+#define CMD_MASK_CMD			(0xff)
+#define CMD_SHIFT_CMD			(0)
+
+#define CMD(c,r)		( ((c) & CMD_MASK_CMD) | CMD_RESP((r)) )
+
+#define CMD_IDLE		CMD(MMC_GO_IDLE_STATE,0) | CMD_BIT_LS | CMD_BIT_INIT
+#define CMD_SD_OP_COND		CMD(SD_APP_OP_COND,1) | CMD_BIT_LS | CMD_BIT_APP
+#define CMD_SD_SEND_IF_COND	CMD(SD_CMD8,1) | CMD_BIT_LS
+#define CMD_MMC_OP_COND		CMD(MMC_SEND_OP_COND,3) | CMD_BIT_LS | CMD_BIT_INIT
+#define CMD_ALL_SEND_CID	CMD(MMC_ALL_SEND_CID,2) | CMD_BIT_LS
+#define CMD_MMC_SET_RCA		CMD(MMC_SET_RELATIVE_ADDR,1) | CMD_BIT_LS
+#define CMD_SD_SEND_RCA		CMD(SD_SEND_RELATIVE_ADDR,1) | CMD_BIT_LS
+#define CMD_SEND_CSD		CMD(MMC_SEND_CSD,2) | CMD_BIT_LS
+#define CMD_SEND_EXT_CSD	CMD(MMC_SEND_EXT_CSD,1) | CMD_BIT_LS | CMD_BIT_DATA
+#define CMD_DESELECT_CARD	CMD(MMC_SELECT_CARD,0)
+#define CMD_SELECT_CARD		CMD(MMC_SELECT_CARD,1)
+#define CMD_SET_BLOCKLEN	CMD(MMC_SET_BLOCKLEN,1)
+#define CMD_SEND_STATUS		CMD(MMC_SEND_STATUS,1)
+#define CMD_READ_SINGLE		CMD(MMC_READ_SINGLE_BLOCK,1) | CMD_BIT_DATA
+#define CMD_READ_MULTIPLE	CMD(MMC_READ_MULTIPLE_BLOCK,1) | CMD_BIT_DATA | CMD_BIT_AUTO_STOP
+#define CMD_SD_SET_WIDTH	CMD(SD_APP_SET_BUS_WIDTH,1)| CMD_BIT_APP
+#define CMD_STOP		CMD(MMC_STOP_TRANSMISSION,1) | CMD_BIT_BUSY
+#define CMD_WRITE_SINGLE	CMD(MMC_WRITE_BLOCK,1) | CMD_BIT_DATA | CMD_BIT_WRITE
+#define CMD_WRITE_MULTIPLE	CMD(MMC_WRITE_MULTIPLE_BLOCK,1) | CMD_BIT_DATA | \
+				CMD_BIT_WRITE | CMD_BIT_AUTO_STOP
+
+#define MMC_SECTOR_SIZE		512
+
+#endif /* SDMMC_H */
diff --git a/arch/arm/include/asm/arch-lpc313x/spi.h b/arch/arm/include/asm/arch-lpc313x/spi.h
new file mode 100644
index 0000000..dce4ae4
--- /dev/null
+++ b/arch/arm/include/asm/arch-lpc313x/spi.h
@@ -0,0 +1,211 @@
+/*
+ * (C) Copyright 2010 NXP Semiconductors
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef SPI_H
+#define SPI_H
+
+#include <common.h>
+#include <asm/arch/hardware.h>
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+/* SPI slave ids */
+typedef enum
+{
+	SPI_SLAVE1_ID = 0,
+	SPI_DEFAULT_ID = SPI_SLAVE1_ID,
+	SPI_SLAVE2_ID,
+	SPI_SLAVE3_ID,
+	SPI_INVALID_ID = 0xFF
+} SPI_SLAVE_ID_T;
+
+/* SPI transfer mode */
+typedef enum
+{
+	SPI_MODE0,
+	SPI_MODE1,
+	SPI_MODE2,
+	SPI_MODE3,
+	SSI_MODE
+} SPI_TRANS_MODE_T;
+
+/* Structure for setting up SPI parameters */
+typedef struct
+{
+	/* slave index */
+	SPI_SLAVE_ID_T sid;
+	/* Number of data bits, must be between 4 and 16 */
+	ulong databits;
+	/* Number of words required in sequential multi-slave transfer mode */
+	ulong words;
+	/* Transfer mode */
+	SPI_TRANS_MODE_T mode;
+	/* Flag used to set cs polarity high between frames */
+	ulong cs_high;
+	/* Post & pre transfer delay */
+	ulong pp_delay;
+	/* inter transfer delay */
+	ulong inter_delay;
+	/* Serial clock rate */
+	ulong clk;
+} SPI_SLAVE_CONFIG_T;
+
+/* SPI slave setting Register Structure */
+typedef volatile struct
+{
+	volatile ulong setting1;
+	volatile ulong setting2;
+} SPI_SLV_SETTING_T;
+
+/* Serial Peripheral Interface (SPI) Module Register Structure */
+typedef volatile struct
+{
+	volatile ulong spi_config;
+	volatile ulong slave_enable;
+	volatile ulong tx_fifo_flush;
+	volatile ulong fifo_data;
+	volatile ulong nhp_pop;
+	volatile ulong nhp_mode;
+	volatile ulong dma_settings;
+	volatile const ulong status;
+	volatile const ulong hw_info;
+	SPI_SLV_SETTING_T slv_setting[3];
+	volatile const ulong _reserved1[998];
+	volatile ulong int_threshold;
+	volatile ulong int_clr_enable;
+	volatile ulong int_set_enable;
+	volatile const ulong int_status;
+	volatile const ulong int_enable;
+	volatile ulong int_clr_status;
+	volatile ulong int_set_status;
+	volatile const ulong _reserved2[3];
+	volatile const ulong module_id;
+} SPI_REGS_T;
+/***********************************************************************
+ * SPI device contants
+ **********************************************************************/
+#define SPI_FIFO_DEPTH		64	/* 64 words (16bit) deep */
+#define SPI_NUM_SLAVES		3	/* number of slaves supported */
+#define SPI_MAX_DIV2		254
+#define SPI_MAX_DIVIDER		65024	/* = 254 * (255 + 1) */
+#define SPI_MIN_DIVIDER		2
+
+/***********************************************************************
+ * SPI Configuration register definitions
+ **********************************************************************/
+#define SPI_CFG_INTER_DLY(n)		_SBF(16, ((n) & 0xFFFF))
+#define SPI_CFG_INTER_DLY_GET(n)	(((n) >> 16) & 0xFFFF)
+#define SPI_CFG_UPDATE_EN		_BIT(7)
+#define SPI_CFG_SW_RESET		_BIT(6)
+#define SPI_CFG_SLAVE_DISABLE		_BIT(4)
+#define SPI_CFG_MULTI_SLAVE		_BIT(3)
+#define SPI_CFG_LOOPBACK		_BIT(2)
+#define SPI_CFG_SLAVE_MODE		_BIT(1)
+#define SPI_CFG_ENABLE			_BIT(0)
+/***********************************************************************
+ * SPI slave_enable register definitions
+ **********************************************************************/
+#define SPI_SLV_EN(n)			_SBF(((n) << 1), 0x1)
+#define SPI_SLV_SUSPEND(n)		_SBF(((n) << 1), 0x3)
+
+/***********************************************************************
+ * SPI tx_fifo_flush register definitions
+ **********************************************************************/
+#define SPI_TXFF_FLUSH			_BIT(1)
+
+/***********************************************************************
+ * SPI dma_settings register definitions
+ **********************************************************************/
+#define SPI_DMA_TX_EN			_BIT(1)
+#define SPI_DMA_RX_EN			_BIT(0)
+
+/***********************************************************************
+ * SPI status register definitions
+ **********************************************************************/
+#define SPI_ST_SMS_BUSY			_BIT(5)
+#define SPI_ST_BUSY			_BIT(4)
+#define SPI_ST_RX_FF			_BIT(3)
+#define SPI_ST_RX_EMPTY			_BIT(2)
+#define SPI_ST_TX_FF			_BIT(1)
+#define SPI_ST_TX_EMPTY			_BIT(0)
+
+/***********************************************************************
+ * SPI slv_setting registers definitions
+ **********************************************************************/
+#define SPI_SLV1_INTER_TX_DLY(n)	_SBF(24, ((n) & 0xFF))
+#define SPI_SLV1_NUM_WORDS(n)		_SBF(16, ((n) & 0xFF))
+#define SPI_SLV1_CLK_PS(n)		_SBF(8, ((n) & 0xFF))
+#define SPI_SLV1_CLK_PS_GET(n)		(((n) >> 8) & 0xFF)
+#define SPI_SLV1_CLK_DIV1(n)		((n) & 0xFF)
+#define SPI_SLV1_CLK_DIV1_GET(n)	((n) & 0xFF)
+
+#define SPI_SLV2_PPCS_DLY(n)		_SBF(9, ((n) & 0xFF))
+#define SPI_SLV2_CS_HIGH		_BIT(8)
+#define SPI_SLV2_SSI_MODE		_BIT(7)
+#define SPI_SLV2_SPO			_BIT(6)
+#define SPI_SLV2_SPH			_BIT(5)
+#define SPI_SLV2_WD_SZ(n)		((n) & 0x1F)
+
+/***********************************************************************
+ * SPI int_threshold registers definitions
+ **********************************************************************/
+#define SPI_INT_TSHLD_TX		_SBF(8, ((n) & 0xFF))
+#define SPI_INT_TSHLD_RX		((n) & 0xFF)
+
+/***********************************************************************
+ * SPI intterrupt registers definitions
+ **********************************************************************/
+#define SPI_SMS_INT			_BIT(4)
+#define SPI_TX_INT			_BIT(3)
+#define SPI_RX_INT			_BIT(2)
+#define SPI_OVR_INT			_BIT(0)
+#define SPI_ALL_INTS			(SPI_SMS_INT | SPI_TX_INT | \
+					SPI_RX_INT | SPI_OVR_INT)
+
+/*
+ * SPI write function - the buffer must be aligned on a 16-bit
+ * boundary if the data size is 9 bits or more
+ */
+long spi_write(void *buffer, long n_fifo);
+
+/*
+ * SPI read function - the buffer must be aligned on a 16-bit
+ * boundary if the data size is 9 bits or more
+ */
+long spi_read(void *buffer, long max_fifo);
+
+long lpc313x_spi_init(void);
+long lpc313x_setup_slave(SPI_SLAVE_CONFIG_T *cfg);
+void spi_flush_rx_fifo(void);
+void spi_flush_tx_fifo(void);
+unsigned int spi_get_status(void);
+void spinor_cs_low(void);
+void spinor_cs_high(void);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* SPI_H */
diff --git a/arch/arm/include/asm/arch-lpc313x/sys_proto.h b/arch/arm/include/asm/arch-lpc313x/sys_proto.h
new file mode 100644
index 0000000..bac5e79
--- /dev/null
+++ b/arch/arm/include/asm/arch-lpc313x/sys_proto.h
@@ -0,0 +1,27 @@
+/*
+ * Copyright (C) ST-Ericsson SA 2010
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+#ifndef _SYS_PROTO_H_
+#define _SYS_PROTO_H_
+
+void gpio_init(void);
+
+#endif  /* _SYS_PROTO_H_ */
diff --git a/arch/arm/include/asm/arch-lpc313x/sysreg.h b/arch/arm/include/asm/arch-lpc313x/sysreg.h
new file mode 100644
index 0000000..a81ad79
--- /dev/null
+++ b/arch/arm/include/asm/arch-lpc313x/sysreg.h
@@ -0,0 +1,197 @@
+/*
+ * (C) Copyright 2010 NXP Semiconductors
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef SYSREG_H
+#define SYSREG_H
+
+#include <common.h>
+#include <asm/arch/hardware.h>
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+/***********************************************************************
+* System Control (SysCReg) Register Structures
+**********************************************************************/
+typedef volatile struct
+{
+	volatile ulong spare_reg0;
+	volatile ulong activate_testpins;
+	volatile ulong ebi_ip2024_1;
+	volatile ulong ebi_ip2024_2;
+	volatile ulong ebi_ip2024_3;
+	volatile ulong ccp_ring_osc_cfg;
+	volatile ulong ssa1_adc_pd_adc10bits;
+	volatile ulong cgu_dyn_hp0;
+	volatile ulong cgu_dyn_hp1;
+	volatile ulong abc_cfg;
+	volatile ulong sd_mmc_cfg;
+	volatile ulong mci_delaymodes;
+	volatile ulong usb_atx_pll_pd_reg;
+	volatile ulong usb_otg_cfg;
+	volatile ulong usb_otg_port_ind_ctl;
+	volatile ulong sys_usb_tpr_dyn;
+	volatile ulong usb_pll_ndec;
+	volatile ulong usb_pll_mdec;
+	volatile ulong usb_pll_pdec;
+	volatile ulong usb_pll_selr;
+	volatile ulong usb_pll_seli;
+	volatile ulong usb_pll_selp;
+	volatile ulong isram0_latency_cfg;
+	volatile ulong isram1_latency_cfg;
+	volatile ulong isrom_latency_cfg;
+	volatile ulong ahb_mpmc_pl172_misc;
+	volatile ulong mpmp_delaymodes;
+	volatile ulong mpmc_waitread_delay0;
+	volatile ulong mpmc_waitread_delay1;
+	volatile ulong wire_ebi_msize_init;
+	volatile ulong mpmc_testmode0;
+	volatile ulong mpmc_testmode1;
+	volatile ulong ahb0_extprio;
+	volatile ulong arm926_shadow_pointer;
+	volatile ulong sleepstatus;
+	volatile ulong chip_id;
+	volatile ulong mux_lcd_ebi_sel;
+	volatile ulong mux_gpio_mci_sel;
+	volatile ulong mux_nand_mci_sel;
+	volatile ulong mux_uart_spi_sel;
+	volatile ulong mux_dao_ipint_sel;
+	volatile ulong ebi_d_9_pctrl;
+	volatile ulong ebi_d_10_pctrl;
+	volatile ulong ebi_d_11_pctrl;
+	volatile ulong ebi_d_12_pctrl;
+	volatile ulong ebi_d_13_pctrl;
+	volatile ulong ebi_d_14_pctrl;
+	volatile ulong dai_bck0_pctrl;
+	volatile ulong mgpio9_pctrl;
+	volatile ulong mgpio6_pctrl;
+	volatile ulong mlcd_db_7_pctrl;
+	volatile ulong mlcd_db_4_pctrl;
+	volatile ulong mlcd_db_2_pctrl;
+	volatile ulong mnand_rybn0_pctrl;
+	volatile ulong gpio1_pctrl;
+	volatile ulong ebi_d_4_pctrl;
+	volatile ulong mdao_clk0_pctrl;
+	volatile ulong mdao_bck0_pctrl;
+	volatile ulong ebi_a_1_cle_pctrl;
+	volatile ulong ebi_ncas_blout_0_pctrl;
+	volatile ulong nand_ncs_3_pctrl;
+	volatile ulong mlcd_db_0_pctrl;
+	volatile ulong ebi_dqm_0_noe_pctrl;
+	volatile ulong ebi_d_0_pctrl;
+	volatile ulong ebi_d_1_pctrl;
+	volatile ulong ebi_d_2_pctrl;
+	volatile ulong ebi_d_3_pctrl;
+	volatile ulong ebi_d_5_pctrl;
+	volatile ulong ebi_d_6_pctrl;
+	volatile ulong ebi_d_7_pctrl;
+	volatile ulong ebi_d_8_pctrl;
+	volatile ulong ebi_d_15_pctrl;
+	volatile ulong dao_data1_pctrl;
+	volatile ulong dao_bck1_pctrl;
+	volatile ulong dao_ws1_pctrl;
+	volatile ulong dai_data0_pctrl;
+	volatile ulong dai_ws0_pctrl;
+	volatile ulong dai_data1_pctrl;
+	volatile ulong dai_bck1_pctrl;
+	volatile ulong dai_ws1_pctrl;
+	volatile ulong sysclk_o_pctrl;
+	volatile ulong pwm_data_pctrl;
+	volatile ulong uart_rxd_pctrl;
+	volatile ulong uart_txd_pctrl;
+	volatile ulong i2c_sda1_pctrl;
+	volatile ulong i2c_scl1_pctrl;
+	volatile ulong clk_256fs_o_pctrl;
+	volatile ulong gpio0_pctrl;
+	volatile ulong gpio2_pctrl;
+	volatile ulong gpio3_pctrl;
+	volatile ulong gpio4_pctrl;
+	volatile ulong gpio_tst_0_dd_pctrl;
+	volatile ulong gpio_tst_1_dd_pctrl;
+	volatile ulong gpio_tst_2_dd_pctrl;
+	volatile ulong gpio_tst_3_dd_pctrl;
+	volatile ulong gpio_tst_4_dd_pctrl;
+	volatile ulong gpio_tst_5_dd_pctrl;
+	volatile ulong gpio_tst_6_dd_pctrl;
+	volatile ulong gpio_tst_7_dd_pctrl;
+	volatile ulong ad_nint_i_pctrl;
+	volatile ulong play_det_i_pctrl;
+	volatile ulong spi_miso_pctrl;
+	volatile ulong spi_mosi_pctrl;
+	volatile ulong spi_cs_in_pctrl;
+	volatile ulong spi_sck_pctrl;
+	volatile ulong spi_cs_out0_pctrl;
+	volatile ulong nand_ncs_0_pctrl;
+	volatile ulong nand_ncs_1_pctrl;
+	volatile ulong nand_ncs_2_pctrl;
+	volatile ulong mlcd_csb_pctrl;
+	volatile ulong mlcd_db_1_pctrl;
+	volatile ulong mlcd_e_rd_pctrl;
+	volatile ulong mlcd_rs_pctrl;
+	volatile ulong mlcd_rw_wr_pctrl;
+	volatile ulong mlcd_db_3_pctrl;
+	volatile ulong mlcd_db_5_pctrl;
+	volatile ulong mlcd_db_6_pctrl;
+	volatile ulong mlcd_db_8_pctrl;
+	volatile ulong mlcd_db_9_pctrl;
+	volatile ulong mlcd_db_10_pctrl;
+	volatile ulong mlcd_db_11_pctrl;
+	volatile ulong mlcd_db_12_pctrl;
+	volatile ulong mlcd_db_13_pctrl;
+	volatile ulong mlcd_db_14_pctrl;
+	volatile ulong mlcd_db_15_pctrl;
+	volatile ulong mgpio5_pctrl;
+	volatile ulong mgpio7_pctrl;
+	volatile ulong mgpio8_pctrl;
+	volatile ulong mgpio10_pctrl;
+	volatile ulong mnand_rybn1_pctrl;
+	volatile ulong mnand_rybn2_pctrl;
+	volatile ulong mnand_rybn3_pctrl;
+	volatile ulong muart_cts_n_pctrl;
+	volatile ulong muart_rts_n_pctrl;
+	volatile ulong mdao_data0_pctrl;
+	volatile ulong mdao_ws0_pctrl;
+	volatile ulong ebi_nras_blout_1_pctrl;
+	volatile ulong ebi_a_0_ale_pctrl;
+	volatile ulong ebi_nwe_pctrl;
+	volatile ulong eshctrl_sup4;
+	volatile ulong eshctrl_sup8;
+} SYSCREG_REGS_T;
+
+/***********************************************************************
+ * SYSREGS Pad control register definitions
+ **********************************************************************/
+#define SYSREG_PCTRL_PULLUP	_SBF(1, 0x00)
+#define SYSREG_PCTRL_PULLDOWN	_SBF(1, 0x03)
+#define SYSREG_PCTRL_RPTR	_SBF(1, 0x01)
+#define SYSREG_PCTRL_INPUT	_SBF(1, 0x02)
+
+/* Macro pointing to SysRegs registers */
+#define SYS_REGS	((SYSCREG_REGS_T *)(SYSCREG_BASE))
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* SYSREG_H */
diff --git a/arch/arm/include/asm/arch-lpc313x/timer.h b/arch/arm/include/asm/arch-lpc313x/timer.h
new file mode 100644
index 0000000..2b03e5d
--- /dev/null
+++ b/arch/arm/include/asm/arch-lpc313x/timer.h
@@ -0,0 +1,67 @@
+/*
+ * (C) Copyright 2010 NXP Semiconductors
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef TIMER_H
+#define TIMER_H
+
+#include <common.h>
+#include <asm/arch/hardware.h>
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+/* Timer Module Register Structure */
+typedef volatile struct
+{
+	volatile ulong load;
+	volatile const ulong value;
+	volatile ulong control;
+	volatile ulong clear;
+	volatile ulong test;
+} TIMER_REGS_T;
+
+/**********************************************************************
+*  Timer Control Register (TimerCtrl) (0x08) Read/Write
+**********************************************************************/
+#define TM_CTRL_ENABLE		_BIT(7)
+#define TM_CTRL_MODE		_BIT(6)
+#define TM_CTRL_PERIODIC	_BIT(6)
+#define TM_CTRL_PS1		_SBF(2, 0)
+#define TM_CTRL_PS16		_SBF(2, 1)
+#define TM_CTRL_PS256		_SBF(2, 2)
+#define TM_CTRL_PS_MASK		_SBF(2, 0x3)
+
+/**********************************************************************
+* Macro to access TIMER registers
+**********************************************************************/
+#define TIMER_CNTR0		((TIMER_REGS_T*)TIMER0_BASE)
+#define TIMER_CNTR1		((TIMER_REGS_T*)TIMER1_BASE)
+#define TIMER_CNTR2		((TIMER_REGS_T*)TIMER2_BASE)
+#define TIMER_CNTR3		((TIMER_REGS_T*)TIMER3_BASE)
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* TIMER_H */
diff --git a/arch/arm/include/asm/arch-lpc313x/uart.h b/arch/arm/include/asm/arch-lpc313x/uart.h
new file mode 100644
index 0000000..e2129ed
--- /dev/null
+++ b/arch/arm/include/asm/arch-lpc313x/uart.h
@@ -0,0 +1,207 @@
+/*
+ * (C) Copyright 2010 NXP Semiconductors
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef UART_H
+#define UART_H
+
+#include <common.h>
+#include <asm/arch/hardware.h>
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+/* UART Module Register Structure */
+typedef volatile struct
+{
+	volatile ulong dll_fifo;
+	volatile ulong dlm_ie;
+	volatile ulong iir_fcr;
+	volatile ulong lcr;
+	volatile ulong mcr;
+	volatile const ulong lsr;
+	volatile const ulong msr;
+	volatile ulong scr;
+	volatile ulong acr;
+	volatile ulong icr;
+	volatile ulong fdr;
+	volatile const ulong unused;
+	volatile ulong pop;
+	volatile ulong mode;
+	volatile const ulong unused1[999];
+	volatile const ulong cfg;
+	volatile ulong intce;
+	volatile ulong intse;
+	volatile const ulong ints;
+	volatile const ulong inte;
+	volatile ulong intcs;
+	volatile ulong intss;
+	volatile const ulong unused2[3];
+	volatile const ulong mid;
+} UART_REGS_T;
+
+/**********************************************************************
+ * dll and dlm register definitions
+ **********************************************************************/
+/* Macro for loading most and least significant halfs of divisors */
+#define UART_LOAD_DLL(div)	((div) & 0xFF)
+#define UART_LOAD_DLM(div)	(((div) >> 8) & 0xFF)
+
+/**********************************************************************
+* ie register definitions
+**********************************************************************/
+/* Bit for enabling the Auto-baud Time-Out interrupt */
+#define UART_IE_ABTO		_BIT(9)
+/* Bit for enabling the End of Auto-Baud interrupt */
+#define UART_IE_ABEO		_BIT(8)
+/* Bit for enabling the cts_ansignal transition interrupt */
+#define UART_IE_CTS		_BIT(7)
+/* Bit for enabling the Modem Status interrupt */
+#define UART_IE_MS		_BIT(3)
+/* Bit for enabling the RX line status interrupt(s) */
+#define UART_IE_RXLINE_STS	_BIT(2)
+/* Bit for enabling the transmit holding register empty interrupt */
+#define UART_IE_THRE		_BIT(1)
+/* Bit for enabling the receive data available (RDA) interrupt */
+#define UART_IE_RDA		_BIT(0)
+
+/**********************************************************************
+* iir register definitions
+**********************************************************************/
+/* Bit for the Auto-baud Time-Out interrupt status*/
+#define UART_IR_INT_ABTO	_BIT(9)
+/* Bit for the End of Auto-Baud interrupt status*/
+#define UART_IR_INT_ABEO	_BIT(8)
+/* Bit for masking interrupt pending status */
+#define UART_IIR_INT_PENDING	_BIT(0)
+/* Mask for getting interrupt source */
+#define UART_IIR_INTSRC_MASK	0xE
+/* Interrupt sources */
+#define UART_IIR_INTSRC_MS	0x0
+#define UART_IIR_INTSRC_THRE	0x2
+#define UART_IIR_INTSRC_RDA	0x4
+#define UART_IIR_INTSRC_RXLINE	0x6
+#define UART_IIR_INTSRC_CTI	0xC /* Character timeout */
+
+
+/**********************************************************************
+* fcr register definitions
+**********************************************************************/
+/* Receive FIFO trigger level selections */
+#define UART_FCR_RXFIFO_TL1	_SBF(6, 0)
+#define UART_FCR_RXFIFO_TL16	_SBF(6, 1)
+#define UART_FCR_RXFIFO_TL24	_SBF(6, 2)
+#define UART_FCR_RXFIFO_TL28	_SBF(6, 3)
+/* DMA mode select bit  */
+#define UART_FCR_DMA_MODE	_BIT(3)
+/* Clear TX FIFO bit */
+#define UART_FCR_TXFIFO_FLUSH	_BIT(2)
+/* Clear RX FIFO bit */
+#define UART_FCR_RXFIFO_FLUSH	_BIT(1)
+/* Enable FIFO bit  */
+#define UART_FCR_FIFO_EN	_BIT(0)
+
+/**********************************************************************
+* lcr register definitions
+**********************************************************************/
+/* Bit for enabling divisor latch and IER register */
+#define UART_LCR_DIVLATCH_EN	_BIT(7)
+/* Bit for enabling break transmission (forces TX low) */
+#define UART_LCR_BREAK_EN	 _BIT(6)
+/* Parity selection */
+#define UART_LCR_PARITY_ODD	0x0
+#define UART_LCR_PARITY_EVEN	_BIT(4)
+#define UART_LCR_PARITY_FORCE1	_BIT(5)
+#define UART_LCR_PARITY_FORCE0	(_BIT(5) | _BIT(4))
+/* Parity selection mask */
+#define UART_LCR_PARITY_MASK	(_BIT(5) | _BIT(4))
+/* Parity enable bit */
+#define UART_LCR_PARITY_ENABLE	_BIT(3)
+/* Stop bit selection */
+#define UART_LCR_STOP1BIT	0x0
+#define UART_LCR_STOP2BITS	_BIT(2)
+/* Word length selections */
+#define UART_LCR_WLEN_5BITS	_SBF(0, 0)
+#define UART_LCR_WLEN_6BITS	_SBF(0, 1)
+#define UART_LCR_WLEN_7BITS	_SBF(0, 2)
+#define UART_LCR_WLEN_8BITS	_SBF(0, 3)
+/* Word length mask */
+#define UART_LCR_WLEN_MASK	(_BIT(1) | _BIT(0))
+
+/**********************************************************************
+* mcr register definitions
+**********************************************************************/
+/* Bit for Auto-cts flow control enable */
+#define UART_MCR_AUTO_CTS	_BIT(7)
+/* Bit for Auto-rts flow control enable */
+#define UART_MCR_AUTO_RTS	_BIT(6)
+/* Bit for Loop-back mode enable */
+#define UART_MCR_LOOP		_BIT(4)
+/* Bit for Inverse control for the out2_n output */
+#define UART_MCR_OUT2		_BIT(3)
+/* Bit for Inverse control for the out1_n output */
+#define UART_MCR_OUT1		_BIT(2)
+/* Bit for inverse control for the rts_n output */
+#define UART_MCR_RTS		_BIT(1)
+/* Bit for Inverse control for the Data Terminal Ready output */
+#define UART_MCR_DTS		_BIT(0)
+
+/**********************************************************************
+* lsr register definitions
+**********************************************************************/
+/* FIFO RX error status */
+#define UART_LSR_FIFORX_ERR	_BIT(7)
+/* transmitter empty status */
+#define UART_LSR_TEMT		_BIT(6)
+/* transmitter Holding Register empty status */
+#define UART_LSR_THRE		_BIT(5)
+/* break interrupt status */
+#define UART_LSR_BI		_BIT(4)
+/* framing error status */
+#define UART_LSR_FR		_BIT(3)
+/* parity error status */
+#define UART_LSR_PE		_BIT(2)
+/* RX FIFO overrun error status */
+#define UART_LSR_OE		_BIT(1)
+/* RX FIFO empty status */
+#define UART_LSR_RDR		_BIT(0)
+
+/**********************************************************************
+* FDR register definitions
+**********************************************************************/
+/* Macro for loading most and least significant halfs of divisors */
+#define UART_FDR_MUL_GET(div)		(((div) >> 4) & 0xF)
+#define UART_FDR_DIVADD_GET(div)	((div) & 0xF)
+#define UART_FDR_MUL_SET(div)		_SBF(4, ((div) & 0xF))
+#define UART_FDR_DIVADD_SET(div)	((div) & 0xF)
+
+/**********************************************************************
+* Macro to access UART registers
+**********************************************************************/
+#define UART	((UART_REGS_T *) UART_BASE)
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* UART_H */
diff --git a/arch/arm/include/asm/mach-types.h b/arch/arm/include/asm/mach-types.h
index 2d5c3bc..d992d4f 100644
--- a/arch/arm/include/asm/mach-types.h
+++ b/arch/arm/include/asm/mach-types.h
@@ -11,6 +11,9 @@
 extern unsigned int __machine_arch_type;
 #endif
 
+#define MACH_TYPE_EA3152               9996
+#define MACH_TYPE_EA313X               9997
+
 /* see arch/arm/kernel/arch.c for a description of these */
 #define MACH_TYPE_EBSA110              0
 #define MACH_TYPE_RISCPC               1
@@ -14222,6 +14225,30 @@ extern unsigned int __machine_arch_type;
 # define machine_is_omap5_sevm()      (0)
 #endif
 
+#ifdef CONFIG_MACH_EA313X
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EA313X
+# endif
+# define machine_is_ea313x()	(machine_arch_type == MACH_TYPE_EA313X)
+#else
+# define machine_is_ea313x()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EA3152
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EA3152
+# endif
+# define machine_is_ea3152()	(machine_arch_type == MACH_TYPE_EA3152)
+#else
+# define machine_is_ea3152()	(0)
+#endif
+
 /*
  * These have not yet been registered
  */
diff --git a/arch/arm/lib/board.c b/arch/arm/lib/board.c
index 3d78274..ab0dc86 100644
--- a/arch/arm/lib/board.c
+++ b/arch/arm/lib/board.c
@@ -38,6 +38,8 @@
  * FIQ Stack: 00ebef7c
  */
 
+#define DEBUG
+
 #include <common.h>
 #include <command.h>
 #include <malloc.h>
@@ -528,7 +530,6 @@ void board_init_r(gd_t *id, ulong dest_addr)
 	AT91F_DataflashInit();
 	dataflash_print_info();
 #endif
-
 	/* initialize environment */
 	env_relocate();
 
diff --git a/board/ElecArts/ea3131/Makefile b/board/ElecArts/ea3131/Makefile
new file mode 100644
index 0000000..e5a42d5
--- /dev/null
+++ b/board/ElecArts/ea3131/Makefile
@@ -0,0 +1,55 @@
+#
+# (C) Copyright 2003-2008
+# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+#
+# (C) Copyright 2008
+# Stelian Pop <stelian.pop@leadtechdesign.com>
+# Lead Tech Design <www.leadtechdesign.com>
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= $(obj)lib$(BOARD).o
+
+SOBJS	= lowlevel_init.o
+COBJS	:= ea3131.o
+
+SRCS	:= $(SOBJS:.o=.S) $(COBJS:.o=.c)
+OBJS	:= $(addprefix $(obj),$(COBJS))
+SOBJS	:= $(addprefix $(obj),$(SOBJS))
+
+$(LIB):	$(obj).depend $(OBJS) $(SOBJS)
+	$(call cmd_link_o_target, $(OBJS) $(SOBJS))
+
+clean:
+	rm -f $(SOBJS) $(OBJS)
+
+distclean:	clean
+	rm -f $(LIB) core *.bak $(obj).depend
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff --git a/board/ElecArts/ea3131/config.mk b/board/ElecArts/ea3131/config.mk
new file mode 100644
index 0000000..482a150
--- /dev/null
+++ b/board/ElecArts/ea3131/config.mk
@@ -0,0 +1 @@
+TEXT_BASE = 0x33600000
diff --git a/board/ElecArts/ea3131/ea3131.c b/board/ElecArts/ea3131/ea3131.c
new file mode 100644
index 0000000..dc09782
--- /dev/null
+++ b/board/ElecArts/ea3131/ea3131.c
@@ -0,0 +1,213 @@
+/*
+* (C) Copyright 2007-2008
+* Stelian Pop <stelian.pop@leadtechdesign.com>
+* Lead Tech Design <www.leadtechdesign.com>
+*
+* See file CREDITS for list of people who contributed to this
+* project.
+*
+* This program is free software; you can redistribute it and/or
+* modify it under the terms of the GNU General Public License as
+* published by the Free Software Foundation; either version 2 of
+* the License, or (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the Free Software
+* Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+* MA 02111-1307 USA
+*/
+
+#include <common.h>
+#include <asm/arch/hardware.h>
+#include <asm/arch/clock.h>
+#include <asm/arch/spi.h>
+#include <asm/arch/i2c.h>
+#include <net.h>
+#include <netdev.h>
+
+/* Event router macros */
+#define EVRT_VBUS_BANK                  3
+#define EVRT_VBUS_BIT			(1 << 23)
+
+
+#define PCA9532_SLAVE_ADDR		(0xC0)
+#define PCA9532_USB_VBUS_PWR_REG	0x07
+#define PCA9532_USB_VBUS_PWR_VAL	0x10
+
+DECLARE_GLOBAL_DATA_PTR;
+
+const SPI_SLAVE_CONFIG_T slavecfg =
+{
+	.sid = (SPI_SLAVE_ID_T)SPI_SLAVE1_ID,
+	.databits = 8,
+	.words = SPI_FIFO_DEPTH,
+	.mode = SPI_MODE0,
+	.cs_high = 0,
+	.pp_delay =0 ,
+	.inter_delay = 0,
+	.clk = 1000000
+};
+
+//extern int is_nand_init_done;
+//extern int is_spi_init_done;
+
+#ifdef CONFIG_DRIVER_DM9000
+int board_eth_init(bd_t *bis)
+{
+	return dm9000_initialize(bis);
+}
+#endif
+
+int misc_init_r(void)
+{
+	unsigned char i = 0;
+	unsigned char oft = 0;
+	uchar env_enetaddr[6];
+	char enetvar[32] = "ethaddr";
+	unsigned int rnd_num = 0;
+	char buf[32] = {0};
+
+	/*
+	* If "ethaddr" environment variable is 00:00:00:00:00:00,
+	* generate a random MAC address using Random Number Gen Module.
+	*/
+	eth_getenv_enetaddr(enetvar, env_enetaddr);
+	if((env_enetaddr[0] | env_enetaddr[1] | env_enetaddr[2] |
+		env_enetaddr[3] | env_enetaddr[4] | env_enetaddr[5]) == 0x0) {
+
+			/* Enable clock for Random Number Generator Module */
+			cgu_clk_en_dis(CGU_SB_RNG_PCLK_ID, 1);
+			rnd_num = *((volatile u32 *)(CIC_RNG_BASE));
+
+			env_enetaddr[0] = 0x00;
+			env_enetaddr[1] = 0x08;
+			for (i = 2; i < 6; i++) {
+				env_enetaddr[i] = ((rnd_num >> ((i - 2) * 8)) & 0xFF);
+			}
+
+			sprintf(buf,"%02x:%02x:%02x:%02x:%02x:%02x",
+				env_enetaddr[0], env_enetaddr[1],
+				env_enetaddr[2], env_enetaddr[3],
+				env_enetaddr[4], env_enetaddr[5]);
+			setenv(enetvar, buf);
+	}
+
+	/* fill device MAC address registers */
+	for (i = 0, oft = 0x10; i < 6; i++, oft++) {
+		*(volatile u8 *)DM9000_IO = oft;
+		*(volatile u8 *)DM9000_DATA = env_enetaddr[i];
+	}
+
+	for (i = 0, oft = 0x16; i < 8; i++, oft++) {
+		*(volatile u8 *)DM9000_IO = oft;
+		*(volatile u8 *)DM9000_DATA = 0xff;
+	}
+
+	return 0;
+}
+
+int board_init(void)
+{
+#ifdef CONFIG_EA3152
+	gd->bd->bi_arch_number = MACH_TYPE_EA3152;
+#else
+	gd->bd->bi_arch_number = MACH_TYPE_EA313X;
+#endif
+	/* adress of boot parameters */
+	gd->bd->bi_boot_params = PHYS_SDRAM + 0x100;
+
+#ifdef CONFIG_CMD_NAND
+	/* Initialize NAND device */
+//	if(is_nand_init_done == 0) {
+//		printf("\nNAND:  ");
+//		nand_init();
+//		is_nand_init_done = 1;
+//	}
+
+#endif
+
+#ifdef CONFIG_HARD_SPI
+	/* Inialize SPI NOR flash*/
+//	if(is_spi_init_done == 0) {
+//		spi_init();
+//		is_spi_init_done = 1;
+//	}
+#endif
+
+	/* Initialize I2C and also sets correct
+	* slave addresses for I2C0/I2C1 Controller
+	*/
+	i2c_init(CGU_SB_I2C0_PCLK_ID,I2C0_CTRL);
+#ifndef CONFIG_EA3152
+	i2c_init(CGU_SB_I2C1_PCLK_ID,I2C1_CTRL);
+#endif
+
+	/* for VBUS monitoring */
+	EVRT_ATR(EVRT_VBUS_BANK) &= ~EVRT_VBUS_BIT;
+	EVRT_APR(EVRT_VBUS_BANK) |= EVRT_VBUS_BIT;
+	lpc31xx_enable_vbus(1);
+	return 0;
+}
+
+int board_late_init(void)
+{
+#if CONFIG_CMD_NAND
+	prepare_write_nand_params_bbt(1);
+#endif
+}
+
+#ifdef CONFIG_USB_EHCI_LPC313X
+int lpc31xx_enable_vbus(int enable)
+{
+	static int init = 0;
+	int ret = 0;
+	printf("%s USB VBUS power..\n", (enable)?"Enabling":"Disabling");
+	if (enable) {
+		/* VBUS is wrong state */
+		if (EVRT_RSR(EVRT_VBUS_BANK) & EVRT_VBUS_BIT) {
+			/* level VBUS is already high. May be device
+			* cable is connected to PC.
+			*/
+			if (init == 0) {
+				printf("VBUS level is already high. Remove device cable"
+				" connected to mini-B connector and PC\n");
+				ret = -1;
+			}
+		} else {
+			/* enable VBUS power */
+			i2c_write(I2C0_CTRL, PCA9532_SLAVE_ADDR, PCA9532_USB_VBUS_PWR_REG, 
+				1, PCA9532_USB_VBUS_PWR_VAL, 1);
+			init = 1;
+			while (!(EVRT_RSR(EVRT_VBUS_BANK) & EVRT_VBUS_BIT)) {
+				udelay(1000);
+			}
+		}
+	} else {
+		/* disable VBUS power */
+		i2c_write(I2C0_CTRL, PCA9532_SLAVE_ADDR, PCA9532_USB_VBUS_PWR_REG, 
+			1, 0x00, 1);
+		init = 0;
+		while (EVRT_RSR(EVRT_VBUS_BANK) & EVRT_VBUS_BIT) {
+			udelay(1000);
+		}
+
+	}
+
+	return ret;
+}
+#endif
+
+/***********************************************************************/
+int dram_init(void)
+{
+	gd->ram_size = PHYS_SDRAM_SIZE;
+	gd->bd->bi_dram[0].start = PHYS_SDRAM;
+	gd->bd->bi_dram[0].size = PHYS_SDRAM_SIZE;
+	return 0;
+}
+
diff --git a/board/ElecArts/ea3131/lowlevel_init.S b/board/ElecArts/ea3131/lowlevel_init.S
new file mode 100644
index 0000000..1e276dd
--- /dev/null
+++ b/board/ElecArts/ea3131/lowlevel_init.S
@@ -0,0 +1,322 @@
+/*
+ * armboot - Startup Code for ARM926EJS CPU-core
+ * Based on cpu/arm926ejs/start.S
+ * 
+ * Copyright (c) 2010 NXP Semiconductors
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <config.h>
+#include <common.h>
+#include <version.h>
+#include <asm/arch/hardware.h>
+#include <asm/arch/clock.h>
+
+/*
+ * special lookup flags
+ */
+#define DO_MEM_DELAY	1
+#define DO_MEM_READ	2
+
+.globl lowlevel_init
+.type lowlevel_init,function
+lowlevel_init:
+#ifndef CONFIG_SPL_BUILD
+	mov	pc, lr		/* do nothing return */
+#else
+	/*
+	* Go setup Memory and board specific bits prior to relocation.
+	*/
+	ldr	sp, =(0x1103B000)
+	bic	sp, sp, #7 /* 8-byte alignment for ABI compliance */
+
+	stmfd	sp!, {ip, lr}
+	adr	r0, CGU_FDIV_REG_VALS
+	adr	r1, CGU_FDIV_CLKS
+	bl	init_clocks /* go setup pll,mux,memory */
+
+#ifdef CONFIG_EA3152
+	/*
+	 * For LPC3152 board, set IO voltage for 
+	 * SDRAM to work properly
+	 */
+	bl	setup_sdram_voltage
+#endif
+	/*
+	 * Setup Memory Controller & SDRAM Timing.
+	 */
+	bl	mpmc_sdram_init /* go setup pll,mux,memory */
+
+	/* Return to U-boot via saved link register */
+	ldmfd	sp!, {ip, pc}
+
+	/*
+	 *************************************************************************
+	 *
+	 * Initialize MPMC and SDRAM Timing registers
+	 *
+	 *************************************************************************
+	 */
+mpmc_sdram_init:
+	mov 	r9, lr
+	/* memory control configuration */
+	/* make r0 relative the current location so that it */
+	/* reads INITMEM_DATA out of FLASH rather than memory ! */
+	/*   r0 = current word pointer */
+	/*   r1 = end word location, one word past last actual word */
+	/*   r3 = address for writes, special lookup flags */
+	/*   r4 = value for writes, delay constants, or read addresses */
+	/*   r2 = location for mem reads */
+	adr 	r0, INITMEM_DATA
+	adr	r1, INITMEM_DATA_END
+
+mem_loop:
+	cmp	r1, r0
+	moveq	pc, r9		@ Done
+
+	ldr	r3, [r0], #4	@ Fetch Destination Register Address, or 1 for delay
+	ldr	r4, [r0], #4	@ value
+
+	cmp	r3, #DO_MEM_DELAY
+	bleq	mem_delay
+	beq	mem_loop
+	cmp	r3, #DO_MEM_READ
+	ldreq	r2, [r4]
+	beq	mem_loop
+	str	r4, [r3]	@ normal register/ram store
+	b	mem_loop
+
+mem_delay:
+	ldr	r5, =TIMER0_BASE
+	mov	r6, #0x88	    @ divide 6MHz clock by 256, enable
+	str	r6, [r5, #8]
+	ldr	r6, [r5, #4]    @load current counter
+	sub r4, r6, r4
+0:	ldr	r6, [r5, #4]	@ timer value
+	cmp	r6, r4
+	bhi	0b
+	mov	r6, #0		@ disable timer
+	str	r6, [r5, #8]
+	mov	pc, lr
+
+	.ltorg
+/* the literal pools origin */
+
+INITMEM_DATA:
+
+	.word	0x13002884 /*SYS_REMAP_ADDR: */
+	.word	0x11028000 
+	.word	0x13002890 /*SYS_MUX_LCD_EBI:*/
+	.word	0x00000001 
+	/* Enable External Memory Ctrl */
+	.word	0x17008000 /*MPMC_CTRL:*/
+	.word	0x1 
+	/* Force HCLK to MPMC_CLK to 1:1 ratio */
+	.word	0x17008008 /*MPMC_CONFIG:*/
+	.word	0x0 
+	/* Set MPMC delay gates appropriately based on trace lengths between
+	 SDRAM and the chip. Also based on the delay startergy used for SDRAM. */
+	.word	0x13002868 /*SYS_MPMC_DELAY:*/
+	.word	0x824 
+	/* Initialize timings for LCD display, 16 bit */
+	.word	0x17008200 /*MPMC_STCONFIG0:*/
+	.word	0x81 
+	.word	0x17008204 /*MPMC_STWTWEN0:*/
+	.word	0x2 
+	.word	0x17008208 /*MPMC_STWTOEN0:*/
+	.word	0x1
+	.word	0x1700820C /*MPMC_STWTRD0:*/
+	.word	0x15
+	.word	0x17008210 /*MPMC_STWTPG0:*/
+	.word	0x2
+	.word	0x17008214 /*MPMC_STWTWR0:*/
+	.word	0x4
+	.word	0x17008218 /*MPMC_STWTTURN0:*/
+	.word	0x2
+
+	/* Initialize timings for Ethernet DM9000, 16 bit */
+	.word	0x17008220 /*MPMC_STCONFIG1:*/
+	.word	0x81
+	.word	0x17008224 /*MPMC_STWTWEN1:*/
+	.word	0x1
+	.word	0x17008228 /*MPMC_STWTOEN1:*/
+	.word	0x1
+	.word	0x1700822C /*MPMC_STWTRD1:*/
+	.word	0x4
+	.word	0x17008230 /*MPMC_STWTPG1:*/
+	.word	0x1
+	.word	0x17008234 /*MPMC_STWTWR1:*/
+	.word	0x1
+	.word	0x17008238 /*MPMC_STWTTURN1:*/
+	.word	0x2
+	/* Put Delay of 100us */
+	.word	DO_MEM_DELAY
+	.word	4
+	/* Set command delay startergy */
+	.word	0x17008028 /*MPMC_DYRDCFG:*/
+	.word	0x1
+	/* Configure "device config register" nSDCE0 for proper width
+	 * SDRAM 
+	 */
+	.word	0x17008100 /*MPMC_DYCONFIG:*/
+	.word	0x880
+	.word	0x17008104 /*MPMC_DYRASCAS:*/
+	.word	0x202
+	/* Minimum 20ns program 1 so that atleast 2 HCLKs are used */
+	.word	0x17008030 /*MPMC_DYTRP:*/
+	.word	0x2
+	.word	0x17008034 /*MPMC_DYTRAS:*/
+	.word	0x4
+	.word	0x17008038 /*MPMC_DYTSREX:*/
+	.word	0x7
+	.word	0x1700803C /*MPMC_DYTAPR:*/
+	.word	0x4
+	.word	0x17008040 /*MPMC_DYTDAL:*/
+	.word	0x5
+	.word	0x17008044 /*MPMC_DYTWR:*/
+	.word	0x7
+	.word	0x17008048 /*MPMC_DYTRC:*/
+	.word	0x6
+	.word	0x1700804C /*MPMC_DYTRFC:*/
+	.word	0x6
+	.word	0x17008050 /*MPMC_DYTXSR:*/
+	.word	0x7
+	.word	0x17008054 /*MPMC_DYTRRD:*/
+	.word	0x1
+	.word	0x17008058 /*MPMC_DYTMRD:*/
+	.word	0x2
+	/* Put delay 100us */
+	.word	DO_MEM_DELAY
+	.word	4
+	/* Issue continuous NOP commands (INIT & MRS set) */
+	.word	0x17008020 /*MPMC_DYNCTL:*/
+	.word	0x183
+	/* Put delay 200us */
+	.word	DO_MEM_DELAY
+	.word	6
+	/* Issue a "pre-charge all" command */
+	.word	0x17008020
+	.word	0x103
+	/*******************************************************************
+	* Do at least 2 quick refresh cycles now.
+	******************************************************************/
+	.word	0x17008024 /*MPMC_DYNREF:*/
+	.word	0x1
+	/* Put delay 250us */
+	.word	DO_MEM_DELAY
+	.word	8
+	/*******************************************************************
+	* Set operational refersh rate.
+	******************************************************************/
+	.word	0x17008024 /*MPMC_DYNREF:*/
+	.word	0x2b
+	/* Select mode register update mode */
+	.word	0x17008020 /*MPMC_DYNCTL*/
+	.word	0x83
+	/*******************************************************************
+	* Program the SDRAM internal mode registers with CAS latency.
+	******************************************************************/
+	.word DO_MEM_READ
+	.word 0x30046000
+
+	/* Select normal operating mode */
+	.word	0x17008020 /*MPMC_DYNCTL:*/
+	.word	0x3
+
+	/* Enable buffer */
+	.word	0x17008100 /*MPMC_DYCONFIG:*/
+	.word	0x80880
+	.word	0x17008020 /*MPMC_DYNCTL: */
+	.word	0x0
+
+	/* program external refresh controller */
+	.word   0x13002878  /* SYSCREG_MPMC_TESTMODE0 */
+	.word   SYSREG_TEST0_VAL         
+	.word   0x1300287c  /*SYSCREG_MPMC_TESTMODE1 */
+	.word   SYSREG_TEST1_VAL        
+
+INITMEM_DATA_END:
+CGU_FDIV_REG_VALS:
+	.word	CGU_DEF_FDIV0_VAL	 
+	.word	CGU_DEF_FDIV1_VAL
+	.word	CGU_DEF_FDIV2_VAL
+	.word	CGU_DEF_FDIV3_VAL
+	.word	CGU_DEF_FDIV4_VAL
+	.word	CGU_DEF_FDIV5_VAL
+	.word	CGU_DEF_FDIV6_VAL
+	.word	CGU_DEF_FDIV7_VAL
+	.word	CGU_DEF_FDIV8_VAL
+	.word	CGU_DEF_FDIV9_VAL
+	.word	CGU_DEF_FDIV10_VAL
+	.word	CGU_DEF_FDIV11_VAL
+	.word	CGU_DEF_FDIV12_VAL
+	.word	CGU_DEF_FDIV13_VAL
+	.word	CGU_DEF_FDIV14_VAL
+	.word	CGU_DEF_FDIV15_VAL
+	.word	CGU_DEF_FDIV16_VAL
+	.word	CGU_DEF_FDIV17_VAL
+	.word	CGU_DEF_FDIV18_VAL
+	.word	CGU_DEF_FDIV19_VAL
+	.word	CGU_DEF_FDIV20_VAL
+	.word	CGU_DEF_FDIV21_VAL
+	.word	CGU_DEF_FDIV22_VAL
+	.word	CGU_DEF_FDIV23_VAL
+	.word	CGU_DEF_DYNFDIV0_VAL
+	.word	CGU_DEF_DYNFDIV1_VAL
+	.word	CGU_DEF_DYNFDIV2_VAL
+	.word	CGU_DEF_DYNFDIV3_VAL
+	.word	CGU_DEF_DYNFDIV4_VAL
+	.word	CGU_DEF_DYNFDIV5_VAL
+	.word	CGU_DEF_DYNFDIV6_VAL
+
+CGU_FDIV_CLKS:
+	.word	CGU_DEF_DOMAIN0_DIV0	 
+	.word	CGU_DEF_DOMAIN0_DIV1
+	.word	CGU_DEF_DOMAIN0_DIV2
+	.word	CGU_DEF_DOMAIN0_DIV3
+	.word	CGU_DEF_DOMAIN0_DIV4
+	.word	CGU_DEF_DOMAIN0_DIV5
+	.word	CGU_DEF_DOMAIN0_DIV6
+	.word	CGU_DEF_DOMAIN1_DIV7	 
+	.word	CGU_DEF_DOMAIN1_DIV8
+	.word	CGU_DEF_DOMAIN2_DIV9
+	.word	CGU_DEF_DOMAIN2_DIV10
+	.word	CGU_DEF_DOMAIN3_DIV11
+	.word	CGU_DEF_DOMAIN3_DIV12
+	.word	CGU_DEF_DOMAIN3_DIV13
+	.word	CGU_DEF_DOMAIN4_DIV14	 
+	.word	CGU_DEF_DOMAIN5_DIV15
+	.word	CGU_DEF_DOMAIN6_DIV16
+	.word	CGU_DEF_DOMAIN7_DIV17
+	.word	CGU_DEF_DOMAIN7_DIV18
+	.word	CGU_DEF_DOMAIN7_DIV19
+	.word	CGU_DEF_DOMAIN7_DIV20
+	.word	CGU_DEF_DOMAIN7_DIV21
+	.word	CGU_DEF_DOMAIN7_DIV22
+	.word	CGU_DEF_DOMAIN10_DIV23
+	.word	CGU_DEF_DYNFDIV0_CFG
+	.word	CGU_DEF_DYNFDIV1_CFG
+	.word	CGU_DEF_DYNFDIV2_CFG
+	.word	CGU_DEF_DYNFDIV3_CFG
+	.word	CGU_DEF_DYNFDIV4_CFG
+	.word	CGU_DEF_DYNFDIV5_CFG
+	.word	CGU_DEF_DYNFDIV6_CFG
+#endif
+
diff --git a/boards.cfg b/boards.cfg
index 1e5b3e0..77c385f 100644
--- a/boards.cfg
+++ b/boards.cfg
@@ -153,6 +153,8 @@ openrd_ultimate              arm         arm926ejs   openrd              Marvell
 rd6281a                      arm         arm926ejs   -                   Marvell        kirkwood
 sheevaplug                   arm         arm926ejs   -                   Marvell        kirkwood
 dockstar                     arm         arm926ejs   -                   Seagate        kirkwood
+ea3131                       arm         arm926ejs   ea3131              ElecArts       lpc313x
+ea3152                       arm         arm926ejs   ea3131              ElecArts       lpc313x
 jadecpu                      arm         arm926ejs   jadecpu             syteco         mb86r0x
 mx25pdk                      arm         arm926ejs   mx25pdk             freescale      mx25		mx25pdk:IMX_CONFIG=board/freescale/mx25pdk/imximage.cfg
 tx25                         arm         arm926ejs   tx25                karo           mx25
diff --git a/common/Makefile b/common/Makefile
index 2d9ae8c..9819d0a 100644
--- a/common/Makefile
+++ b/common/Makefile
@@ -26,12 +26,14 @@ include $(TOPDIR)/config.mk
 LIB	= $(obj)libcommon.o
 
 # core
+COBJS-y += dlmalloc.o
+COBJS-y += image.o
+
 ifndef CONFIG_SPL_BUILD
 COBJS-y += main.o
 COBJS-y += command.o
 COBJS-y += exports.o
 COBJS-$(CONFIG_SYS_HUSH_PARSER) += hush.o
-COBJS-y += image.o
 COBJS-y += s_record.o
 COBJS-$(CONFIG_SERIAL_MULTI) += serial.o
 COBJS-y += xyzModem.o
diff --git a/common/cmd_nand.c b/common/cmd_nand.c
index 3e2edb8..4cdf58a 100644
--- a/common/cmd_nand.c
+++ b/common/cmd_nand.c
@@ -189,12 +189,25 @@ static int arg_off(const char *arg, int *idx, loff_t *off, loff_t *maxsize)
 static int arg_off_size(int argc, char *const argv[], int *idx,
 			loff_t *off, loff_t *size)
 {
-	int ret;
+	int ret = 0;
 	loff_t maxsize;
 
 	if (argc == 0) {
 		*off = 0;
 		*size = nand_info[*idx].size;
+#ifdef CONFIG_LPC313X
+		printf("\nFor LPC313X based board, Do you want to erase block 0: <y/n>\n");
+		while(1) {
+			ret = getc();
+			if(ret != 0)	
+				break;
+		}
+
+		if(ret != 'y') {
+			*off = 0x20000;
+			*size -= 0x20000;
+		}
+#endif
 		goto print;
 	}
 
diff --git a/common/dlmalloc.c b/common/dlmalloc.c
index c645d73..9cef225 100644
--- a/common/dlmalloc.c
+++ b/common/dlmalloc.c
@@ -1521,11 +1521,13 @@ void *sbrk(ptrdiff_t increment)
 
 void mem_malloc_init(ulong start, ulong size)
 {
-	mem_malloc_start = start;
-	mem_malloc_end = start + size;
-	mem_malloc_brk = start;
+	if(mem_malloc_start == 0) {
+		mem_malloc_start = start;
+		mem_malloc_end = start + size;
+		mem_malloc_brk = start;
 
-	memset((void *)mem_malloc_start, 0, size);
+		memset((void *)mem_malloc_start, 0, size);
+	}
 }
 
 /* field-extraction macros */
diff --git a/drivers/mtd/nand/Makefile b/drivers/mtd/nand/Makefile
index 36ee454..887fac2 100644
--- a/drivers/mtd/nand/Makefile
+++ b/drivers/mtd/nand/Makefile
@@ -31,7 +31,7 @@ ifdef CONFIG_SPL_NAND_SIMPLE
 COBJS-y += nand_spl_simple.o
 endif
 ifdef CONFIG_SPL_NAND_LOAD
-COBJS-y	+= nand_spl_load.o
+COBJS-y += nand_spl_load.o
 endif
 else
 COBJS-y += nand.o
@@ -63,6 +63,7 @@ COBJS-$(CONFIG_NAND_SPEAR) += spr_nand.o
 COBJS-$(CONFIG_NAND_OMAP_GPMC) += omap_gpmc.o
 COBJS-$(CONFIG_NAND_PLAT) += nand_plat.o
 endif
+COBJS-$(CONFIG_NAND_LPC313X) += lpc313x_nand.o
 
 COBJS	:= $(COBJS-y)
 SRCS	:= $(COBJS:.o=.c)
diff --git a/drivers/mtd/nand/lpc313x_nand.c b/drivers/mtd/nand/lpc313x_nand.c
new file mode 100644
index 0000000..8508fc8
--- /dev/null
+++ b/drivers/mtd/nand/lpc313x_nand.c
@@ -0,0 +1,585 @@
+/*
+ * (C) Copyright 2010 NXP Semiconductors
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <asm/arch/sysreg.h>
+#include <asm/arch/nand.h>
+#include <asm/arch/clock.h>
+
+#include <common.h>
+#include <nand.h>
+
+#ifdef CONFIG_CMD_NAND
+
+#define OOB_FREE_OFFSET 4
+
+const struct lpc313x_nand_timing ea313x_nanddev_timing =
+{
+	.ns_trsd	= 36,
+	.ns_tals	= 36,
+	.ns_talh	= 12,
+	.ns_tcls	= 36,
+	.ns_tclh	= 12,
+	.ns_tdrd	= 36,
+	.ns_tebidel	= 12,
+	.ns_tch		= 12,
+	.ns_tcs		= 48,
+	.ns_treh	= 24,
+	.ns_trp		= 48,
+	.ns_trw		= 24,
+	.ns_twp		= 36
+};
+
+/*
+ * Autoplacement pattern for 2048+64 bytes large block NAND FLASH
+ */
+static const struct nand_ecclayout nand_hw_eccoob_64 =
+{
+	.eccbytes = 48,
+	.eccpos = {
+		4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
+		20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31,
+		36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,
+		52, 53, 54, 55, 56, 67, 58, 59, 60, 61, 62, 63
+	},
+	.oobfree = {
+		{0, 4},
+		{16, 4},
+		{32, 4},
+		{48, 4}
+	}
+};
+
+/*
+ * Bad block descriptors for small/large/huge block FLASH
+ * Hardware specific flash bbt decriptors
+ */
+static const uint8_t bbt_pattern[] = { 'B', 'b', 't', '0' };
+static const uint8_t mirror_pattern[] = { '1', 't', 'b', 'B' };
+
+static const struct nand_bbt_descr lpc313x_bbt_main_descr =
+{
+	.options = NAND_BBT_LASTBLOCK | NAND_BBT_CREATE | NAND_BBT_WRITE
+		| NAND_BBT_2BIT | NAND_BBT_VERSION | NAND_BBT_PERCHIP,
+	.offs = 32,
+	.len = 4,
+	.veroffs = 48,
+	.maxblocks = 4,
+	.pattern = bbt_pattern
+};
+
+static const struct nand_bbt_descr lpc313x_bbt_mirror_descr =
+{
+	.options = NAND_BBT_LASTBLOCK | NAND_BBT_CREATE | NAND_BBT_WRITE
+		| NAND_BBT_2BIT | NAND_BBT_VERSION | NAND_BBT_PERCHIP,
+	.offs = 32,
+	.len = 4,
+	.veroffs = 48,
+	.maxblocks = 4,
+	.pattern = mirror_pattern
+};
+
+/* Decode and encode buffer ECC status masks */
+static const u32 nand_buff_dec_mask[2] =
+{
+	NAND_IRQ_ECC_DEC_RAM0, NAND_IRQ_ECC_DEC_RAM1
+};
+static const u32 nand_buff_enc_mask[2] =
+{
+	NAND_IRQ_ECC_ENC_RAM0, NAND_IRQ_ECC_ENC_RAM1
+};
+static const u32 nand_buff_wr_mask[2] =
+{
+	NAND_IRQ_WR_RAM0, NAND_IRQ_WR_RAM1
+};
+
+/* Decode buffer addresses */
+static const void *nand_buff_addr[2] =
+{
+	(void *) NANDFLASH_CTRL_S0_BASE, (void *) (NANDFLASH_CTRL_S0_BASE + 0x400)
+};
+
+/*
+ * Dummies bytes for bad block ( just for HARDWARE ECC: inaccurate )
+ */
+static const uint8_t scan_ff_pattern[] = { 0xff, 0xff };
+
+static const struct nand_bbt_descr lpc313x_largepage_flashbased = 
+{
+	.options = NAND_BBT_SCAN2NDPAGE,
+	.offs = 50,
+	.len = 2,
+	.pattern = scan_ff_pattern
+};
+
+/***********************************************************************
+ * NAND driver private functions
+ **********************************************************************/
+
+/*
+ * Clear NAND interrupt status
+ */
+static inline void lpc313x_nand_int_clear(u32 mask)
+{
+	NAND_CTRL->irq_status_raw = mask;
+}
+
+/*
+ * Start a RAM read operation on RAM0 or RAM1
+ */
+static inline void lpc313x_ram_read(int bufnum)
+{
+	if (bufnum == 0) {
+		/* Use RAM buffer 0 */
+		NAND_CTRL->control_flow = NAND_CTRL_RD_RAM0;
+	}
+	else {
+		/* Use RAM buffer 1 */
+		NAND_CTRL->control_flow = NAND_CTRL_RD_RAM1;
+	}
+}
+
+/*
+ * Start a RAM write operation on RAM0 or RAM1
+ */
+static inline void lpc313x_ram_write(int bufnum)
+{
+	if (bufnum == 0) {
+		/* Use RAM buffer 0 */
+		NAND_CTRL->control_flow = NAND_CTRL_WR_RAM0;
+	}
+	else {
+		/* Use RAM buffer 1 */
+		NAND_CTRL->control_flow = NAND_CTRL_WR_RAM1;
+	}
+}
+
+/*
+ * MTD hardware ECC enable callback
+ */
+static void lpc313x_nand_enable_hwecc(struct mtd_info *mtd, int mode)
+{
+	(void) mtd;
+	(void) mode;
+
+	/* Nothing to really do here, ECC is enabled and used by default */
+}
+
+/*
+ * MTD ECC data correction callback
+ */
+static int lpc313x_nand_correct_data(struct mtd_info *mtd, u_char *dat,
+		u_char *read_ecc, u_char *calc_ecc)
+{
+	u32 tmp;
+	int errs_corrected = 0;
+
+	(void) mtd;
+	(void) dat;
+	(void) calc_ecc;
+
+	/* Data is corrected in hardware, just verify that data is correct per HW */
+	if (((NAND_CTRL->irq_status_raw) & NAND_IRQ_ERR_UNR_RAM0) &
+			(read_ecc[OOB_FREE_OFFSET] != 0xFF)) {
+		return -1;
+	}
+
+	/* Generate correction statistics */
+	tmp = NAND_CTRL->irq_status_raw;
+	if (!(tmp & (NAND_IRQ_NOERR_RAM0 | NAND_IRQ_NOERR_RAM1))) {
+		if (tmp & (NAND_IRQ_ERR1_RAM0 | NAND_IRQ_ERR1_RAM1)) {
+			errs_corrected = 1;
+		}
+		else if (tmp & (NAND_IRQ_ERR2_RAM0| NAND_IRQ_ERR2_RAM1)) {
+			errs_corrected = 2;
+		}
+		else if (tmp & (NAND_IRQ_ERR3_RAM0| NAND_IRQ_ERR3_RAM1)) {
+			errs_corrected = 3;
+		}
+		else if (tmp & (NAND_IRQ_ERR4_RAM0| NAND_IRQ_ERR4_RAM1)) {
+			errs_corrected = 4;
+		}
+		else if (tmp & (NAND_IRQ_ERR5_RAM0| NAND_IRQ_ERR5_RAM1)) {
+			errs_corrected = 5;
+		}
+
+		mtd->ecc_stats.corrected += errs_corrected;
+	}
+	else if (tmp & (NAND_IRQ_ERR_UNR_RAM0 | NAND_IRQ_ERR_UNR_RAM1)) {
+		mtd->ecc_stats.failed++;
+	}
+	return 0;
+}
+
+/*
+ * MTD calculate ECC callback
+ */
+static int lpc313x_nand_calculate_ecc(struct mtd_info *mtd, const u_char *dat, u_char *ecc_code)
+{
+	(void) mtd;
+	(void) dat;
+	(void) ecc_code;
+
+	/* ECC is calculated automatically in hardware, nothing to do */
+	return 0;
+}
+
+/*
+ * Read the payload and OOB data from the device in the hardware storage format
+ */
+int lpc313x_nand_read_page_syndrome(struct mtd_info *mtd, struct nand_chip *chip,
+		uint8_t *buf,int page)
+{
+	int i, curbuf = 0, bufrdy = 0, eccsize = chip->ecc.size;
+	int eccbytes = chip->ecc.bytes;
+	int eccsteps = chip->ecc.steps;
+	uint8_t *p = buf;
+	uint8_t *oob = chip->oob_poi;
+
+	for (i = 0; i < eccsteps; i++) {
+		/* Clear all current statuses */
+		lpc313x_nand_int_clear(~0);
+
+		/* Start read into RAM0 or RAM1 */
+		lpc313x_ram_read(curbuf);
+
+		/* Polling for buffer loaded and decoded */
+		while (!((NAND_CTRL->irq_status_raw) & nand_buff_dec_mask[curbuf]));
+
+		chip->ecc.correct(mtd, p, oob, NULL);
+
+		/* Read payload portion of the transfer */
+		memcpy((void *)p, nand_buff_addr[bufrdy], eccsize);
+		p += eccsize;
+
+		/* Read OOB data portion of the transfer */
+		memcpy((void *)oob, nand_buff_addr[bufrdy] + eccsize, eccbytes);
+		oob += eccbytes;
+	}
+
+	return 0;
+}
+
+/*
+ * Read the OOB data from the device in the hardware storage format
+ */
+static int lpc313x_nand_read_oob_syndrome(struct mtd_info *mtd, struct nand_chip *chip,
+		int page, int sndcmd)
+{
+	uint8_t *buf = chip->oob_poi;
+	int length = mtd->oobsize;
+	int chunk = chip->ecc.bytes + chip->ecc.prepad + chip->ecc.postpad;
+	int eccsize = chip->ecc.size, eccsteps = chip->ecc.steps;
+	uint8_t *bufpoi = buf;
+	int i, toread, sndrnd = sndcmd, pos;
+
+	chip->cmdfunc(mtd, NAND_CMD_READ0, chip->ecc.size, page);
+	for (i = eccsteps; i > 0; i--) {
+		/* Random position read needed? */
+		if (sndrnd) {
+			pos = eccsize + i * (eccsize + chunk);
+			if (mtd->writesize > 512)
+				chip->cmdfunc(mtd, NAND_CMD_RNDOUT, pos, -1);
+			else
+				chip->cmdfunc(mtd, NAND_CMD_READ0, pos, page);
+		} else {
+			sndrnd = 1;
+		}
+
+		toread = min_t(int, length, chunk);
+		chip->read_buf(mtd, bufpoi, toread);
+		bufpoi += toread;
+		length -= toread;
+	}
+	if (length > 0)
+		chip->read_buf(mtd, bufpoi, length);
+
+	return 1;
+}
+
+/*
+ * Write the payload and OOB data to the device in the hardware storage format
+ */
+static void lpc313x_nand_write_page_syndrome(struct mtd_info *mtd,
+		struct nand_chip *chip, const uint8_t *buf)
+{
+	int i, curbuf = 0, bufrdy = 0, eccsize = chip->ecc.size;
+	int eccbytes = chip->ecc.bytes;
+	int eccsteps = chip->ecc.steps;
+	const uint8_t *p = buf;
+	uint8_t *oob = chip->oob_poi;
+
+	for (i = 0; i < eccsteps; i++) {
+		/* Clear all current statuses */
+		lpc313x_nand_int_clear(~0);
+
+		/* Copy payload and OOB data to the buffer */
+		memcpy((void *) nand_buff_addr[bufrdy], p, eccsize);
+		memcpy((void *) nand_buff_addr[bufrdy] + eccsize, oob, OOB_FREE_OFFSET);
+		p += eccsize;
+		oob += eccbytes;
+		while(!((NAND_CTRL->irq_status_raw) & nand_buff_enc_mask[bufrdy]));
+
+		lpc313x_ram_write(curbuf);
+
+		/* Polling for buffer loaded and decoded */
+		while (!((NAND_CTRL->irq_status_raw) & nand_buff_wr_mask[curbuf]));
+	}
+
+	/* Calculate remaining oob bytes */
+	i = mtd->oobsize - (oob - chip->oob_poi);
+	if (i)
+		chip->write_buf(mtd, oob, i);
+}
+
+/*
+ * Write the OOB data to the device in the hardware storage format
+ */
+static int lpc313x_nand_write_oob_syndrome(struct mtd_info *mtd,
+		struct nand_chip *chip, int page)
+{
+	int chunk = chip->ecc.bytes + chip->ecc.prepad + chip->ecc.postpad;
+	int eccsize = chip->ecc.size, length = mtd->oobsize;
+	int i, len, pos, status = 0, sndcmd = 0, steps = chip->ecc.steps;
+	const uint8_t *bufpoi = chip->oob_poi;
+	int tmpStatus;
+
+	pos = eccsize;
+
+	chip->cmdfunc(mtd, NAND_CMD_SEQIN, pos, page);
+	for (i = 0; i < steps; i++) {
+		if (sndcmd) {
+			if (mtd->writesize <= 512) {
+				uint32_t fill = 0xFFFFFFFF;
+
+				len = eccsize;
+				while (len > 0) {
+					int num = min_t(int, len, 4);
+					chip->write_buf(mtd, (uint8_t *)&fill,
+							num);
+					len -= num;
+				}
+			} else {
+				pos = eccsize + i * (eccsize + chunk);
+				chip->cmdfunc(mtd, NAND_CMD_RNDIN, pos, -1);
+			}
+		} else {
+			sndcmd = 1;
+		}
+
+		len = min_t(int, length, chunk);
+		chip->write_buf(mtd, bufpoi, len);
+		bufpoi += len;
+		length -= len;
+	}
+	if (length > 0)
+		chip->write_buf(mtd, bufpoi, length);
+
+	chip->cmdfunc(mtd, NAND_CMD_PAGEPROG, -1, -1);
+	status = chip->waitfunc(mtd, chip);
+
+	tmpStatus = status & NAND_STATUS_FAIL ? -1 : 0;
+
+	return tmpStatus;
+}
+
+/*
+ * Returns NAND busy(0)/ready(!0) status callback
+ */
+static int nand_lpc313x_dev_ready(struct mtd_info *mtd)
+{
+	unsigned long tmp;
+	tmp = NAND_CTRL->check_sts;
+	return (int)(tmp & NAND_CHK_STS_RB1_LVL); 
+}
+
+/*
+ * nand_lpc313x_select_chip - [DEFAULT] control CE line
+ * Asserts and deasserts chip selects (callback)
+ */
+static void nand_lpc313x_select_chip (struct mtd_info *mtd, int chipnr)
+{
+	switch (chipnr) {
+	case -1:
+		NAND_CTRL->set_ce = NAND_SETCE_WP | NAND_SETCE_CV_MASK;
+		break;
+	case 0:
+		NAND_CTRL->set_ce = NAND_SETCE_WP | NAND_SETCE_CV(0);
+		break;
+	default:
+		BUG();
+	}
+}
+
+/*
+ * hardwarespecific function for accesing control-lines
+ */
+static void nand_lpc313x_hwcontrol(struct mtd_info *mtd, int cmd, unsigned int ctrl)
+
+{
+	if (cmd == NAND_CMD_NONE)
+		return;
+
+	if (ctrl & NAND_CLE) {
+		NAND_CTRL->set_cmd  = (u32 )cmd; 
+	}
+	else if (ctrl & NAND_ALE) {
+		NAND_CTRL->set_addr  = (u32 )cmd; 
+	}
+}
+
+/*
+ * Setup NAND interface timing
+ */
+static void lpc313x_nand_setrate(struct lpc313x_nand_timing *timing)
+{
+	u32 tmp, timing1, timing2, srcclk;
+
+	/* Get the NAND controller base clock rate */
+	srcclk = cgu_get_clk_freq(CGU_SB_NANDFLASH_NAND_CLK_ID);
+
+	/* Compute number of clocks for timing1 parameters */
+	tmp = srcclk / (1000000000 / timing->ns_trsd);
+	if (tmp > 0x3)
+		tmp = 0x3;
+	timing1 = NAND_TIM1_TSRD(tmp);
+	tmp = srcclk / (1000000000 / timing->ns_tals);
+	if (tmp > 0x7)
+		tmp = 0x7;
+	timing1 |= NAND_TIM1_TALS(tmp);
+	tmp = srcclk / (1000000000 / timing->ns_talh);
+	if (tmp > 0x7)
+		tmp = 0x7;
+	timing1 |= NAND_TIM1_TALH(tmp);
+	tmp = srcclk / (1000000000 / timing->ns_tcls);
+	if (tmp > 0x7)
+		tmp = 0x7;
+	timing1 |= NAND_TIM1_TCLS(tmp);
+	tmp = srcclk / (1000000000 / timing->ns_tclh);
+	if (tmp > 0x7)
+		tmp = 0x7;
+	timing1 |= NAND_TIM1_TCLH(tmp);
+	NAND_CTRL->timing1 = timing1;
+
+
+	/* Compute number of clocks for timing2 parameters */
+	tmp = srcclk / (1000000000 / timing->ns_tdrd);
+	if (tmp > 0x3)
+		tmp = 0x3;
+	timing2 = NAND_TIM2_TDRD(tmp);
+	tmp = srcclk / (1000000000 / timing->ns_tebidel);
+	if (tmp > 0x7)
+		tmp = 0x7;
+	timing2 |= NAND_TIM2_TEBI(tmp);
+	tmp = srcclk / (1000000000 / timing->ns_tch);
+	if (tmp > 0x7)
+		tmp = 0x7;
+	timing2 |= NAND_TIM2_TCH(tmp);
+	tmp = srcclk / (1000000000 / timing->ns_tcs);
+	if (tmp > 0x7)
+		tmp = 0x7;
+	timing2 |= NAND_TIM2_TCS(tmp);
+	tmp = srcclk / (1000000000 / timing->ns_treh);
+	if (tmp > 0x7)
+		tmp = 0x7;
+	timing2 |= NAND_TIM2_TRH(tmp);
+	tmp = srcclk / (1000000000 / timing->ns_trp);
+	if (tmp > 0x7)
+		tmp = 0x7;
+	timing2 |= NAND_TIM2_TRP(tmp);
+	tmp = srcclk / (1000000000 / timing->ns_trw);
+	if (tmp > 0x7)
+		tmp = 0x7;
+	timing2 |= NAND_TIM2_TWH(tmp);
+	tmp = srcclk / (1000000000 / timing->ns_twp);
+	if (tmp > 0x7)
+		tmp = 0x7;
+	timing2 |= NAND_TIM2_TWP(tmp);
+	NAND_CTRL->timing2 = timing2;
+}
+
+static void nand_lpc313x_inithw( void )
+{
+	/* enable NAND clocks */
+	cgu_clk_en_dis(CGU_SB_NANDFLASH_S0_CLK_ID, 1);
+	cgu_clk_en_dis(CGU_SB_NANDFLASH_ECC_CLK_ID, 1);
+	cgu_clk_en_dis(CGU_SB_NANDFLASH_NAND_CLK_ID, 1);
+	cgu_clk_en_dis(CGU_SB_NANDFLASH_PCLK_ID, 1);
+
+	/* reset NAND controller */
+	cgu_soft_reset_module(NANDFLASH_NAND_RESET_N_SOFT);
+	cgu_soft_reset_module(NANDFLASH_ECC_RESET_N_SOFT);
+
+	/* check NAND mux signals */
+	SYS_REGS->mux_nand_mci_sel = 0;
+
+	/* Disable all NAND interrupts */
+	NAND_CTRL->irq_mask = ~0;
+	NAND_CTRL->irq_mask2 = ~0;
+
+	/* Setup device and controller timing */
+	lpc313x_nand_setrate(&ea313x_nanddev_timing);
+
+	/* enable the controller for 8-bit NAND and de-assert nFCE */
+	NAND_CTRL->config = NAND_CTRL->config | (NAND_CFG_DC |
+				NAND_CFG_ECGC | NAND_CFG_EC);
+}
+
+int board_nand_init(struct nand_chip *nand)
+{
+	/* Populdate device callbacks used by MTD driver */
+	nand->IO_ADDR_R = (void __iomem *)&NAND_CTRL->read_data;
+	nand->IO_ADDR_W = (void __iomem *)&NAND_CTRL->write_data;
+
+	nand->select_chip = nand_lpc313x_select_chip;
+	nand->chip_delay = 20;
+	nand->cmd_ctrl = nand_lpc313x_hwcontrol;
+	nand->dev_ready = nand_lpc313x_dev_ready;
+
+	/* Configuration ECC related stuff */
+	nand->ecc.mode = NAND_ECC_HW_SYNDROME;
+	nand->ecc.read_page_raw = lpc313x_nand_read_page_syndrome;
+	nand->ecc.read_page = lpc313x_nand_read_page_syndrome;
+	nand->ecc.write_page = lpc313x_nand_write_page_syndrome;
+	nand->ecc.write_oob = lpc313x_nand_write_oob_syndrome;
+	nand->ecc.read_oob = lpc313x_nand_read_oob_syndrome;
+	nand->ecc.calculate = lpc313x_nand_calculate_ecc;
+	nand->ecc.correct   = lpc313x_nand_correct_data;
+	nand->ecc.hwctl = lpc313x_nand_enable_hwecc;
+	nand->ecc.layout = &nand_hw_eccoob_64;
+
+	nand->options |= NAND_USE_FLASH_BBT;
+
+	/* Configuration for Bad Block Table */
+	nand->bbt_td = &lpc313x_bbt_main_descr;
+	nand->bbt_md = &lpc313x_bbt_mirror_descr;
+	nand->badblock_pattern = &lpc313x_largepage_flashbased;
+
+	nand->ecc.size = 512;
+	nand->ecc.bytes = 16;
+	nand->ecc.prepad = 0;
+
+	nand_lpc313x_inithw();
+
+	return(0);
+}
+#endif
+
diff --git a/drivers/mtd/nand/nand_base.c b/drivers/mtd/nand/nand_base.c
index 27f6c77..e2806e6 100644
--- a/drivers/mtd/nand/nand_base.c
+++ b/drivers/mtd/nand/nand_base.c
@@ -2540,7 +2540,7 @@ static void nand_flash_detect_non_onfi(struct mtd_info *mtd,
 /*
  * Get the flash and manufacturer id and lookup if the type is supported
  */
-static const struct nand_flash_dev *nand_get_flash_type(struct mtd_info *mtd,
+const struct nand_flash_dev *nand_get_flash_type(struct mtd_info *mtd,
 						  struct nand_chip *chip,
 						  int busw,
 						  int *maf_id, int *dev_id,
diff --git a/drivers/net/dm9000x.c b/drivers/net/dm9000x.c
index 0424110..105abae 100644
--- a/drivers/net/dm9000x.c
+++ b/drivers/net/dm9000x.c
@@ -264,7 +264,7 @@ dm9000_reset(void)
 	/* Step 1: Power internal PHY by writing 0 to GPIO0 pin */
 	DM9000_iow(DM9000_GPR, 0);
 	/* Step 2: Software reset */
-	DM9000_iow(DM9000_NCR, (NCR_LBK_INT_MAC | NCR_RST));
+	DM9000_iow(DM9000_NCR, NCR_RST);
 
 	do {
 		DM9000_DBG("resetting the DM9000, 1st reset\n");
@@ -272,7 +272,7 @@ dm9000_reset(void)
 	} while (DM9000_ior(DM9000_NCR) & 1);
 
 	DM9000_iow(DM9000_NCR, 0);
-	DM9000_iow(DM9000_NCR, (NCR_LBK_INT_MAC | NCR_RST)); /* Issue a second reset */
+	DM9000_iow(DM9000_NCR, NCR_RST); /* Issue a second reset */
 
 	do {
 		DM9000_DBG("resetting the DM9000, 2nd reset\n");
@@ -372,7 +372,7 @@ static int dm9000_init(struct eth_device *dev, bd_t *bd)
 	while (!(dm9000_phy_read(1) & 0x20)) {	/* autonegation complete bit */
 		udelay(1000);
 		i++;
-		if (i == 10000) {
+		if (i == 1000000) {
 			printf("could not establish link\n");
 			return 0;
 		}
diff --git a/drivers/serial/usbtty.c b/drivers/serial/usbtty.c
index a263b2c..406bdce 100644
--- a/drivers/serial/usbtty.c
+++ b/drivers/serial/usbtty.c
@@ -29,6 +29,9 @@
 #include "usbtty.h"
 #include "usb_cdc_acm.h"
 #include "usbdescriptors.h"
+#include <usb_dfu_descriptors.h>
+#include <usb_dfu.h>
+
 
 #ifdef DEBUG
 #define TTYDBG(fmt,args...)\
@@ -84,7 +87,7 @@ static struct usb_endpoint_instance endpoint_instance[NUM_ENDPOINTS+1];
  * Global flag
  */
 int usbtty_configured_flag = 0;
-
+int usbtty_init_done = 0;
 /*
  * Serial number
  */
@@ -102,7 +105,7 @@ extern struct usb_string_descriptor **usb_strings;
 static unsigned short rx_endpoint = 0;
 static unsigned short tx_endpoint = 0;
 static unsigned short interface_count = 0;
-static struct usb_string_descriptor *usbtty_string_table[STR_COUNT];
+static struct usb_string_descriptor *usbtty_string_table[NUM_STRINGS];
 
 /* USB Descriptor Strings */
 static u8 wstrLang[4] = {4,USB_DT_STRING,0x9,0x4};
@@ -152,6 +155,11 @@ struct acm_config_desc {
 	/* Slave Interface */
 	struct usb_interface_descriptor data_class_interface;
 	struct usb_endpoint_descriptor data_endpoints[NUM_ENDPOINTS-1];
+#ifdef CONFIG_USB_DFU
+	struct usb_interface_descriptor uif_dfu;
+	struct usb_dfu_func_descriptor func_dfu;
+#endif
+
 } __attribute__((packed));
 
 static struct acm_config_desc acm_configuration_descriptors[NUM_CONFIGS] = {
@@ -162,7 +170,11 @@ static struct acm_config_desc acm_configuration_descriptors[NUM_CONFIGS] = {
 			.bDescriptorType = USB_DT_CONFIG,
 			.wTotalLength =
 				cpu_to_le16(sizeof(struct acm_config_desc)),
+#ifdef CONFIG_USB_DFU
+			.bNumInterfaces = NUM_ACM_INTERFACES +1,
+#else
 			.bNumInterfaces = NUM_ACM_INTERFACES,
+#endif
 			.bConfigurationValue = 1,
 			.iConfiguration = STR_CONFIG,
 			.bmAttributes =
@@ -261,6 +273,11 @@ static struct acm_config_desc acm_configuration_descriptors[NUM_CONFIGS] = {
 				.bInterval		= 0xFF,
 			},
 		},
+#ifdef CONFIG_USB_DFU
+		/* Interface 3 */
+		.uif_dfu = DFU_RT_IF_DESC,
+		.func_dfu = DFU_FUNC_DESC,
+#endif
 	},
 };
 
@@ -371,7 +388,7 @@ static int fill_buffer (circbuf_t * buf);
 void usbtty_poll (void);
 
 /* utility function for converting char* to wide string used by USB */
-static void str2wide (char *str, u16 * wide)
+void str2wide (char *str, u16 * wide)
 {
 	int i;
 	for (i = 0; i < strlen (str) && str[i]; i++){
@@ -524,55 +541,68 @@ int drv_usbtty_init (void)
 	char * tt;
 	int snlen;
 
-	/* Ger seiral number */
-	if (!(sn = getenv("serial#"))) {
+	if(usbtty_init_done == 0) {
+#ifdef CONFIG_LPC313X
 		sn = "000000000000";
-	}
-	snlen = strlen(sn);
-	if (snlen > sizeof(serial_number) - 1) {
-		printf ("Warning: serial number %s is too long (%d > %lu)\n",
-			sn, snlen, (ulong)(sizeof(serial_number) - 1));
-		snlen = sizeof(serial_number) - 1;
-	}
-	memcpy (serial_number, sn, snlen);
-	serial_number[snlen] = '\0';
-
-	/* Decide on which type of UDC device to be.
-	 */
+#else
+		/* Ger seiral number */
+		if (!(sn = getenv("serial#"))) {
+			sn = "000000000000";
+		}
+#endif
+		snlen = strlen(sn);
+		if (snlen > sizeof(serial_number) - 1) {
+			printf ("Warning: serial number %s is too long (%d > %lu)\n",
+					sn, snlen, (ulong)(sizeof(serial_number) - 1));
+			snlen = sizeof(serial_number) - 1;
+		}
+		memcpy (serial_number, sn, snlen);
+		serial_number[snlen] = '\0';
 
-	if(!(tt = getenv("usbtty"))) {
-		tt = "generic";
-	}
-	usbtty_init_terminal_type(strcmp(tt,"cdc_acm"));
+		/* Decide on which type of UDC device to be.
+		*/
 
-	/* prepare buffers... */
-	buf_init (&usbtty_input, USBTTY_BUFFER_SIZE);
-	buf_init (&usbtty_output, USBTTY_BUFFER_SIZE);
+#ifdef CONFIG_LPC313X
+		usbtty_init_terminal_type(0);
+#else
+		if(!(tt = getenv("usbtty"))) {
+			tt = "generic";
+		}
+		usbtty_init_terminal_type(strcmp(tt,"cdc_acm"));
+#endif
+		/* prepare buffers... */
+		buf_init (&usbtty_input, USBTTY_BUFFER_SIZE);
+		buf_init (&usbtty_output, USBTTY_BUFFER_SIZE);
 
-	/* Now, set up USB controller and infrastructure */
-	udc_init ();		/* Basic USB initialization */
+		/* Now, set up USB controller and infrastructure */
+		udc_init ();		/* Basic USB initialization */
 
-	usbtty_init_strings ();
-	usbtty_init_instances ();
+		usbtty_init_strings ();
+		usbtty_init_instances ();
 
-	usbtty_init_endpoints ();
+		udc_startup_events (device_instance);/* Enable dev, init udc pointers */
+		udc_connect ();		/* Enable pullup for host detection */
 
-	udc_startup_events (device_instance);/* Enable dev, init udc pointers */
-	udc_connect ();		/* Enable pullup for host detection */
+		usbtty_init_endpoints ();
 
-	/* Device initialization */
-	memset (&usbttydev, 0, sizeof (usbttydev));
+		/* Device initialization */
+		memset (&usbttydev, 0, sizeof (usbttydev));
 
-	strcpy (usbttydev.name, "usbtty");
-	usbttydev.ext = 0;	/* No extensions */
-	usbttydev.flags = DEV_FLAGS_INPUT | DEV_FLAGS_OUTPUT;
-	usbttydev.tstc = usbtty_tstc;	/* 'tstc' function */
-	usbttydev.getc = usbtty_getc;	/* 'getc' function */
-	usbttydev.putc = usbtty_putc;	/* 'putc' function */
-	usbttydev.puts = usbtty_puts;	/* 'puts' function */
+		strcpy (usbttydev.name, "usbtty");
+		usbttydev.ext = 0;	/* No extensions */
+		usbttydev.flags = DEV_FLAGS_INPUT | DEV_FLAGS_OUTPUT;
+		usbttydev.tstc = usbtty_tstc;	/* 'tstc' function */
+		usbttydev.getc = usbtty_getc;	/* 'getc' function */
+		usbttydev.putc = usbtty_putc;	/* 'putc' function */
+		usbttydev.puts = usbtty_puts;	/* 'puts' function */
 
+		usbtty_init_done = 1;
+	}
+#ifndef CONFIG_USB_DFU
 	rc = stdio_register (&usbttydev);
-
+#else
+	rc = 0;
+#endif
 	return (rc == 0) ? 1 : rc;
 }
 
@@ -643,6 +673,9 @@ static void usbtty_init_instances (void)
 	device_instance->bus = bus_instance;
 	device_instance->configurations = NUM_CONFIGS;
 	device_instance->configuration_instance_array = config_instance;
+#ifdef CONFIG_USB_DFU
+	dfu_init_instance(device_instance);
+#endif
 
 	/* initialize bus instance */
 	memset (bus_instance, 0, sizeof (struct usb_bus_instance));
diff --git a/drivers/serial/usbtty.h b/drivers/serial/usbtty.h
index e449cd7..f753681 100644
--- a/drivers/serial/usbtty.h
+++ b/drivers/serial/usbtty.h
@@ -33,6 +33,8 @@
 #include <usb/musb_udc.h>
 #elif defined(CONFIG_CPU_PXA27X)
 #include <usb/pxa27x_udc.h>
+#elif defined(CONFIG_LPC313X)
+#include <usb/lpc313x_udc.h>
 #elif defined(CONFIG_SPEAR3XX) || defined(CONFIG_SPEAR600)
 #include <usb/spr_udc.h>
 #endif
@@ -84,4 +86,10 @@
 #define STR_CTRL_INTERFACE	0x06
 #define STR_COUNT		0x07
 
+#ifdef CONFIG_USB_DFU
+#define NUM_STRINGS		DFU_STR_COUNT
+#else
+#define NUM_STRINGS		STR_COUNT
+#endif
+
 #endif
diff --git a/drivers/spi/Makefile b/drivers/spi/Makefile
index 6f389f0..bee4da4 100644
--- a/drivers/spi/Makefile
+++ b/drivers/spi/Makefile
@@ -40,6 +40,7 @@ COBJS-$(CONFIG_MXC_SPI) += mxc_spi.o
 COBJS-$(CONFIG_MXS_SPI) += mxs_spi.o
 COBJS-$(CONFIG_OC_TINY_SPI) += oc_tiny_spi.o
 COBJS-$(CONFIG_OMAP3_SPI) += omap3_spi.o
+COBJS-$(CONFIG_LPC313X_SPI) += lpc313x_spi.o
 COBJS-$(CONFIG_SOFT_SPI) += soft_spi.o
 COBJS-$(CONFIG_SH_SPI) += sh_spi.o
 COBJS-$(CONFIG_FSL_ESPI) += fsl_espi.o
diff --git a/drivers/spi/lpc313x_spi.c b/drivers/spi/lpc313x_spi.c
new file mode 100644
index 0000000..e120c79
--- /dev/null
+++ b/drivers/spi/lpc313x_spi.c
@@ -0,0 +1,150 @@
+/*
+ * (C) Copyright 2010 NXP Semiconductors
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <spi.h>
+#include <malloc.h>
+#include <asm/io.h>
+#include <asm/arch/hardware.h>
+#include <asm/arch/spi.h>
+
+struct lpc313x_spi_info
+{
+	long spi_init;
+	struct spi_slave slave;
+};
+
+struct lpc313x_spi_info *lpc313x_spi = NULL;
+const extern SPI_SLAVE_CONFIG_T slavecfg;
+
+static inline struct lpc313x_spi_info *to_lpc313x_spi(struct spi_slave *slave)
+{
+	return container_of(slave, struct lpc313x_spi_info, slave);
+}
+
+void spi_init(void)
+{
+	lpc313x_spi = (struct lpc313x_spi_info *)malloc(sizeof(struct lpc313x_spi_info));
+	if(!lpc313x_spi) {
+		printf("%s not able to allocate memory\n",__FUNCTION__);
+		return;
+	}
+
+	memset((void*)lpc313x_spi,0x0,sizeof(struct lpc313x_spi_info));
+
+	lpc313x_spi_init();
+
+	lpc313x_spi->spi_init = 1;
+}
+
+struct spi_slave *spi_setup_slave(unsigned int bus, unsigned int cs,
+			unsigned int max_hz, unsigned int mode)
+{
+	lpc313x_spi->slave.bus = bus;
+	lpc313x_spi->slave.cs = cs;
+	
+	if(lpc313x_setup_slave(&slavecfg) != 0)
+		return NULL;
+
+	return &lpc313x_spi->slave;
+}
+
+void spi_free_slave(struct spi_slave *slave)
+{
+	struct lpc313x_spi_info *lpc313xspi = to_lpc313x_spi(slave);
+
+	free(lpc313xspi);
+}
+
+int spi_claim_bus(struct spi_slave *slave)
+{
+	return 0;
+}
+
+void spi_release_bus(struct spi_slave *slave)
+{
+}
+
+int spi_xfer(struct spi_slave *slave, unsigned int bitlen,
+		const void *dout, void *din, unsigned long flags)
+{
+	unsigned int	len;
+	int		ret;
+	u32		status;
+	const u8	*txp = dout;
+	u8		*rxp = din;
+	long 		rxbytes = 0;
+	unsigned int	txbytes = 0;
+	unsigned int	total_txbytes = 0;
+
+	ret = 0;
+	if (bitlen == 0)
+		/* Finish any previously submitted transfers */
+		goto out;
+
+	if (bitlen % 8) {
+		/* Errors always terminate an ongoing transfer */
+		flags |= SPI_XFER_END;
+		goto out;
+	}
+
+	len = bitlen / 8;
+	if (flags & SPI_XFER_BEGIN)
+		spinor_cs_low();
+
+	/* flush the FFOS */
+	spi_flush_rx_fifo();
+
+	/* write the commands or data to Flash memory */
+	
+	while (total_txbytes < len) {
+		if(!txp) {
+			udelay(10);
+			txbytes = spi_write((void *)txp, ((len > 64) ? 64: len));
+		}
+		else {
+			udelay(10);
+			txbytes = spi_write((void *)&txp[total_txbytes], ((len > 64) ? 64: len));
+		}
+		total_txbytes += txbytes;
+		/* wait till SPI is not busy */
+		do {
+			status = spi_get_status();
+		}
+		while ((status & SPI_ST_TX_EMPTY) != SPI_ST_TX_EMPTY);
+		/* Read Data from Flash memory */
+		if(!rxp) {
+			udelay(10);
+			rxbytes += spi_read(rxp, txbytes);
+		}
+		else {
+			udelay(10);
+			rxbytes += spi_read(&rxp[rxbytes], txbytes);
+		}
+	}
+out:
+	if (flags & SPI_XFER_END) {
+		spinor_cs_high();
+	}
+	
+	return 0;
+}
diff --git a/drivers/usb/gadget/Makefile b/drivers/usb/gadget/Makefile
index 64b091f..1944799 100644
--- a/drivers/usb/gadget/Makefile
+++ b/drivers/usb/gadget/Makefile
@@ -43,6 +43,8 @@ COBJS-$(CONFIG_OMAP1510) += omap1510_udc.o
 COBJS-$(CONFIG_OMAP1610) += omap1510_udc.o
 COBJS-$(CONFIG_MPC885_FAMILY) += mpc8xx_udc.o
 COBJS-$(CONFIG_CPU_PXA27X) += pxa27x_udc.o
+COBJS-$(CONFIG_LPC313X) += lpc313x_udc.o
+COBJS-$(CONFIG_USB_DFU) += dfu.o
 COBJS-$(CONFIG_SPEARUDC) += spr_udc.o
 endif
 endif
diff --git a/drivers/usb/gadget/core.c b/drivers/usb/gadget/core.c
index 4f2ebab..d91d00f 100644
--- a/drivers/usb/gadget/core.c
+++ b/drivers/usb/gadget/core.c
@@ -31,6 +31,7 @@
 
 #include <malloc.h>
 #include <usbdevice.h>
+#include <usb_dfu.h>
 
 #define MAX_INTERFACES 2
 
@@ -209,6 +210,10 @@ struct usb_alternate_instance *usbd_device_alternate_instance (struct usb_device
  */
 struct usb_device_descriptor *usbd_device_device_descriptor (struct usb_device_instance *device, int port)
 {
+#ifdef CONFIG_USB_DFU
+	if (device->dfu_state != DFU_STATE_appIDLE)
+		return device->dfu_dev_desc;
+#endif
 	return (device->device_descriptor);
 }
 
@@ -229,6 +234,10 @@ struct usb_configuration_descriptor *usbd_device_configuration_descriptor (struc
 	if (!(configuration_instance = usbd_device_configuration_instance (device, port, configuration))) {
 		return NULL;
 	}
+#ifdef CONFIG_USB_DFU
+	if (device->dfu_state != DFU_STATE_appIDLE)
+		return (&device->dfu_cfg_desc->ucfg);
+#endif
 	return (configuration_instance->configuration_descriptor);
 }
 
@@ -250,6 +259,13 @@ struct usb_interface_descriptor *usbd_device_interface_descriptor (struct usb_de
 	if (!(interface_instance = usbd_device_interface_instance (device, port, configuration, interface))) {
 		return NULL;
 	}
+#ifdef CONFIG_USB_DFU
+	if (device->dfu_state != DFU_STATE_appIDLE) {
+		if (alternate < 0 || alternate >= DFU_NUM_ALTERNATES)
+			return NULL;
+		return &device->dfu_cfg_desc->uif[alternate];
+	}
+#endif
 	if ((alternate < 0) || (alternate >= interface_instance->alternates)) {
 		return NULL;
 	}
@@ -680,4 +696,7 @@ void usbd_device_event_irq (struct usb_device_instance *device, usb_device_event
 		/* usbdbg("calling device->event"); */
 		device->event(device, event, data);
 	}
+#ifdef CONFIG_USB_DFU
+	dfu_event(device, event, data);
+#endif
 }
diff --git a/drivers/usb/gadget/dfu.c b/drivers/usb/gadget/dfu.c
new file mode 100644
index 0000000..e7e552d
--- /dev/null
+++ b/drivers/usb/gadget/dfu.c
@@ -0,0 +1,611 @@
+/*
+ * (C) 2007 by OpenMoko, Inc.
+ * Author: Harald Welte <laforge@openmoko.org>
+ *
+ * based on existing SAM7DFU code from OpenPCD:
+ * (C) Copyright 2006 by Harald Welte <hwelte@hmw-consulting.de>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ *
+ */
+
+#include <config.h>
+#if defined(CONFIG_USB_DFU)
+
+#include <common.h>
+DECLARE_GLOBAL_DATA_PTR;
+
+#include <malloc.h>
+#include <linux/types.h>
+#include <linux/list.h>
+#include <asm/errno.h>
+#include <usbdevice.h>
+#include <usb_dfu.h>
+#include <usb_dfu_descriptors.h>
+
+extern struct list_head devices;
+
+#include "../../serial/usbtty.h"			/* for STR_* defs */
+
+#define RET_NOTHING	0
+#define RET_ZLP		1
+#define RET_STALL	2
+
+volatile enum dfu_state *system_dfu_state; /* for 3rd parties */
+
+struct dnload_state {
+	unsigned char *ptr;	/* pointer to next empty byte in buffer */
+	unsigned char *buf;	/* pointer to allocated erase page buffer */
+};
+
+static struct dnload_state _dnstate;
+
+unsigned int total_len = 0;
+unsigned char stop_polling = 0;
+unsigned char xfer_error = 0;
+
+extern ulong dfu_load_addr;
+
+static int handle_dnload(struct urb *urb, u_int16_t val, u_int16_t len, int first)
+{
+	struct usb_device_instance *dev = urb->device;
+	struct dnload_state *ds = &_dnstate;
+	unsigned int i = 0;
+
+	debug("download(len=%u, first=%u) ", len, first);
+
+	if (len > CONFIG_USBD_DFU_XFER_SIZE) {
+		/* Too big. Not that we'd really care, but it's a
+		 * DFU protocol violation */
+		debug("length exceeds flash page size ");
+		printf("length exceeds flash page size len: %d\n",len);
+		dev->dfu_state = DFU_STATE_dfuERROR;
+		dev->dfu_status = DFU_STATUS_errADDRESS;
+		return RET_STALL;
+	}
+
+	if (len == 0) {
+		debug("zero-size write -> MANIFEST_SYNC ");
+		dev->dfu_state = DFU_STATE_dfuMANIFEST_SYNC;
+		stop_polling = 1;
+		printf("bytes transfered: %d\n",total_len);
+
+		/* cleanup */
+		switch (dev->alternate) {
+			char buf[12];
+		case 0:
+#ifndef CONFIG_LPC313X
+			sprintf(buf, "%lx", ds->ptr - ds->buf);
+			setenv("filesize", buf);
+#endif
+			ds->ptr = ds->buf;
+			break;
+		default:
+			printf("DFU other alternative interfaces are not supported\n");
+			break;
+		}
+
+		return RET_ZLP;
+	}
+
+	if (urb->actual_length != len) {
+		printf("#urb->actual_length(%u) != len(%u) ?!? ",
+			urb->actual_length, len);
+		debug("#urb->actual_length(%u) != len(%u) ?!? ",
+			urb->actual_length, len);
+		xfer_error = 1;
+		printf("total_len: %d\n",total_len);
+		dev->dfu_state = DFU_STATE_dfuERROR;
+		dev->dfu_status = DFU_STATUS_errADDRESS;
+		return RET_STALL;
+	}
+
+	switch (dev->alternate) {
+	case 0:
+		if (first) {
+			printf("Starting DFU DOWNLOAD to RAM (0x%08p) \n",
+				dfu_load_addr);
+			total_len = 0;
+			ds->buf = (unsigned char*)dfu_load_addr;
+			ds->ptr = ds->buf;
+		}
+		total_len += len;
+		memcpy(ds->ptr, urb->buffer, len);
+		ds->ptr += len;
+		break;
+	default:
+		printf("DFU other alternative interfaces are not supported\n");
+		break;
+	}
+
+	return RET_ZLP;
+}
+
+static void handle_getstatus(struct urb *urb, int max)
+{
+	struct usb_device_instance *dev = urb->device;
+	struct dfu_status *dstat = (struct dfu_status *) urb->buffer;
+
+	debug("getstatus ");
+
+	if (!urb->buffer || urb->buffer_length < sizeof(*dstat)) {
+		debug("invalid urb! ");
+		return;
+	}
+
+	switch (dev->dfu_state) {
+	case DFU_STATE_dfuDNLOAD_SYNC:
+	case DFU_STATE_dfuDNBUSY:
+#if 0
+		if (fsr & AT91C_MC_PROGE) {
+			debug("errPROG ");
+			dev->dfu_status = DFU_STATUS_errPROG;
+			dev->dfu_state = DFU_STATE_dfuERROR;
+		} else if (fsr & AT91C_MC_LOCKE) {
+			debug("errWRITE ");
+			dev->dfu_status = DFU_STATUS_errWRITE;
+			dev->dfu_state = DFU_STATE_dfuERROR;
+		} else if (fsr & AT91C_MC_FRDY) {
+#endif
+			debug("DNLOAD_IDLE ");
+			dev->dfu_state = DFU_STATE_dfuDNLOAD_IDLE;
+#if 0
+		} else {
+			debug("DNBUSY ");
+			dev->dfu_state = DFU_STATE_dfuDNBUSY;
+		}
+#endif
+		break;
+	case DFU_STATE_dfuMANIFEST_SYNC:
+		break;
+	default:
+		//return;
+		break;
+	}
+
+	/* send status response */
+	dstat->bStatus = dev->dfu_status;
+	dstat->bState = dev->dfu_state;
+	dstat->iString = 0;
+	/* FIXME: set dstat->bwPollTimeout */
+	urb->actual_length = MIN(sizeof(*dstat), max);
+
+	/* we don't need to explicitly send data here, will
+	 * be done by the original caller! */
+}
+
+static void handle_getstate(struct urb *urb, int max)
+{
+	debug("getstate ");
+
+	if (!urb->buffer || urb->buffer_length < sizeof(u_int8_t)) {
+		debug("invalid urb! ");
+		return;
+	}
+
+	urb->buffer[0] = urb->device->dfu_state & 0xff;
+	urb->actual_length = sizeof(u_int8_t);
+}
+
+#ifndef CONFIG_USBD_PRODUCTID_DFU
+#define CONFIG_USBD_PRODUCTID_DFU CONFIG_USBD_PRODUCTID_CDCACM
+#endif
+
+static const struct usb_device_descriptor dfu_dev_descriptor = {
+	.bLength		= USB_DT_DEVICE_SIZE,
+	.bDescriptorType	= USB_DT_DEVICE,
+	.bcdUSB			= 0x0100,
+	.bDeviceClass		= 0x00,
+	.bDeviceSubClass	= 0x00,
+	.bDeviceProtocol	= 0x00,
+	.bMaxPacketSize0	= EP0_MAX_PACKET_SIZE,
+	.idVendor		= CONFIG_USBD_VENDORID,
+	.idProduct		= CONFIG_USBD_PRODUCTID_DFU,
+	.bcdDevice		= 0x0000,
+	.iManufacturer		= DFU_STR_MANUFACTURER,
+	.iProduct		= DFU_STR_PRODUCT,
+	.iSerialNumber		= DFU_STR_SERIAL,
+	.bNumConfigurations	= 0x01,
+};
+
+static struct _dfu_desc dfu_cfg_descriptor = {
+	.ucfg = {
+		.bLength		= USB_DT_CONFIG_SIZE,
+		.bDescriptorType	= USB_DT_CONFIG,
+		.wTotalLength		= USB_DT_CONFIG_SIZE +
+					  DFU_NUM_ALTERNATES * USB_DT_INTERFACE_SIZE +
+					  USB_DT_DFU_SIZE,
+		.bNumInterfaces		= 1,
+		.bConfigurationValue	= 1,
+		.iConfiguration		= DFU_STR_CONFIG,
+		.bmAttributes		= BMATTRIBUTE_RESERVED,
+		.bMaxPower		= 50,
+	},
+	.func_dfu = DFU_FUNC_DESC,
+};
+
+int dfu_ep0_handler(struct urb *urb)
+{
+	int rc, ret = RET_NOTHING;
+	u_int8_t req = urb->device_request.bRequest;
+	u_int16_t val = urb->device_request.wValue;
+	u_int16_t len = urb->device_request.wLength;
+	struct usb_device_instance *dev = urb->device;
+
+	debug("dfu_ep0(req=0x%x, val=0x%x, len=%u) old_state = %u ",
+		req, val, len, dev->dfu_state);
+
+	switch (dev->dfu_state) {
+	case DFU_STATE_appIDLE:
+		switch (req) {
+		case USB_REQ_DFU_GETSTATUS:
+			handle_getstatus(urb, len);
+			break;
+		case USB_REQ_DFU_GETSTATE:
+			handle_getstate(urb, len);
+			break;
+		case USB_REQ_DFU_DETACH:
+			dev->dfu_state = DFU_STATE_appDETACH;
+			ret = RET_ZLP;
+			goto out;
+			break;
+		default:
+			ret = RET_STALL;
+		}
+		break;
+	case DFU_STATE_appDETACH:
+		switch (req) {
+		case USB_REQ_DFU_GETSTATUS:
+			handle_getstatus(urb, len);
+			break;
+		case USB_REQ_DFU_GETSTATE:
+			handle_getstate(urb, len);
+			break;
+		default:
+			dev->dfu_state = DFU_STATE_appIDLE;
+			ret = RET_STALL;
+			goto out;
+			break;
+		}
+		/* FIXME: implement timer to return to appIDLE */
+		break;
+	case DFU_STATE_dfuIDLE:
+		switch (req) {
+		case USB_REQ_DFU_DNLOAD:
+			//printf("DFU download is started\n");
+			if (len == 0) {
+				dev->dfu_state = DFU_STATE_dfuERROR;
+				ret = RET_STALL;
+				goto out;
+			}
+			dev->dfu_state = DFU_STATE_dfuDNLOAD_SYNC;
+			ret = handle_dnload(urb, val, len, 1);
+			break;
+		case USB_REQ_DFU_UPLOAD:
+			dev->dfu_state = DFU_STATE_dfuUPLOAD_IDLE;
+			printf("DFU upload is not supported\n");
+			break;
+		case USB_REQ_DFU_ABORT:
+			/* no zlp? */
+			ret = RET_ZLP;
+			break;
+		case USB_REQ_DFU_GETSTATUS:
+			handle_getstatus(urb, len);
+			break;
+		case USB_REQ_DFU_GETSTATE:
+			handle_getstate(urb, len);
+			break;
+		case USB_REQ_DFU_DETACH:
+			/* Proprietary extension: 'detach' from idle mode and
+			 * get back to runtime mode in case of USB Reset. As
+			 * much as I dislike this, we just can't use every USB
+			 * bus reset to switch back to runtime mode, since at
+			 * least the Linux USB stack likes to send a number of resets
+			 * in a row :( */
+			dev->dfu_state = DFU_STATE_dfuMANIFEST_WAIT_RST;
+			break;
+		default:
+			dev->dfu_state = DFU_STATE_dfuERROR;
+			ret = RET_STALL;
+			goto out;
+			break;
+		}
+		break;
+	case DFU_STATE_dfuDNLOAD_SYNC:
+		switch (req) {
+		case USB_REQ_DFU_GETSTATUS:
+			handle_getstatus(urb, len);
+			/* FIXME: state transition depending on block completeness */
+			break;
+		case USB_REQ_DFU_GETSTATE:
+			handle_getstate(urb, len);
+			break;
+		default:
+			dev->dfu_state = DFU_STATE_dfuERROR;
+			ret = RET_STALL;
+			goto out;
+		}
+		break;
+	case DFU_STATE_dfuDNBUSY:
+		switch (req) {
+		case USB_REQ_DFU_GETSTATUS:
+			/* FIXME: only accept getstatus if bwPollTimeout
+			 * has elapsed */
+			handle_getstatus(urb, len);
+			break;
+		default:
+			dev->dfu_state = DFU_STATE_dfuERROR;
+			ret = RET_STALL;
+			goto out;
+		}
+		break;
+	case DFU_STATE_dfuDNLOAD_IDLE:
+		switch (req) {
+		case USB_REQ_DFU_DNLOAD:
+			dev->dfu_state = DFU_STATE_dfuDNLOAD_SYNC;
+			ret = handle_dnload(urb, val, len, 0);
+			break;
+		case USB_REQ_DFU_ABORT:
+			dev->dfu_state = DFU_STATE_dfuIDLE;
+			ret = RET_ZLP;
+			break;
+		case USB_REQ_DFU_GETSTATUS:
+			handle_getstatus(urb, len);
+			break;
+		case USB_REQ_DFU_GETSTATE:
+			handle_getstate(urb, len);
+			break;
+		default:
+			dev->dfu_state = DFU_STATE_dfuERROR;
+			ret = RET_STALL;
+			break;
+		}
+		break;
+	case DFU_STATE_dfuMANIFEST_SYNC:
+		switch (req) {
+		case USB_REQ_DFU_GETSTATUS:
+			/* We're MainfestationTolerant */
+			dev->dfu_state = DFU_STATE_dfuIDLE;
+			handle_getstatus(urb, len);
+			break;
+		case USB_REQ_DFU_GETSTATE:
+			handle_getstate(urb, len);
+			break;
+		default:
+			dev->dfu_state = DFU_STATE_dfuERROR;
+			ret = RET_STALL;
+			break;
+		}
+		break;
+	case DFU_STATE_dfuMANIFEST:
+		/* we should never go here */
+		dev->dfu_state = DFU_STATE_dfuERROR;
+		ret = RET_STALL;
+		break;
+	case DFU_STATE_dfuMANIFEST_WAIT_RST:
+		/* we should never go here */
+		break;
+	case DFU_STATE_dfuUPLOAD_IDLE:
+		switch (req) {
+		case USB_REQ_DFU_UPLOAD:
+			/* state transition if less data then requested */
+			printf("DFU upload is not supported\n");
+			if (rc >= 0 && rc < len)
+				dev->dfu_state = DFU_STATE_dfuIDLE;
+			break;
+		case USB_REQ_DFU_ABORT:
+			dev->dfu_state = DFU_STATE_dfuIDLE;
+			/* no zlp? */
+			ret = RET_ZLP;
+			break;
+		case USB_REQ_DFU_GETSTATUS:
+			handle_getstatus(urb, len);
+			break;
+		case USB_REQ_DFU_GETSTATE:
+			handle_getstate(urb, len);
+			break;
+		default:
+			dev->dfu_state = DFU_STATE_dfuERROR;
+			ret = RET_STALL;
+			break;
+		}
+		break;
+	case DFU_STATE_dfuERROR:
+		switch (req) {
+		case USB_REQ_DFU_GETSTATUS:
+			handle_getstatus(urb, len);
+			break;
+		case USB_REQ_DFU_GETSTATE:
+			handle_getstate(urb, len);
+			break;
+		case USB_REQ_DFU_CLRSTATUS:
+			dev->dfu_state = DFU_STATE_dfuIDLE;
+			dev->dfu_status = DFU_STATUS_OK;
+			/* no zlp? */
+			ret = RET_ZLP;
+			break;
+		default:
+			dev->dfu_state = DFU_STATE_dfuERROR;
+			ret = RET_STALL;
+			break;
+		}
+		break;
+	default:
+		return DFU_EP0_UNHANDLED;
+		break;
+	}
+
+out:
+	debug("new_state = %u, ret = %u\n", dev->dfu_state, ret);
+
+	switch (ret) {
+	case RET_ZLP:
+		//udc_ep0_send_zlp();
+		urb->actual_length = 0;
+		return DFU_EP0_ZLP;
+		break;
+	case RET_STALL:
+		//udc_ep0_send_stall();
+		return DFU_EP0_STALL;
+		break;
+	case RET_NOTHING:
+		break;
+	}
+
+	return DFU_EP0_DATA;
+}
+
+void str2wide (char *str, u16 * wide);
+static struct usb_string_descriptor *create_usbstring(char *string)
+{
+	struct usb_string_descriptor *strdesc;
+	int size = sizeof(*strdesc) + strlen(string)*2;
+
+	if (size > 255)
+		return NULL;
+
+	strdesc = malloc(size);
+	if (!strdesc)
+		return NULL;
+
+	strdesc->bLength = size;
+	strdesc->bDescriptorType = USB_DT_STRING;
+	str2wide(string, strdesc->wData);
+
+	return strdesc;
+}
+
+static void dfu_init_strings(struct usb_device_instance *dev)
+{
+	int i;
+	struct usb_string_descriptor *strdesc;
+
+	strdesc = create_usbstring(CONFIG_DFU_CFG_STR);
+	usb_strings[DFU_STR_CONFIG] = strdesc;
+
+	for (i = 0; i < DFU_NUM_ALTERNATES; i++) {
+		strdesc = create_usbstring(CONFIG_DFU_ALT0_STR);
+		usb_strings[STR_COUNT+i+1] = strdesc;
+	}
+}
+
+int dfu_init_instance(struct usb_device_instance *dev)
+{
+	int i;
+
+	for (i = 0; i != DFU_NUM_ALTERNATES; i++) {
+		struct usb_interface_descriptor *uif =
+			dfu_cfg_descriptor.uif+i;
+
+		uif->bLength		= USB_DT_INTERFACE_SIZE;
+		uif->bDescriptorType	= USB_DT_INTERFACE;
+		uif->bAlternateSetting	= i;
+		uif->bInterfaceClass	= 0xfe;
+		uif->bInterfaceSubClass	= 1;
+		uif->bInterfaceProtocol	= 2;
+		uif->iInterface		= DFU_STR_ALT(i);
+	}
+
+	dev->dfu_dev_desc = &dfu_dev_descriptor;
+	dev->dfu_cfg_desc = &dfu_cfg_descriptor;
+	dev->dfu_state = DFU_STATE_appIDLE;
+	dev->dfu_status = DFU_STATUS_OK;
+
+	if (system_dfu_state)
+		printf("SURPRISE: system_dfu_state is already set\n");
+	system_dfu_state = &dev->dfu_state;
+
+	dfu_init_strings(dev);
+
+	return 0;
+}
+
+static int stdout_switched;
+
+/* event handler for usb device state events */
+void dfu_event(struct usb_device_instance *device,
+			usb_device_event_t event, int data)
+{
+	char *out;
+
+	switch (event) {
+	case DEVICE_RESET:
+		switch (device->dfu_state) {
+		case DFU_STATE_appDETACH:
+			device->dfu_state = DFU_STATE_dfuIDLE;
+#ifndef CONFIG_LPC313X 
+			out = getenv("stdout");
+			if (out && !strcmp(out, "usbtty")) {
+				setenv("stdout", "vga");
+				setenv("stderr", "vga");
+				stdout_switched = 1;
+			}
+#endif
+			printf("DFU: Switching to DFU Mode\n");
+			break;
+		case DFU_STATE_dfuMANIFEST_WAIT_RST:
+			device->dfu_state = DFU_STATE_appIDLE;
+			if (stdout_switched) {
+				setenv("stdout", "usbtty");
+				setenv("stderr", "usbtty");
+				stdout_switched = 0;
+			}
+			break;
+		default:
+			break;
+		}
+		break;
+	case DEVICE_CONFIGURED:
+	case DEVICE_DE_CONFIGURED:
+		debug("SET_CONFIGURATION(%u) ", device->configuration);
+		/* fallthrough */
+	case DEVICE_SET_INTERFACE:
+		debug("SET_INTERFACE(%u,%u) old_state = %u ",
+			device->interface, device->alternate,
+			device->dfu_state);
+		switch (device->dfu_state) {
+		case DFU_STATE_appIDLE:
+		case DFU_STATE_appDETACH:
+		case DFU_STATE_dfuIDLE:
+		case DFU_STATE_dfuMANIFEST_WAIT_RST:
+			/* do nothing, we're fine */
+			break;
+		case DFU_STATE_dfuDNLOAD_SYNC:
+		case DFU_STATE_dfuDNBUSY:
+		case DFU_STATE_dfuDNLOAD_IDLE:
+		case DFU_STATE_dfuMANIFEST:
+			device->dfu_state = DFU_STATE_dfuERROR;
+			device->dfu_status = DFU_STATUS_errNOTDONE;
+			/* FIXME: free malloc()ed buffer! */
+			break;
+		case DFU_STATE_dfuMANIFEST_SYNC:
+		case DFU_STATE_dfuUPLOAD_IDLE:
+		case DFU_STATE_dfuERROR:
+			device->dfu_state = DFU_STATE_dfuERROR;
+			device->dfu_status = DFU_STATUS_errUNKNOWN;
+			break;
+		}
+		debug("new_state = %u\n", device->dfu_state);
+		printf("new_state = %u\n", device->dfu_state);
+		break;
+	default:
+		break;
+	}
+}
+#endif /* CONFIG_USB_DFU */
diff --git a/drivers/usb/gadget/ep0.c b/drivers/usb/gadget/ep0.c
index 22499d3..13f3c24 100644
--- a/drivers/usb/gadget/ep0.c
+++ b/drivers/usb/gadget/ep0.c
@@ -51,8 +51,14 @@
  */
 
 #include <common.h>
+DECLARE_GLOBAL_DATA_PTR;
+
 #include <usbdevice.h>
 
+#ifdef CONFIG_USB_DFU
+#include <usb_dfu.h>
+#endif
+
 #if 0
 #define dbg_ep0(lvl,fmt,args...) serial_printf("[%s] %s:%d: "fmt"\n",__FILE__,__FUNCTION__,__LINE__,##args)
 #else
@@ -274,8 +280,26 @@ static int ep0_get_descriptor (struct usb_device_instance *device,
 	case USB_DESCRIPTOR_TYPE_ENDPOINT:
 		serial_printf("USB_DESCRIPTOR_TYPE_ENDPOINT - error not implemented\n");
 		return -1;
+	/* This really means "Class Specific Descriptor #1 == USB_DT_DFU */
 	case USB_DESCRIPTOR_TYPE_HID:
+#ifdef CONFIG_USB_DFU
 		{
+			int bNumInterface =
+				le16_to_cpu(urb->device_request.wIndex);
+
+			/* In runtime mode, we only respond to the DFU INTERFACE,
+			 * whereas in DFU mode, we respond for all intrfaces */
+			if (device->dfu_state != DFU_STATE_appIDLE &&
+					device->dfu_state != DFU_STATE_appDETACH ||
+					bNumInterface == CONFIG_USBD_DFU_INTERFACE) {
+				urb->actual_length = sizeof(struct usb_dfu_func_descriptor);
+				memcpy(urb->buffer,(void *)&device->dfu_cfg_desc->func_dfu,
+						urb->actual_length);
+			} else
+				return -1;
+		}
+#else /* CONFIG_USB_DFU */
+
 			serial_printf("USB_DESCRIPTOR_TYPE_HID - error not implemented\n");
 			return -1;	/* unsupported at this time */
 #if 0
@@ -286,22 +310,23 @@ static int ep0_get_descriptor (struct usb_device_instance *device,
 			struct usb_class_descriptor *class_descriptor;
 
 			if (!(class_descriptor =
-			      usbd_device_class_descriptor_index (device,
-								  port, 0,
-								  bNumInterface,
-								  bAlternateSetting,
-								  class))
-			    || class_descriptor->descriptor.hid.bDescriptorType != USB_DT_HID) {
+						usbd_device_class_descriptor_index (device,
+							port, 0,
+							bNumInterface,
+							bAlternateSetting,
+							class))
+					|| class_descriptor->descriptor.hid.bDescriptorType != USB_DT_HID) {
 				dbg_ep0 (3, "[%d] interface is not HID",
-					 bNumInterface);
+						bNumInterface);
 				return -1;
 			}
 			/* copy descriptor for this class */
 			copy_config (urb, class_descriptor,
-				     class_descriptor->descriptor.hid.bLength,
-				     max);
+					class_descriptor->descriptor.hid.bLength,
+					max);
 #endif
 		}
+#endif /* CONFIG_USB_DFU */
 		break;
 	case USB_DESCRIPTOR_TYPE_REPORT:
 		{
@@ -315,13 +340,13 @@ static int ep0_get_descriptor (struct usb_device_instance *device,
 			struct usb_class_report_descriptor *report_descriptor;
 
 			if (!(report_descriptor =
-			      usbd_device_class_report_descriptor_index
-			      (device, port, 0, bNumInterface,
-			       bAlternateSetting, class))
-			    || report_descriptor->bDescriptorType !=
-			    USB_DT_REPORT) {
+						usbd_device_class_report_descriptor_index
+						(device, port, 0, bNumInterface,
+						 bAlternateSetting, class))
+					|| report_descriptor->bDescriptorType !=
+					USB_DT_REPORT) {
 				dbg_ep0 (3, "[%d] descriptor is not REPORT",
-					 bNumInterface);
+						bNumInterface);
 				return -1;
 			}
 			/* copy report descriptor for this class */
@@ -329,9 +354,9 @@ static int ep0_get_descriptor (struct usb_device_instance *device,
 			if (max - urb->actual_length > 0) {
 				int length =
 					MIN (report_descriptor->wLength,
-					     max - urb->actual_length);
+							max - urb->actual_length);
 				memcpy (urb->buffer + urb->actual_length,
-					&report_descriptor->bData[0], length);
+						&report_descriptor->bData[0], length);
 				urb->actual_length += length;
 			}
 #endif
@@ -353,12 +378,12 @@ static int ep0_get_descriptor (struct usb_device_instance *device,
 		 urb->buffer, urb->buffer_length, urb->actual_length,
 		 device->bus->endpoint_array[0].tx_packetSize);
 /*
-    if ((urb->actual_length < max) && !(urb->actual_length % device->bus->endpoint_array[0].tx_packetSize)) {
+   if ((urb->actual_length < max) && !(urb->actual_length % device->bus->endpoint_array[0].tx_packetSize)) {
 	dbg_ep0(0, "adding null byte");
 	urb->buffer[urb->actual_length++] = 0;
 	dbg_ep0(0, "urb: buffer_length: %2d actual_length: %2d packet size: %2d",
 		urb->buffer_length, urb->actual_length device->bus->endpoint_array[0].tx_packetSize);
-    }
+		}
 */
 	return 0;
 
@@ -403,6 +428,25 @@ int ep0_recv_setup (struct urb *urb)
 		 le16_to_cpu (request->wLength),
 		 USBD_DEVICE_REQUESTS (request->bRequest));
 
+#ifdef CONFIG_USB_DFU
+	if ((request->bmRequestType & 0x3f) == USB_TYPE_DFU &&
+			(device->dfu_state != DFU_STATE_appIDLE ||
+			 le16_to_cpu(request->wIndex) == CONFIG_USBD_DFU_INTERFACE)) {
+		int rc = dfu_ep0_handler(urb);
+		switch (rc) {
+			case DFU_EP0_NONE:
+			case DFU_EP0_UNHANDLED:
+				break;
+			case DFU_EP0_ZLP:
+			case DFU_EP0_DATA:
+				return 0;
+			case DFU_EP0_STALL:
+				//return -1;
+				return 0;
+		}
+	}
+#endif /* CONFIG_USB_DFU */
+
 	/* handle USB Standard Request (c.f. USB Spec table 9-2) */
 	if ((request->bmRequestType & USB_REQ_TYPE_MASK) != 0) {
 		if(device->device_state <= STATE_CONFIGURED){
@@ -580,7 +624,9 @@ int ep0_recv_setup (struct urb *urb)
 			device->interface = le16_to_cpu (request->wIndex);
 			device->alternate = le16_to_cpu (request->wValue);
 			/*dbg_ep0(2, "set interface: %d alternate: %d", device->interface, device->alternate); */
-			serial_printf ("DEVICE_SET_INTERFACE.. event?\n");
+			usbd_device_event_irq(device, DEVICE_SET_INTERFACE,
+					(request->wIndex << 16 | request->wValue));
+
 			return 0;
 
 		case USB_REQ_GET_STATUS:
diff --git a/drivers/usb/gadget/lpc313x_udc.c b/drivers/usb/gadget/lpc313x_udc.c
new file mode 100644
index 0000000..af61758
--- /dev/null
+++ b/drivers/usb/gadget/lpc313x_udc.c
@@ -0,0 +1,737 @@
+/*
+ * (C) Copyright 2010 NXP Semiconductors
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <config.h>
+#include <asm/byteorder.h>
+#include <usbdevice.h>
+#include <asm/arch/hardware.h>
+#include <asm/arch/clock.h>
+#include <asm/arch/sysreg.h>
+#include <usb/lpc313x_udc.h>
+#include "ep0.h"
+
+#define DQH_BASE	(EXT_SDRAM_BASE)
+#define DTD_BASE	(DQH_BASE + EP_NUM_MAX * sizeof(DQH_T))
+
+DQH_T* const ep_QH = (DQH_T*)DQH_BASE;
+DTD_T* const ep_TD = (DTD_T*)DTD_BASE;
+u32 ep_read_len[4];
+
+static struct urb *ep0_urb = NULL;
+static struct usb_device_instance *udc_device;
+static int ep0state = EP0_IDLE;
+u8 device_address = 0;
+
+static struct usb_endpoint_instance *lpc313x_find_ep(int ep)
+{
+	int i;
+
+	for (i = 0; i < udc_device->bus->max_endpoints; i++) {
+		if (udc_device->bus->endpoint_array[i].endpoint_address == ep)
+			return &udc_device->bus->endpoint_array[i];
+	}
+	return NULL;
+}
+
+static u32 get_ep_phy_addr(u32 EPNum)
+{
+	u32 val;
+
+	val = (EPNum & 0x0F) << 1;
+	if (EPNum & 0x80) {
+		val += 1;
+	}
+	return (val);
+}
+
+static u32 get_ep_logical_addr(u32 endpoint_addr)
+{
+	return (endpoint_addr >> 1);
+}
+
+static void udc_setAddress(u32 adr)
+{
+        USB_OTG->periodiclistbase__deviceaddr = USBDEV_ADDR(adr);
+        USB_OTG->periodiclistbase__deviceaddr |= USBDEV_ADDR_AD;
+}
+
+static void udc_progDTD(u32 Edpt, u32 ptrBuff, u32 TsfSize)
+{
+	DTD_T* pDTD;
+
+	pDTD = (DTD_T*) &ep_TD [Edpt];
+
+	/* Zero out the device transfer descriptors */
+	memset((void*)pDTD, 0, sizeof(DTD_T));
+	/* The next DTD pointer is INVALID */
+	pDTD->next_dTD = 0x01;
+
+	/* Length */
+	pDTD->total_bytes = ((TsfSize & 0x7fff) << 16);
+	pDTD->total_bytes |= TD_IOC;
+	pDTD->total_bytes |= 0x80;
+
+	pDTD->buffer0 = ptrBuff;
+	pDTD->buffer1 = (ptrBuff + 0x1000) & 0xfffff000;
+	pDTD->buffer2 = (ptrBuff + 0x2000) & 0xfffff000;
+	pDTD->buffer3 = (ptrBuff + 0x3000) & 0xfffff000;
+	pDTD->buffer4 = (ptrBuff + 0x4000) & 0xfffff000;
+
+	ep_QH[Edpt].next_dTD = (u32)(&ep_TD[Edpt]);
+	ep_QH[Edpt].total_bytes &= (~0xC0);
+}
+
+static u32 udc_write_urb(u32 EPNum, struct usb_endpoint_instance *endpoint)
+{
+	u32 n = USB_EP_BITPOS(EPNum);
+	struct urb *urb = endpoint->tx_urb;
+	u32 length = urb->actual_length;
+
+	if (!urb)
+		return -1;
+
+	if(length == 0x0)
+		udc_progDTD(get_ep_phy_addr(EPNum), NULL, length);
+	else
+		udc_progDTD(get_ep_phy_addr(EPNum), (u32)(urb->buffer + endpoint->sent),
+				length);
+	/* prime the endpoint for transmit */
+	USB_OTG->endptprime |= _BIT(n);
+
+	/* check if priming succeeded */
+	while (USB_OTG->endptprime & _BIT(n));
+
+	endpoint->last = length;
+
+	if((EPNum & 0x7F) != 0x0) {
+		usbd_tx_complete(endpoint);
+	}
+	else {
+		endpoint->sent += length;
+		endpoint->last -= length;
+
+		if( (urb->actual_length - endpoint->sent) <= 0 ) {
+			urb->actual_length = 0;
+			endpoint->sent = 0;
+			endpoint->last = 0;
+		}
+	}
+	if(endpoint->tx_urb->actual_length == 0x0 && ep0state == EP0_IN_DATA) {
+		ep0state = EP0_STATUS_OUT;
+	}
+	else if(endpoint->tx_urb->actual_length == 0x0 && ep0state == EP0_OUT_DATA) {
+		ep0state = EP0_IDLE;
+	}
+
+	return 0;
+}
+
+static u32 udc_read_urb(u32 EPNum, struct usb_endpoint_instance *endpoint)
+{
+	u32 bytes_read, n;
+	DTD_T* pDTD;
+
+	n = get_ep_phy_addr(EPNum);
+	pDTD = (DTD_T*) &ep_TD [n];
+
+	/* return the total bytes read */
+	bytes_read = (pDTD->total_bytes >> 16) & 0x7FFF;
+	bytes_read = ep_read_len[EPNum & 0x0F] - bytes_read;
+
+	if(EPNum == 0x0) {
+		ep0_urb->actual_length += bytes_read;
+	}
+	else {
+		usbd_rcv_complete(endpoint, bytes_read, 0);
+	}
+
+	return 0;
+}
+
+static u32 udc_readReqEP(u32 EPNum, u8 *pData, u32 len) 
+{
+	u32 num = get_ep_phy_addr(EPNum);
+	u32 n = USB_EP_BITPOS(EPNum);
+
+	udc_progDTD(num, (u32)pData, len);
+	ep_read_len[EPNum & 0x0F] = len;
+
+	/* prime the endpoint for read */
+	USB_OTG->endptprime |= _BIT(n);
+
+	return len;
+}
+
+static void udc_setStallEP(u32 EPNum)
+{
+	u32 lep;
+
+	lep = EPNum & 0x0F;
+	if (EPNum & 0x80) {
+		USB_OTG->endptctrl[lep] |= EPCTRL_TXS;
+	} else {
+		USB_OTG->endptctrl[lep] |= EPCTRL_RXS;
+	}
+}
+
+static u32 udc_readSetupPkt(u32 num, u32 *pdata)
+{
+	u32 setup_int, cnt = 0;
+
+	setup_int = USB_OTG->endptsetupstat;
+	
+	/* No setup are admitted on other endpoints than 0 */
+	if (setup_int & _BIT(0)) {
+		/* Clear the setup interrupt */
+		USB_OTG->endptsetupstat = setup_int;
+
+		do {
+			/* Setup in a setup - must considere only the second setup */
+			/*- Set the tripwire */
+			USB_OTG->usbcmd |= USBCMD_SUTW;
+
+			/* Transfer Set-up data to the gtmudsCore_Request buffer */
+			pdata[0] = ep_QH[num].setup[0];
+			pdata[1] = ep_QH[num].setup[1];
+			cnt = 8;
+
+		} while (!(USB_OTG->usbcmd & USBCMD_SUTW));
+
+		/* setup in a setup - Clear the tripwire */
+		USB_OTG->usbcmd &= (~USBCMD_SUTW);
+	}
+	return cnt;
+}
+
+static int udc_handle_dfu_req(void)
+{
+
+	struct usb_device_request *request = &ep0_urb->device_request;
+
+	if((request->bmRequestType & 0x3f) != USB_TYPE_DFU) {
+		printf("Error: not DFU Class Request\n");
+		return -1;
+	}
+
+	switch(request->bRequest) {
+	case USB_REQ_DFU_DNLOAD:
+		break;
+	case USB_REQ_DFU_DETACH:
+	case USB_REQ_DFU_UPLOAD:
+	case USB_REQ_DFU_GETSTATUS:
+	case USB_REQ_DFU_CLRSTATUS:
+	case USB_REQ_DFU_GETSTATE:
+	case USB_REQ_DFU_ABORT:
+		ep0_recv_setup(ep0_urb);
+		break;
+	default:
+		break;
+	}
+	return 0;
+}
+
+static int udc_handle_ep0(u32 event)
+{
+	struct usb_endpoint_instance *endpoint;
+	struct usb_device_request *request = &ep0_urb->device_request;
+	u32 transfer_size = 0;
+
+	endpoint = lpc313x_find_ep(0x00);
+
+	switch(ep0state) {
+	case EP0_IDLE:
+		if(event == USB_EVT_SETUP) {
+			udc_readSetupPkt(0x00, (u32 *)&ep0_urb->device_request);
+			/* Handle setup stage without having data stage */
+			if (ep0_urb->device_request.wLength == 0) {
+				if (ep0_recv_setup(ep0_urb)) {
+					usberr("!!!!!!!can't parse setup packet\n");
+					goto stall;
+				}
+				/* Manually Set Address */
+				if(ep0_urb->device_request.bRequest == USB_REQ_SET_ADDRESS) {
+					//device_address = 0x80 | udc_device->address;
+					usbd_device_event_irq(udc_device,
+							DEVICE_ADDRESS_ASSIGNED,0);
+					endpoint->tx_urb = ep0_urb;
+					udc_write_urb(0x80,endpoint);
+          printf("set_addr%x\n",udc_device->address);
+					//udelay(1);
+					//udc_setAddress(udc_device->address);
+					ep0state = EP0_IDLE;
+				}
+
+				if ((ep0_urb->device_request.bmRequestType &
+						USB_REQ_DIRECTION_MASK)
+						== USB_REQ_DEVICE2HOST) {
+					ep0state = EP0_STATUS_OUT;
+				}
+				else {
+					if(ep0_urb->device_request.bRequest != USB_REQ_SET_ADDRESS) {
+						endpoint->tx_urb = ep0_urb;
+						udc_write_urb(0x80,endpoint);
+						ep0state = EP0_IDLE;
+					}
+				}
+			}
+			/* Handle setup stage having data stage */
+			else {
+				/* Check direction */
+				if ((ep0_urb->device_request.bmRequestType &
+							USB_REQ_DIRECTION_MASK)
+						== USB_REQ_HOST2DEVICE) {
+					/* Handle DFU Class request sepratley */
+					if ((request->bmRequestType & 0x3f) != USB_TYPE_DFU) {
+						if (ep0_recv_setup(ep0_urb)) {
+							usberr(".....can't parse SETUP packet\n");
+							ep0state = EP0_IDLE;
+							goto stall;
+						}
+					}
+					else
+						udc_handle_dfu_req();
+					ep0state = EP0_OUT_DATA;
+					ep0_urb->actual_length = 0;
+				}
+				else {
+					if (ep0_recv_setup(ep0_urb)) {
+						usberr("@@@@@@can't parse setup packet\n");
+						ep0state = EP0_IDLE;
+						goto stall;
+					}
+					ep0state = EP0_IN_DATA;
+					endpoint->tx_urb = ep0_urb;
+					udc_write_urb(0x80,endpoint);
+				}
+			}
+		}
+        /* temporary fix */
+    else if (event == USB_EVT_IN_COMPLETE) 
+      udc_setAddress(udc_device->address);
+
+		break;
+	case EP0_OUT_DATA:
+		if(event == USB_EVT_OUT_NAK ) {
+			if ((ep0_urb->device_request.bmRequestType & 
+					USB_REQ_DIRECTION_MASK) == USB_REQ_HOST2DEVICE) {
+				if ((request->bmRequestType & 0x3f) == USB_TYPE_DFU)
+					transfer_size = le16_to_cpu (ep0_urb->device_request.wLength);
+				else
+					transfer_size = endpoint->rcv_transferSize;
+				udc_readReqEP(0x00, ep0_urb->buffer +
+						ep0_urb->actual_length,
+						transfer_size);
+			}
+		}
+		else if(event == USB_EVT_OUT_COMPLETE) {
+			udc_read_urb(0x00,endpoint);
+			if (ep0_recv_setup(ep0_urb)) {
+				usberr("can't parse setup packet\n");
+				ep0state = EP0_IDLE;
+				goto stall;
+			}
+			ep0state = EP0_STATUS_IN;
+		}
+		break;
+	case EP0_IN_DATA:
+		if(event == USB_EVT_IN_COMPLETE) {
+			endpoint->tx_urb = ep0_urb;
+			udc_write_urb(0x80,endpoint);
+		}
+		break;
+	case EP0_STATUS_IN:
+		ep0_urb->actual_length = 0;
+		endpoint->tx_urb = ep0_urb;
+		udc_write_urb(0x80,endpoint);
+		ep0state = EP0_IDLE;
+		break;
+	case EP0_STATUS_OUT:
+		if(event == USB_EVT_OUT_NAK ) {
+			/* might be zero length pkt */
+			// printf("Zero Len\n");
+			udc_readReqEP(0x00, ep0_urb->buffer, 0);
+		}
+		else if (event == USB_EVT_OUT_COMPLETE) {
+			/* Read zero length packet */
+			udc_read_urb(0x00,endpoint);
+			ep0state = EP0_IDLE;
+		}
+		break;
+	}
+	return 0;
+stall:
+	udc_setStallEP(0x80);
+
+	return -1;
+}
+
+void udc_handle_ep(u32 num, u32 event)
+{
+
+	struct usb_endpoint_instance *endpoint;
+	u32 epnum = get_ep_phy_addr(num);
+	endpoint = lpc313x_find_ep(epnum);
+
+	if((num & 0x7F) == 0x0) {
+	  udc_handle_ep0(event);
+		return;
+	}
+
+	switch (event) {
+	case USB_EVT_OUT_NAK:
+		udc_readReqEP(num, endpoint->rcv_urb->buffer +
+				endpoint->rcv_urb->actual_length,
+				endpoint->rcv_packetSize);
+		break;
+	case USB_EVT_OUT_COMPLETE:
+		udc_read_urb(num,endpoint);
+		break;
+	case USB_EVT_IN_COMPLETE:
+		udc_write_urb(num,endpoint);
+		break;
+	}
+}
+
+/*
+ * USB Public functions
+ */
+void udc_reset(void)
+{
+	u32 i = 0;
+
+	/* disable all EPs */
+	USB_OTG->endptctrl[1] &= ~(EPCTRL_RXE | EPCTRL_TXE);
+	USB_OTG->endptctrl[2] &= ~(EPCTRL_RXE | EPCTRL_TXE);
+	USB_OTG->endptctrl[3] &= ~(EPCTRL_RXE | EPCTRL_TXE);
+
+	/* Clear all pending interrupts */
+	USB_OTG->endptnak = 0xFFFFFFFF;
+	USB_OTG->endptnaken = 0;
+	USB_OTG->usbsts = 0xFFFFFFFF;
+	USB_OTG->endptsetupstat = USB_OTG->endptsetupstat;
+	USB_OTG->endptcomplete = USB_OTG->endptcomplete;
+   
+	/* Wait until all bits are 0 */
+	while (USB_OTG->endptprime) {}
+	USB_OTG->endptflush = 0xFFFFFFFF;
+	while (USB_OTG->endptflush); /* Wait until all bits are 0 */
+
+	/* Set the interrupt Threshold control interval to 0 */
+	USB_OTG->usbcmd &= ~0x00FF0000;
+
+	/* Zero out the Endpoint queue heads */
+	memset((void*)ep_QH, 0, EP_NUM_MAX * sizeof(DQH_T));
+	/* Zero out the device transfer descriptors */
+	memset((void*)ep_TD, 0, EP_NUM_MAX * sizeof(DTD_T));
+	memset((void*)ep_read_len, 0, sizeof(ep_read_len));
+	/* Configure the Endpoint List Address */
+	/* make sure it in on 64 byte boundary !!! */
+	/* init list address */
+	USB_OTG->asynclistaddr__endpointlistaddr = (u32)ep_QH;
+	/* Initialize device queue heads for non ISO endpoint only */
+	for (i = 0; i < EP_NUM_MAX; i++) {
+		ep_QH[i].next_dTD = (u32)&ep_TD[i];
+	}
+	/* Enable interrupts */
+	USB_OTG->usbintr = USBSTS_UI
+		| USBSTS_UEI
+		| USBSTS_PCI
+		| USBSTS_URI
+		| USBSTS_SLI
+		| USBSTS_NAKI;
+}
+
+static void udc_init_endpoints(void)
+{
+	u32 i = 0;
+
+	for (i = 1; i < udc_device->bus->max_endpoints; i++) {
+		udc_setup_ep (udc_device, i, &udc_device->bus->endpoint_array[i]);
+	}
+
+}
+void udc_irq(void)
+{
+	u32 disr, val, n;
+	struct usb_endpoint_instance *ep0 = udc_device->bus->endpoint_array;
+
+	disr = USB_OTG->usbsts; /* Device Interrupt Status */
+	USB_OTG->usbsts = disr;
+
+	/* Device Status Interrupt (Reset, Connect change, Suspend/Resume) */
+	if (disr & USBSTS_URI) { 
+		printf("USB get RESET interrupt\n");
+		udc_reset();
+		udc_setup_ep(udc_device,0,ep0);
+		usbd_device_event_irq (udc_device, DEVICE_RESET, 0);
+		udc_init_endpoints();
+		goto isr_end;
+	}
+
+	if (disr & USBSTS_SLI) {
+		printf("USB get suspend interrupt\n");
+		goto isr_end;
+	}
+
+	if (disr & USBSTS_PCI) {
+		goto isr_end;
+	}
+
+	/* handle completion interrupts */
+	val = USB_OTG->endptcomplete;
+	if (val) {
+		USB_OTG->endptnak = val;
+		for (n = 0; n < EP_NUM_MAX / 2; n++) {
+			if (val & _BIT(n)) {
+				udc_handle_ep(n,USB_EVT_OUT_COMPLETE);
+				USB_OTG->endptcomplete = _BIT(n);
+			}
+			if (val & _BIT(n + 16)) {
+				ep_TD [(n << 1) + 1 ].total_bytes &= 0xC0;
+				udc_handle_ep(n | 0x80,USB_EVT_IN_COMPLETE);
+				USB_OTG->endptcomplete = _BIT(n + 16);
+			}
+		}
+	}
+
+	/* handle setup status interrupts */
+	val = USB_OTG->endptsetupstat;
+	/* Only EP0 will have setup packets so call EP0 handler */
+	if (val) {
+
+		/* Clear the endpoint complete CTRL OUT & IN when */
+		/* a Setup is received */
+		USB_OTG->endptcomplete = 0x00010001;
+		/* enable NAK inetrrupts */
+		USB_OTG->endptnaken |= 0x00010001;
+		udc_handle_ep0(USB_EVT_SETUP);
+	}
+
+	if (disr & USBSTS_NAKI) {
+		val = USB_OTG->endptnak;
+		val &= USB_OTG->endptnaken;
+		/* handle NAK interrupts */
+		if (val) {
+			for (n = 0; n < EP_NUM_MAX/2; n++) {
+
+				if (val & _BIT(n)) {
+					udc_handle_ep(n,USB_EVT_OUT_NAK);
+				}
+				if (val & _BIT(n + 16)) {
+					udc_handle_ep(n | 0x80,USB_EVT_IN_NAK);
+				}
+			}
+			USB_OTG->endptnak = val;
+		}
+	}
+isr_end:
+	return;
+}
+
+/*
+ * udc_set_nak
+ *
+ * Allow upper layers to signal lower layers should not accept more RX data
+ */
+void udc_set_nak(int ep_num)
+{
+	return;
+}
+
+/*
+ * udc_unset_nak
+ *
+ * Suspend sending of NAK tokens for DATA OUT tokens on a given endpoint.
+ * Switch off NAKing on this endpoint to accept more data output from host.
+ */
+void udc_unset_nak(int ep_num)
+{
+	return;
+}
+
+int udc_endpoint_write(struct usb_endpoint_instance *endpoint)
+{
+	return udc_write_urb(get_ep_logical_addr(endpoint->endpoint_address & 0x7F),
+			endpoint);
+}
+
+/* Associate a physical endpoint with endpoint instance */
+void udc_setup_ep(struct usb_device_instance *device, unsigned int id,
+		struct usb_endpoint_instance *endpoint)
+{
+	u32 epnum, lepnum;
+	u32 ep_cfg;
+	u32 bitpos;
+
+	if (!endpoint) {
+		usberr("endpoint void!");
+		return;
+	}
+
+	epnum = endpoint->endpoint_address & USB_ENDPOINT_NUMBER_MASK;
+	if (epnum >= EP_NUM_MAX) {
+		usberr("unable to setup ep %d!", epnum);
+		return;
+	}
+
+	if(epnum == 0 || epnum == 1) {
+		/* enable ep0 IN and ep0 OUT */
+		ep_QH[0].cap = QH_MAXP(EP0_MAX_PACKET_SIZE)
+			| QH_IOS
+			| QH_ZLT;
+		ep_QH[1].cap = QH_MAXP(EP0_MAX_PACKET_SIZE)
+			| QH_IOS
+			| QH_ZLT;
+		/* enable EP0 */
+		USB_OTG->endptctrl[0] = EPCTRL_RXE | EPCTRL_RXR | EPCTRL_TXE | EPCTRL_TXR;
+
+		return;
+	}
+
+	/* Get logical address of endpoint */
+	lepnum = get_ep_logical_addr(epnum);
+	ep_cfg = USB_OTG->endptctrl[lepnum];
+
+	/* set EP type */
+	if (endpoint->tx_attributes != USB_ENDPOINT_XFER_ISOC) {
+		/* init EP capabilities */
+		ep_QH[epnum].cap = QH_MAXP(endpoint->tx_packetSize)
+			| QH_IOS
+			| QH_ZLT ;
+		/* The next DTD pointer is INVALID */
+		ep_TD[epnum].next_dTD = 0x01 ;
+	} else {
+		/* init EP capabilities */
+		ep_QH[epnum].cap  = QH_MAXP(0x400) | QH_ZLT ;
+	}
+	/* setup EP control register */
+	if (endpoint->endpoint_address & 0x80) {
+		ep_cfg &= ~0xFFFF0000;
+		ep_cfg |= EPCTRL_TX_TYPE(endpoint->tx_attributes)
+			| EPCTRL_TXR;
+	} else {
+		ep_cfg &= ~0xFFFF;
+		ep_cfg |= EPCTRL_RX_TYPE(endpoint->rcv_attributes)
+			| EPCTRL_RXR;
+	}
+
+	USB_OTG->endptctrl[lepnum] = ep_cfg;
+
+	/* Enable Endpoint */
+	if (lepnum & 0x80) {
+		USB_OTG->endptctrl[lepnum] |= EPCTRL_TXE;
+	} else {
+		USB_OTG->endptctrl[lepnum] |= EPCTRL_RXE;
+		/* enable NAK interrupt */
+		bitpos = USB_EP_BITPOS(lepnum); 
+		USB_OTG->endptnaken |= _BIT(bitpos);
+	}
+
+	/* Flush EP buffers */
+	USB_OTG->endptflush = _BIT(bitpos);
+	while (USB_OTG->endptflush & _BIT(bitpos));
+
+	/* reset data toggles */
+	if (lepnum & 0x80) {
+		USB_OTG->endptctrl[lepnum] |= EPCTRL_TXE;
+	} else {
+		USB_OTG->endptctrl[lepnum] |= EPCTRL_RXE;
+	}
+
+	return;
+}
+
+/* Connect the USB device to the bus */
+void udc_connect(void)
+{
+	USB_OTG->usbcmd |= USBCMD_RS;
+}
+
+/* Disconnect the USB device to the bus */
+void udc_disconnect(void)
+{
+	USB_OTG->usbcmd &= ~USBCMD_RS;
+}
+
+void udc_shutdown (void)
+{
+	/* reset the controller */
+	USB_OTG->usbcmd = USBCMD_RST;
+
+	/* wait for reset to complete */
+	while (USB_OTG->usbcmd & USBCMD_RST);
+
+	/* reset USB block */
+	cgu_soft_reset_module(USB_OTG_AHB_RST_N_SOFT);
+
+	/* disable USB to AHB clock */
+	cgu_clk_en_dis(CGU_SB_USB_OTG_AHB_CLK_ID, 0);
+
+	/* disable USB OTG PLL */
+	SYS_REGS->usb_atx_pll_pd_reg = 0x1;
+}
+
+/* Allow udc code to do any additional startup */
+void udc_startup_events(struct usb_device_instance *device)
+{
+	/* The DEVICE_INIT event puts the USB device in the state STATE_INIT. */
+	usbd_device_event_irq (device, DEVICE_INIT, 0);
+
+	/* The DEVICE_CREATE event puts the USB device in the state
+	 * STATE_ATTACHED.
+	 */
+	usbd_device_event_irq (device, DEVICE_CREATE, 0);
+
+	udc_device = device;
+
+	if (!ep0_urb)
+		ep0_urb = usbd_alloc_urb(udc_device,
+				udc_device->bus->endpoint_array);
+	else
+		usbinfo("ep0_urb %p already allocated", ep0_urb);
+}
+
+/* Initialize h/w stuff */
+int udc_init(void)
+{
+	/* USB clock is already initialized in lpc313x_init().
+	 * so not doing again here.
+	 */
+	/* enable USB AHB clock */
+	cgu_clk_en_dis(CGU_SB_USB_OTG_AHB_CLK_ID, 1);
+
+	/* reset the controller */
+	USB_OTG->usbcmd = USBCMD_RST;
+	/* wait for reset to complete */
+	while (USB_OTG->usbcmd & USBCMD_RST);
+
+	/* Program the controller to be the USB device controller */
+	USB_OTG->usbmode = USBMODE_CM_DEV
+		/*| USBMODE_SDIS*/
+		| USBMODE_SLOM ;
+
+	/* init UDC now */
+	udc_reset();
+	udc_setAddress(0);
+	return 0;
+}
diff --git a/drivers/usb/host/Makefile b/drivers/usb/host/Makefile
index 77e217f..8d68dd2 100644
--- a/drivers/usb/host/Makefile
+++ b/drivers/usb/host/Makefile
@@ -48,6 +48,7 @@ COBJS-$(CONFIG_USB_EHCI_IXP4XX) += ehci-ixp.o
 COBJS-$(CONFIG_USB_EHCI_KIRKWOOD) += ehci-kirkwood.o
 COBJS-$(CONFIG_USB_EHCI_PCI) += ehci-pci.o
 COBJS-$(CONFIG_USB_EHCI_VCT) += ehci-vct.o
+COBJS-$(CONFIG_USB_EHCI_LPC313X) += ehci-lpc313x.o
 
 COBJS	:= $(COBJS-y)
 SRCS	:= $(COBJS:.o=.c)
diff --git a/drivers/usb/host/ehci-lpc313x.c b/drivers/usb/host/ehci-lpc313x.c
new file mode 100644
index 0000000..dc04ef9
--- /dev/null
+++ b/drivers/usb/host/ehci-lpc313x.c
@@ -0,0 +1,75 @@
+/*
+ * (C) Copyright 2010 NXP Semiconductors
+ *  
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *  
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *  
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *   
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <asm/arch/hardware.h>
+#include <common.h>
+#include <usb.h>
+
+#include "ehci.h"
+#include "ehci-core.h"
+
+/* board specific externa function*/
+extern int lpc31xx_enable_vbus(int en);
+
+/*
+ * Create the appropriate control structures to manage
+ * a new EHCI host controller.
+ */
+int ehci_hcd_init(void)
+{
+	uint32_t cmd;
+	int ret = 0;
+
+	hccr = (struct ehci_hccr *)(USBOTG_BASE + 0x100);
+	hcor = (struct ehci_hcor *)((uint32_t) hccr
+			+ HC_LENGTH(ehci_readl(&hccr->cr_capbase)));
+
+	printf("LPC31xx init hccr %x and hcor %x hc_length %d\n",
+			(uint32_t)hccr, (uint32_t)hcor,
+			(uint32_t)HC_LENGTH(ehci_readl(&hccr->cr_capbase)));
+
+	/* now enable VBUS power */
+	ret = lpc31xx_enable_vbus(1);
+	/* reset the controller */
+	ehci_writel(USBOTG_BASE + 0x140, 0x2);
+	/* wait for reset to complete */
+	do {
+		cmd = ehci_readl(USBOTG_BASE + 0x140);
+	} while (cmd & 0x2);
+
+
+	//cmd = ehci_readl(USBOTG_BASE + 0x1A8);
+	//cmd |= 0x03;
+	ehci_writel(USBOTG_BASE + 0x1A8, 0x03);
+
+	return ret;
+}
+
+/*
+ * Destroy the appropriate control structures corresponding
+ * the the EHCI host controller.
+ */
+int ehci_hcd_stop(void)
+{
+	/* disable VBUS power */
+	return lpc31xx_enable_vbus(0);
+}
diff --git a/fs/ext2/dev.c b/fs/ext2/dev.c
index 874e211..f2cd9af 100644
--- a/fs/ext2/dev.c
+++ b/fs/ext2/dev.c
@@ -23,7 +23,7 @@
  *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
  */
 
-
+#define DEBUG
 #include <common.h>
 #include <config.h>
 #include <ext2fs.h>
diff --git a/fs/ext2/ext2fs.c b/fs/ext2/ext2fs.c
index e119e13..c31164f 100644
--- a/fs/ext2/ext2fs.c
+++ b/fs/ext2/ext2fs.c
@@ -22,6 +22,7 @@
  *  along with this program; if not, write to the Free Software
  *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
  */
+#define DEBUG
 
 #include <common.h>
 #include <ext2fs.h>
diff --git a/include/configs/ea3131.h b/include/configs/ea3131.h
new file mode 100644
index 0000000..47f5231
--- /dev/null
+++ b/include/configs/ea3131.h
@@ -0,0 +1,331 @@
+/*
+ * (C) Copyright 2007
+ * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+ *
+ * Configuation settings for the LPC313X board from Embedded Artists.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#define USE_NAND
+
+/*
+ * If we are developing, we might want to start u-boot from ram
+ * so we MUST NOT initialize critical regs like mem-timing ...
+ */
+#undef CONFIG_SKIP_LOWLEVEL_INIT
+#undef CONFIG_USE_IRQ			/* don't need them anymore */
+#undef CONFIG_CMD_FLASH
+#undef CFG_CLKS_IN_HZ			/* everything, incl board info, in Hz */
+
+/*
+ * SoC Configuration
+ */
+#define CONFIG_LPC313X		1		/* This is a ARM926EJS CPU */
+#define CONFIG_ARM_THUMB	1		/* Use Thumb instruction set */
+/*#define CONFIG_PLL_270		1		* Use 270MHz Clk Freq */
+#define XTAL_IN			12000000	/* Crystal clk freq */
+#define CONFIG_SYS_HZ		(XTAL_IN / 256)	/* decrementer freq in Hz */
+#define CONFIG_SYS_NO_FLASH			/* No NOR flash */
+
+/* LPC313x U-boot bootmode support.
+ * The following defines effect which low-level boot mode
+ * is supported to boot u-boot images.
+ */
+#if 0
+#define CONFIG_CPU_NAND_BOOT
+#define CONFIG_CPU_SPI_BOOT
+#define CONFIG_CPU_USBDFU_BOOT
+#endif
+#define CONFIG_CPU_MMC_BOOT
+#if 0
+#define CONFIG_CPU_NOR_BOOT
+#define CONFIG_CPU_UART_BOOT
+#endif
+
+#define CONFIG_LPC313x_BOOT_HEADER
+
+/*
+ * Memory Info
+ */
+#define CONFIG_SYS_TEXT_BASE		0x31200000
+
+
+#define CONFIG_NR_DRAM_BANKS	1		/* we have 1 bank of DRAM */
+#define PHYS_SDRAM		0x30000000	/* SDRAM Bank #1 */
+#define PHYS_SDRAM_SIZE		0x04000000	/* 64 MB SDRAM */
+
+#define CONFIG_SYS_SDRAM_BASE	PHYS_SDRAM
+#define CONFIG_SYS_SDRAM_SIZE	PHYS_SDRAM_SIZE
+
+#define CONFIG_SYS_INIT_RAM_ADDR	0x11029000
+#define CONFIG_SYS_INIT_RAM_SIZE	0x00018000
+#define CONFIG_SYS_GBL_DATA_OFFSET	(CONFIG_SYS_INIT_RAM_SIZE - \
+						GENERATED_GBL_DATA_SIZE)
+#define CONFIG_SYS_INIT_SP_ADDR	(CONFIG_SYS_INIT_RAM_ADDR + \
+						CONFIG_SYS_GBL_DATA_OFFSET)
+
+/* Defines for SPL */
+#define CONFIG_SPL
+
+#define CONFIG_SPL_LIBGENERIC_SUPPORT
+#define CONFIG_SPL_LIBCOMMON_SUPPORT
+
+#if 0
+#define CONFIG_SPL_LIBCOMMON_SUPPORT
+#define CONFIG_SPL_LIBGENERIC_SUPPORT
+#define CONFIG_SPL_LIBDISK_SUPPORT
+#define CONFIG_SPL_NAND_SUPPORT
+#define CONFIG_SPL_SPI_SUPPORT
+#define CONFIG_SPL_SPI_FLASH_SUPPORT
+#endif
+#define CONFIG_SPL_MMC_SUPPORT
+#if 0
+#define CONFIG_SPL_SERIAL_SUPPORT
+#define CONFIG_SPL_USB_GADGET_SUPPORT
+#endif
+#define CONFIG_SPL_LDSCRIPT		"$(CPUDIR)/lpc313x/u-boot-spl.lds"
+
+#define CONFIG_SPL_TEXT_BASE		0x11029000	/* CONFIG_SYS_INIT_RAM_ADDR */
+#define CONFIG_SPL_MAX_SIZE		0x00014000	/* CONFIG_SYS_INIT_RAM_SIZE */
+#define CONFIG_SPL_STACK		0x1103B000	/* CONFIG_SYS_INIT_SP_ADDR */
+
+#define CONFIG_SPL_BSS_START_ADDR	0x30000000	/* PHYS_SDRAM */
+#define CONFIG_SPL_BSS_MAX_SIZE		0x80000
+
+#define CONFIG_BOARD_LATE_INIT
+
+/*
+ * U-Boot memory configuration
+ */
+#define CONFIG_STACKSIZE		(32 * 1024)	/* regular stack */
+#ifdef CONFIG_USE_IRQ
+#define CONFIG_STACKSIZE_IRQ		(4*1024)	/* IRQ stack */
+#define CONFIG_STACKSIZE_FIQ		(4*1024)	/* FIQ stack */
+#endif
+#define CONFIG_SYS_MALLOC_LEN		(1 * 1024 * 1024)		/* No need for any malloc space, we steal from the end of the DRAM */
+#define CONFIG_SYS_GBL_DATA_SIZE	128		/* size in bytes reserved for initial data */
+#define CONFIG_SYS_MEMTEST_START	0x30000000	/* memtest works on */
+#define CONFIG_SYS_MEMTEST_END		0x33FFFFFF	/* 64MB of DRAM */
+
+/* 
+ * Ethernet Driver 7 Network Configuratin.
+ * */
+#define CONFIG_CMD_NET
+#define CONFIG_DRIVER_DM9000		1
+#define CONFIG_DM9000_BASE		0x20020000
+#define DM9000_IO			CONFIG_DM9000_BASE
+#define DM9000_DATA			(CONFIG_DM9000_BASE + 0x10000)
+#define CONFIG_NET_MULTI
+#define CONFIG_CMD_DHCP			1
+#define CONFIG_CMD_PING			1
+#define CONFIG_NET_RETRY_COUNT		100
+/*
+ * Uncomment this below line if you want static IP
+ * support. Don't forget to change "net_boot" command.
+ * In "net_boot" command, use tftpboot instead of dhcp.
+ */
+#if 0
+#define CONFIG_IPADDR			192.168.1.60
+#define CONFIG_SERVERIP			192.168.1.45
+#define CONFIG_GATEWAYIP		192.168.1.1
+#define CONFIG_NETMASK			255.255.255.0
+#endif
+
+/* Linux boot using network */
+#define CONFIG_BOOTCOMMAND		"run sdmmc_boot"
+
+/*
+ * Serial Driver Console
+ */
+#define CONFIG_SERIAL1			1	/* we use Serial line 1 */
+#define CONFIG_BAUDRATE			115200
+#define CONFIG_SYS_BAUDRATE_TABLE	{ 9600, 19200, 38400, 57600, 115200 }
+
+/*
+ * U-boot Boot configuration
+ */
+#define CONFIG_BOOTFILE			"uImage"
+#define CONFIG_BOOTDELAY		1
+#define CONFIG_EXTRA_ENV_SETTINGS	\
+"loadaddr=0x31000000\0" \
+"rd_addr=0x32000000\0" \
+"usbtty=cdc_acm\0" \
+"ramargs=setenv bootargs console=ttyS0,115200n8 root=/dev/mmcblk0p3 init=/etc/preinit rw ip=182.168.1.180 loglevel=7\0" \
+"serverip=192.168.1.48\0" \
+"nfsargs=setenv bootargs console=ttyS0,115200n8 root=/dev/nfs init=/etc/preinit rw nfsroot=${serverip}:${rootpath} ip=dhcp loglevel=7\0" \
+"rootpath=/tftpboot/arm\0" \
+"bootfile=uImage\0" \
+"ramfile=rootfs.ext2.gz.uboot\0" \
+"net_boot=dhcp; run nfsargs; bootm $(loadaddr)\0" \
+"spi_boot= sf probe 0 0 0; sf read $(loadaddr) 0x42000 0x200000; run nfsargs; bootm $(loadaddr)\0" \
+"nand_boot= nand read $(loadaddr) 0x80000 0x200000; run ramargs; bootm $(loadaddr)\0" \
+"sdmmc_boot= mmc init; fatload mmc 0 $(loadaddr) $(bootfile); run ramargs; bootm $(loadaddr)\0" \
+"usbdfu_boot= usbpoll $(loadaddr); run nfsargs; bootm $(loadaddr)\0" \
+"usb_boot= usb start; fatload usb 0 $(loadaddr) $(bootfile); run nfsargs; bootm $(loadaddr)\0" \
+"uart_boot= loady; run nfsargs; bootm $(loadaddr)\0" \
+"netram_boot=dhcp; tftp $(rd_addr) $(ramfile); run ramargs; bootm $(loadaddr) $(rd_addr)\0" \
+"spiram_boot= sf probe 0 0 0; sf read $(loadaddr) 0x42000 0x200000; sf read $(rd_addr) 0x243000 0x400000; run ramargs; bootm $(loadaddr) $(rd_addr)\0" \
+"nandram_boot= nand read $(loadaddr) 0x80000 0x200000; nand read $(rd_addr) 0x2a0000 0x400000; run ramargs; bootm $(loadaddr) $(rd_addr)\0" \
+"sdmmcram_boot= mmc init; fatload mmc 0 $(loadaddr) $(bootfile); fatload mmc 0 $(rd_addr) $(ramfile); run ramargs; bootm $(loadaddr) $(rd_addr)\0" \
+"usbdfuram_boot= usbpoll $(loadaddr); usbpoll $(rd_addr); run ramargs; bootm $(loadaddr) $(rd_addr)\0" \
+"usbram_boot= usb start; fatload usb 0 $(loadaddr) $(bootfile); fatload usb 0 $(rd_addr) $(ramfile); run ramargs; bootm $(loadaddr) $(rd_addr)\0" \
+"uartram_boot= loady; loady $(rd_addr); run ramargs; bootm $(loadaddr) $(rd_addr)\0" \
+""
+
+/*
+ * Linux interfacing
+ */
+#define CONFIG_CMDLINE_TAG
+#define CONFIG_SETUP_MEMORY_TAGS
+#define CONFIG_INITRD_TAG
+#define CONFIG_SYS_MAXARGS		16			/* max number of command args	*/
+#define CONFIG_SYS_BARGSIZE		CONFIG_SYS_CBSIZE	/* Boot Argument Buffer Size	*/
+
+/*
+ * U-boot geneal configurable
+ */
+#define CONFIG_SYS_LONGHELP				/* undef to save memory */
+#ifndef CONFIG_EA3152
+#define CONFIG_SYS_PROMPT		"EA3131-NXP # "	/* Monitor Command Prompt */
+#else
+#define CONFIG_SYS_PROMPT		"EA3152-NXP # "	/* Monitor Command Prompt */
+#endif
+
+#define CONFIG_SYS_CBSIZE		256		/* Console I/O Buffer Size */
+#define CONFIG_SYS_PBSIZE		(CONFIG_SYS_CBSIZE+sizeof(CONFIG_SYS_PROMPT)+16) 
+#define CONFIG_SYS_LOAD_ADDR		11029000
+#define CONFIG_ENV_OVERWRITE		/* allow to overwrite serial and ethaddr */
+#define CONFIG_AUTO_COMPLETE
+#define CONFIG_CMDLINE_EDITING
+#define CONFIG_PANIC_HANG
+
+#include <config_cmd_default.h>
+/*
+ * U-boot Generic Command line configuration.
+ */
+#define CONFIG_CMD_AUTOSCRIPT	/* Autoscript Support */
+#define CONFIG_CMD_BDI		/* bdinfo */
+#define CONFIG_CMD_BOOTD	/* bootd */
+#define CONFIG_CMD_CONSOLE	/* coninfo */
+#define CONFIG_CMD_ECHO		/* echo arguments */
+#define CONFIG_CMD_SAVEENV	/* saveenv */
+#define CONFIG_CMD_IMI		/* iminfo */
+#define CONFIG_CMD_MISC		/* Misc functions like sleep etc*/
+#define CONFIG_CMD_RUN		/* run command in env variable */
+#define CONFIG_CMD_SETGETDCR	/* DCR support on 4xx */
+#define CONFIG_CMD_XIMG		/* Load part of Multi Image */
+#define CONFIG_CMD_MEMORY	/* Use for Memory*/
+#define CONFIG_CMD_LOADB
+#define CONFIG_MISC_INIT_R
+/*
+ * Flash (NAND,SPINOR) configuration
+ */
+/* Micron NAND Flash support */
+#define CONFIG_CMD_NAND			1
+#define CONFIG_NAND_LPC313X		1
+/* #define CONFIG_ENV_IS_IN_NAND 	1 */
+#define LPC313X_NAND_LP_SUPPORT		1
+#define CONFIG_SYS_NAND_BASE		0x00000000
+#define CONFIG_SYS_MAX_NAND_DEVICE	1		/* Max number of NAND devices */
+#define NAND_MAX_CHIPS			1
+
+/* ATMEL SPI based NOR Flash support */
+#define CONFIG_HARD_SPI			1
+#define CONFIG_LPC313X_SPI		1
+#define CONFIG_SPI_FLASH		1
+#define CONFIG_SPI_FLASH_ATMEL		1
+#define CONFIG_CMD_SF			1
+#define CONFIG_ENV_IS_IN_SPI_FLASH	1
+
+#ifdef CONFIG_ENV_IS_IN_NAND
+#ifdef LPC313X_NAND_LP_SUPPORT
+#define CONFIG_ENV_OFFSET		0x60000		/* Addr of Environment Sector */
+#define CONFIG_ENV_SIZE			0x20000		/* Total Size of Environment Sector */
+#else
+#define CONFIG_ENV_OFFSET		0x20000		/* Addr of Environment Sector */
+#define CONFIG_ENV_SIZE			0x4000		/* Total Size of Environment Sector */
+#endif
+#else
+
+#ifdef CONFIG_ENV_IS_IN_SPI_FLASH
+#define CONFIG_ENV_SIZE			0x1000		/* Total Size of Environment Sector */
+#define CONFIG_ENV_SECT_SIZE		0x10000
+#define CONFIG_ENV_OFFSET		0x40000
+
+#else
+#define CONFIG_ENV_OFFSET		0x00		/* Addr of Environment Sector */
+#define CONFIG_ENV_SIZE			0x800		/* Total Size of Environment Sector */
+#define CONFIG_ENV_IS_NOWHERE		1
+
+#endif
+#endif
+
+#define CONFIG_SYS_I2C_SPEED		100000
+
+#define CONFIG_OF_LIBFDT
+
+/* Uncomment if you want USB host support and
+ * disable USB gadget supoprt. Please note if
+ * you disable USB gadget support, USB DFU boot
+ * mode will not work.
+ */
+/*
+ * USB configuration as EHCI HOST
+ */
+
+#define CONFIG_CMD_USB
+#define CONFIG_USB_EHCI			/* Enable EHCI USB support */
+#define CONFIG_USB_EHCI_LPC313X		/* on LPC313X platform */
+#define CONFIG_EHCI_IS_TDI
+#define CONFIG_USB_STORAGE
+#define CONFIG_SUPPORT_VFAT
+/*#undef CONFIG_CPU_USBDFU_BOOT*/
+
+
+/*
+ * USB configuration as GADGET
+ */
+#define CONFIG_USB_DEVICE		1
+#define CONFIG_USB_TTY			1
+#define CONFIG_SYS_CONSOLE_IS_IN_ENV	1
+#define CONFIG_USBD_VENDORID		0x1457	/* Linux/NetChip */
+#define CONFIG_USBD_PRODUCTID_CDCACM	0x5119	/* CDC ACM */
+#define CONFIG_USBD_MANUFACTURER	"OpenMoko, Inc"
+#define CONFIG_USBD_PRODUCT_NAME	"LPC313x Bootloader " U_BOOT_VERSION
+#define CONFIG_USB_DFU			1
+#define CONFIG_USBD_DFU_XFER_SIZE	4096	/* 0x1000 */
+#define CONFIG_USBD_DFU_INTERFACE	2
+
+/*
+ * MMC Driver configuration
+ */
+#define CONFIG_CMD_MMC			1
+#define CONFIG_MMC			1
+
+#define CONFIG_CMD_FAT			1
+#define CONFIG_DOS_PARTITION
+#define CONFIG_ISO_PARTITION 
+
+
+
+#endif /* __CONFIG_H */
diff --git a/include/usb/lpc313x_udc.h b/include/usb/lpc313x_udc.h
new file mode 100644
index 0000000..d58510d
--- /dev/null
+++ b/include/usb/lpc313x_udc.h
@@ -0,0 +1,227 @@
+/*
+ * (C) Copyright 2010 NXP Semiconductors
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __USBDCORE_LPC313X_H__
+#define __USBDCORE_LPC313X_H__
+
+#include <asm/arch/hardware.h>
+
+/* USB Module Register Structure */
+typedef volatile struct
+{
+	/*Capability registers*/
+	volatile u8 caplength;
+	volatile u8 _otg1[1];
+	volatile u16 hciversion;
+	volatile u32 hcsparams;
+	volatile u32 hccparams;
+	volatile u32 _otg2[5];
+	volatile u16 dciversion;
+	volatile u16 _otg3[1];
+	volatile u32 dccparams;
+	volatile u32 _otg4a[4];
+	volatile u32 usb_up_int;
+	volatile u32 _otg4b[1];
+	/* Operational registers */
+	volatile u32 usbcmd;
+	volatile u32 usbsts;
+	volatile u32 usbintr;
+	volatile u32 frindex;
+	volatile u32 _otg5[1];
+	volatile u32 periodiclistbase__deviceaddr;
+	volatile u32 asynclistaddr__endpointlistaddr;
+	volatile u32 ttctrl;
+	volatile u32 burstsize;
+	volatile u32 txfilltuning;
+	volatile u32 txttfilltuning;
+	volatile u32 _otg6[1];
+	volatile u32 _otg7[2];
+	volatile u32 endptnak;
+	volatile u32 endptnaken;
+	volatile u32 configflag;
+	volatile u32 portsc1;
+	volatile u32 _otg8[7];
+	volatile u32 otgsc;
+	volatile u32 usbmode;
+	volatile u32 endptsetupstat;
+	volatile u32 endptprime;
+	volatile u32 endptflush;
+	volatile u32 endptstatus;
+	volatile u32 endptcomplete;
+	volatile u32 endptctrl[4];
+} USB_OTG_REGS_T;
+
+/* dTD Transfer Description */
+typedef volatile struct
+{
+	volatile u32 next_dTD;
+	volatile u32 total_bytes;
+	volatile u32 buffer0;
+	volatile u32 buffer1;
+	volatile u32 buffer2;
+	volatile u32 buffer3;
+	volatile u32 buffer4;
+	volatile u32 reserved;
+} DTD_T;
+
+/* dQH Queue Head */
+typedef volatile struct
+{
+	volatile u32 cap;
+	volatile u32 curr_dTD;
+	volatile u32 next_dTD;
+	volatile u32 total_bytes;
+	volatile u32 buffer0;
+	volatile u32 buffer1;
+	volatile u32 buffer2;
+	volatile u32 buffer3;
+	volatile u32 buffer4;
+	volatile u32 reserved;
+	volatile u32 setup[2];
+	volatile u32 gap[4];
+} DQH_T;
+
+/* bit defines for USBCMD register */
+#define USBCMD_RS		_BIT(0)
+#define USBCMD_RST		_BIT(1)
+#define USBCMD_ATDTW		_BIT(12)
+#define USBCMD_SUTW		_BIT(13)
+
+/* bit defines for USBSTS register */
+#define USBSTS_UI		_BIT(0)
+#define USBSTS_UEI		_BIT(1)
+#define USBSTS_PCI		_BIT(2)
+#define USBSTS_URI		_BIT(6)
+#define USBSTS_SRI		_BIT(7)
+#define USBSTS_SLI		_BIT(8)
+#define USBSTS_NAKI		_BIT(16)
+
+/* bit defines for DEVICEADDR register */
+#define USBDEV_ADDR_AD		_BIT(24)
+#define USBDEV_ADDR(n)		_SBF(25, ((n) & 0x7F))
+
+/* bit defines for PRTSC1 register */
+#define USBPRTS_CCS		_BIT(0)
+#define USBPRTS_PE		_BIT(2)
+#define USBPRTS_FPR		_BIT(6)
+#define USBPRTS_SUSP		_BIT(7)
+#define USBPRTS_PR		_BIT(8)
+#define USBPRTS_HSP		_BIT(9)
+#define USBPRTS_PLPSCD		_BIT(23)
+#define USBPRTS_PFSC		_BIT(24)
+
+/* bit defines for USBMODE register */
+#define USBMODE_CM_IDLE		_SBF(0, 0x0)
+#define USBMODE_CM_DEV		_SBF(0, 0x2)
+#define USBMODE_CM_HOST		_SBF(0, 0x3)
+#define USBMODE_SLOM		_BIT(3)
+#define USBMODE_SDIS		_BIT(4)
+
+/* bit defines for EP registers*/
+#define USB_EP_BITPOS(n) (((n) & 0x80)? (0x10 | ((n) & 0x7)) : ((n) & 0x7))
+
+/* bit defines EPcontrol registers*/
+#define EPCTRL_RXS		_BIT(0)
+#define EPCTRL_RX_TYPE(n)	_SBF(2,((n) & 0x3))
+#define EPCTRL_RX_CTL		_SBF(2,0)
+#define EPCTRL_RX_ISO		_SBF(2,1)
+#define EPCTRL_RX_BLK		_SBF(2,2)
+#define EPCTRL_RXI		_BIT(5)
+#define EPCTRL_RXR		_BIT(6)
+#define EPCTRL_RXE		_BIT(7)
+#define EPCTRL_TXS		_BIT(16)
+#define EPCTRL_TX_TYPE(n) _SBF(18,((n) & 0x3))
+#define EPCTRL_TX_CTL		_SBF(18,0)
+#define EPCTRL_TX_ISO		_SBF(18,1)
+#define EPCTRL_TX_BLK		_SBF(18,2)
+#define EPCTRL_TX_INT		_SBF(18,3)
+#define EPCTRL_TXI		_BIT(21)
+#define EPCTRL_TXR		_BIT(22)
+#define EPCTRL_TXE		_BIT(23)
+
+/* dQH field and bit defines */
+/* Temp fixed on max, should be taken out of table */
+#define QH_MAX_CTRL_PAYLOAD	0x03ff
+#define QH_MAX_PKT_LEN_POS	16
+#define QH_MAXP(n)		_SBF(16,((n) & 0x3FF))
+#define QH_IOS			_BIT(15)
+#define QH_ZLT			_BIT(29)
+
+/* dTD field and bit defines */
+#define TD_NEXT_TERMINATE	_BIT(0)
+#define TD_IOC			_BIT(15)
+
+/* Total physical enpoints*/
+#define EP_NUM_MAX		8
+
+/**********************************************************************
+ * * Macro to access USB_OTG registers
+ * **********************************************************************/
+#define USB_OTG	((USB_OTG_REGS_T *)(USBOTG_BASE + 0x100))
+
+/* LPC313X Endpoint parameters */
+#define EP0_MAX_PACKET_SIZE	64
+#define UDC_OUT_ENDPOINT	2
+#define UDC_OUT_PACKET_SIZE	64
+#define UDC_IN_ENDPOINT		3
+#define UDC_IN_PACKET_SIZE	64
+#define UDC_INT_ENDPOINT	5
+#define UDC_INT_PACKET_SIZE	64
+#define UDC_BULK_PACKET_SIZE	512
+
+/* UDC Endpoints events */
+#define USB_EVT_SETUP		1
+#define USB_EVT_OUT_COMPLETE	2
+#define USB_EVT_IN_COMPLETE	3
+#define USB_EVT_OUT_NAK		4
+#define USB_EVT_IN_NAK		5
+#define USB_EVT_OUT_STALL	6
+#define USB_EVT_IN_STALL	7
+
+/* States for Endpoint0 during Control X'fer */
+#define EP0_IDLE		0
+#define EP0_IN_DATA		1
+#define EP0_OUT_DATA		2
+#define EP0_STATUS_OUT		3
+#define EP0_STATUS_IN		4
+
+void udc_irq (void);
+/* Flow control */
+void udc_set_nak(int epid);
+void udc_unset_nak (int epid);
+
+/* Higher level functions for abstracting away from specific device */
+int udc_endpoint_write(struct usb_endpoint_instance *endpoint);
+
+int udc_init (void);
+
+void udc_enable(struct usb_device_instance *device);
+void udc_disable(void);
+
+void udc_connect(void);
+void udc_disconnect(void);
+
+void udc_startup_events(struct usb_device_instance *device);
+void udc_setup_ep(struct usb_device_instance *device, unsigned int ep,
+			struct usb_endpoint_instance *endpoint);
+
+#endif
diff --git a/include/usb_dfu.h b/include/usb_dfu.h
new file mode 100644
index 0000000..aa1ead3
--- /dev/null
+++ b/include/usb_dfu.h
@@ -0,0 +1,94 @@
+#ifndef _DFU_H
+#define _DFU_H
+
+/* USB Device Firmware Update Implementation for u-boot
+ * (C) 2007 by OpenMoko, Inc.
+ * Author: Harald Welte <laforge@openmoko.org>
+ *
+ * based on: USB Device Firmware Update Implementation for OpenPCD
+ * (C) 2006 by Harald Welte <hwelte@hmw-consulting.de>
+ *
+ * This ought to be compliant to the USB DFU Spec 1.0 as available from
+ * http://www.usb.org/developers/devclass_docs/usbdfu10.pdf
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <asm/types.h>
+#include <usbdescriptors.h>
+#include <usb_dfu_descriptors.h>
+#include <config.h>
+
+/* USB DFU functional descriptor */
+#define DFU_FUNC_DESC  {						\
+	.bLength		= USB_DT_DFU_SIZE,			\
+	.bDescriptorType	= USB_DT_DFU,				\
+	.bmAttributes		= USB_DFU_CAN_DOWNLOAD | USB_DFU_CAN_UPLOAD | USB_DFU_MANIFEST_TOL, \
+	.wDetachTimeOut		= 0xff00,				\
+	.wTransferSize		= CONFIG_USBD_DFU_XFER_SIZE,		\
+	.bcdDFUVersion		= 0x0100,				\
+}
+
+/* USB Interface descriptor in Runtime mode */
+#define DFU_RT_IF_DESC	{						\
+	.bLength		= USB_DT_INTERFACE_SIZE,		\
+	.bDescriptorType	= USB_DT_INTERFACE,			\
+	.bInterfaceNumber	= CONFIG_USBD_DFU_INTERFACE,		\
+	.bAlternateSetting	= 0x00,					\
+	.bNumEndpoints		= 0x00,					\
+	.bInterfaceClass	= 0xfe,					\
+	.bInterfaceSubClass	= 0x01,					\
+	.bInterfaceProtocol	= 0x01,					\
+	.iInterface		= DFU_STR_CONFIG,			\
+}
+
+#define ARRAY_SIZE(x)           (sizeof(x) / sizeof((x)[0]))
+
+#ifndef DFU_NUM_ALTERNATES
+#define DFU_NUM_ALTERNATES	1
+#endif
+
+#define DFU_STR_MANUFACTURER	STR_MANUFACTURER
+#define DFU_STR_PRODUCT		STR_PRODUCT
+#define DFU_STR_SERIAL		STR_SERIAL
+#define DFU_STR_CONFIG		(STR_COUNT)
+#define DFU_STR_ALT(n)		(STR_COUNT+(n)+1)
+#define DFU_STR_COUNT		DFU_STR_ALT(DFU_NUM_ALTERNATES)
+
+#define CONFIG_DFU_CFG_STR	"USB Device Firmware Upgrade"
+#define CONFIG_DFU_ALT0_STR	"RAM memory"
+
+struct _dfu_desc {
+	struct usb_configuration_descriptor ucfg;
+	struct usb_interface_descriptor uif[DFU_NUM_ALTERNATES];
+	struct usb_dfu_func_descriptor func_dfu;
+};
+
+int dfu_init_instance(struct usb_device_instance *dev);
+
+#define DFU_EP0_NONE		0
+#define DFU_EP0_UNHANDLED	1
+#define DFU_EP0_STALL		2
+#define DFU_EP0_ZLP		3
+#define DFU_EP0_DATA		4
+
+extern volatile enum dfu_state *system_dfu_state; /* for 3rd parties */
+
+int dfu_ep0_handler(struct urb *urb);
+
+void dfu_event(struct usb_device_instance *device,
+	       usb_device_event_t event, int data);
+
+#endif /* _DFU_H */
diff --git a/include/usb_dfu_descriptors.h b/include/usb_dfu_descriptors.h
new file mode 100644
index 0000000..d4d6a4d
--- /dev/null
+++ b/include/usb_dfu_descriptors.h
@@ -0,0 +1,94 @@
+#ifndef _USB_DFU_H
+#define _USB_DFU_H
+/* USB Device Firmware Update Implementation for OpenPCD
+ * (C) 2006 by Harald Welte <hwelte@hmw-consulting.de>
+ *
+ * Protocol definitions for USB DFU
+ *
+ * This ought to be compliant to the USB DFU Spec 1.0 as available from
+ * http://www.usb.org/developers/devclass_docs/usbdfu10.pdf
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/types.h>
+
+#define USB_DT_DFU			0x21
+
+struct usb_dfu_func_descriptor {
+	u_int8_t		bLength;
+	u_int8_t		bDescriptorType;
+	u_int8_t		bmAttributes;
+#define USB_DFU_CAN_DOWNLOAD	(1 << 0)
+#define USB_DFU_CAN_UPLOAD	(1 << 1)
+#define USB_DFU_MANIFEST_TOL	(1 << 2)
+#define USB_DFU_WILL_DETACH	(1 << 3)
+	u_int16_t		wDetachTimeOut;
+	u_int16_t		wTransferSize;
+	u_int16_t		bcdDFUVersion;
+} __attribute__ ((packed));
+
+#define USB_DT_DFU_SIZE			9
+
+#define USB_TYPE_DFU		(USB_TYPE_CLASS|USB_RECIP_INTERFACE)
+
+/* DFU class-specific requests (Section 3, DFU Rev 1.1) */
+#define USB_REQ_DFU_DETACH	0x00
+#define USB_REQ_DFU_DNLOAD	0x01
+#define USB_REQ_DFU_UPLOAD	0x02
+#define USB_REQ_DFU_GETSTATUS	0x03
+#define USB_REQ_DFU_CLRSTATUS	0x04
+#define USB_REQ_DFU_GETSTATE	0x05
+#define USB_REQ_DFU_ABORT	0x06
+
+struct dfu_status {
+	u_int8_t bStatus;
+	u_int8_t bwPollTimeout[3];
+	u_int8_t bState;
+	u_int8_t iString;
+} __attribute__((packed));
+
+#define DFU_STATUS_OK			0x00
+#define DFU_STATUS_errTARGET		0x01
+#define DFU_STATUS_errFILE		0x02
+#define DFU_STATUS_errWRITE		0x03
+#define DFU_STATUS_errERASE		0x04
+#define DFU_STATUS_errCHECK_ERASED	0x05
+#define DFU_STATUS_errPROG		0x06
+#define DFU_STATUS_errVERIFY		0x07
+#define DFU_STATUS_errADDRESS		0x08
+#define DFU_STATUS_errNOTDONE		0x09
+#define DFU_STATUS_errFIRMWARE		0x0a
+#define DFU_STATUS_errVENDOR		0x0b
+#define DFU_STATUS_errUSBR		0x0c
+#define DFU_STATUS_errPOR		0x0d
+#define DFU_STATUS_errUNKNOWN		0x0e
+#define DFU_STATUS_errSTALLEDPKT	0x0f
+
+enum dfu_state {
+	DFU_STATE_appIDLE		= 0,
+	DFU_STATE_appDETACH		= 1,
+	DFU_STATE_dfuIDLE		= 2,
+	DFU_STATE_dfuDNLOAD_SYNC	= 3,
+	DFU_STATE_dfuDNBUSY		= 4,
+	DFU_STATE_dfuDNLOAD_IDLE	= 5,
+	DFU_STATE_dfuMANIFEST_SYNC	= 6,
+	DFU_STATE_dfuMANIFEST		= 7,
+	DFU_STATE_dfuMANIFEST_WAIT_RST	= 8,
+	DFU_STATE_dfuUPLOAD_IDLE	= 9,
+	DFU_STATE_dfuERROR		= 10,
+};
+
+#endif /* _USB_DFU_H */
diff --git a/include/usbdevice.h b/include/usbdevice.h
index 4171636..434879c 100644
--- a/include/usbdevice.h
+++ b/include/usbdevice.h
@@ -33,7 +33,7 @@
 
 #include <common.h>
 #include "usbdescriptors.h"
-
+#include <usb_dfu_descriptors.h>
 
 #define MAX_URBS_QUEUED 5
 
@@ -467,7 +467,11 @@ typedef struct urb_link {
  * function driver to inform it that data has arrived.
  */
 
+#ifdef CONFIG_USB_DFU
+#define URB_BUF_SIZE (128 + CONFIG_USBD_DFU_XFER_SIZE)
+#else
 #define URB_BUF_SIZE 128 /* in linux we'd malloc this, but in u-boot we prefer static data */
+#endif
 struct urb {
 
 	struct usb_endpoint_instance *endpoint;
@@ -595,6 +599,12 @@ struct usb_device_instance {
 	unsigned long usbd_rxtx_timestamp;
 	unsigned long usbd_last_rxtx_timestamp;
 
+#ifdef CONFIG_USB_DFU
+        const struct usb_device_descriptor *dfu_dev_desc;
+        const struct _dfu_desc *dfu_cfg_desc;
+        enum dfu_state dfu_state;
+        u_int8_t dfu_status;
+#endif
 };
 
 /* Bus Interface configuration structure
@@ -624,6 +634,8 @@ extern char *usbd_device_status[];
 extern char *usbd_device_requests[];
 extern char *usbd_device_descriptors[];
 
+extern struct usb_string_descriptor **usb_strings;
+
 void urb_link_init (urb_link * ul);
 void urb_detach (struct urb *urb);
 urb_link *first_urb_link (urb_link * hd);
diff --git a/lib/Makefile b/lib/Makefile
index 54708c2..9f6d02c 100644
--- a/lib/Makefile
+++ b/lib/Makefile
@@ -24,6 +24,7 @@
 include $(TOPDIR)/config.mk
 
 LIB	= $(obj)libgeneric.o
+COBJS-y += crc32.o
 
 ifndef CONFIG_SPL_BUILD
 COBJS-$(CONFIG_ADDR_MAP) += addr_map.o
@@ -32,11 +33,8 @@ COBJS-$(CONFIG_BZIP2) += bzlib_crctable.o
 COBJS-$(CONFIG_BZIP2) += bzlib_decompress.o
 COBJS-$(CONFIG_BZIP2) += bzlib_randtable.o
 COBJS-$(CONFIG_BZIP2) += bzlib_huffman.o
-COBJS-$(CONFIG_USB_TTY) += circbuf.o
 COBJS-y += crc7.o
 COBJS-y += crc16.o
-COBJS-y += crc32.o
-COBJS-y += display_options.o
 COBJS-y += errno.o
 COBJS-$(CONFIG_OF_CONTROL) += fdtdec.o
 COBJS-$(CONFIG_GZIP) += gunzip.o
@@ -51,6 +49,8 @@ COBJS-$(CONFIG_SHA256) += sha256.o
 COBJS-y	+= strmhz.o
 COBJS-$(CONFIG_RBTREE)	+= rbtree.o
 endif
+COBJS-$(CONFIG_USB_TTY) += circbuf.o
+COBJS-y += display_options.o
 
 COBJS-y += ctype.o
 COBJS-y += div64.o
diff --git a/spl/Makefile b/spl/Makefile
index 6ac42a2..6ac70eb 100644
--- a/spl/Makefile
+++ b/spl/Makefile
@@ -57,6 +57,7 @@ LIBS-$(CONFIG_SPL_NAND_SUPPORT) += drivers/mtd/nand/libnand.o
 LIBS-$(CONFIG_SPL_ONENAND_SUPPORT) += drivers/mtd/onenand/libonenand.o
 LIBS-$(CONFIG_SPL_DMA_SUPPORT) += drivers/dma/libdma.o
 LIBS-$(CONFIG_SPL_POST_MEM_SUPPORT) += post/drivers/memory.o
+LIBS-$(CONFIG_SPL_USB_GADGET_SUPPORT) += drivers/usb/gadget/libusb_gadget.o
 
 ifeq ($(SOC),omap3)
 LIBS-y += $(CPUDIR)/omap-common/libomap-common.o
